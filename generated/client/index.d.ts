
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Users
 * 
 */
export type Users = $Result.DefaultSelection<Prisma.$UsersPayload>
/**
 * Model Course
 * 
 */
export type Course = $Result.DefaultSelection<Prisma.$CoursePayload>
/**
 * Model CourseCreator
 * 
 */
export type CourseCreator = $Result.DefaultSelection<Prisma.$CourseCreatorPayload>
/**
 * Model CourseLogging
 * 
 */
export type CourseLogging = $Result.DefaultSelection<Prisma.$CourseLoggingPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model SubCategory
 * 
 */
export type SubCategory = $Result.DefaultSelection<Prisma.$SubCategoryPayload>
/**
 * Model Topic
 * 
 */
export type Topic = $Result.DefaultSelection<Prisma.$TopicPayload>
/**
 * Model CourseTopic
 * 
 */
export type CourseTopic = $Result.DefaultSelection<Prisma.$CourseTopicPayload>
/**
 * Model Syllabus
 * 
 */
export type Syllabus = $Result.DefaultSelection<Prisma.$SyllabusPayload>
/**
 * Model SyllabusContent
 * 
 */
export type SyllabusContent = $Result.DefaultSelection<Prisma.$SyllabusContentPayload>
/**
 * Model Exam
 * 
 */
export type Exam = $Result.DefaultSelection<Prisma.$ExamPayload>
/**
 * Model ExamQuestion
 * 
 */
export type ExamQuestion = $Result.DefaultSelection<Prisma.$ExamQuestionPayload>
/**
 * Model ExamOptionQuestion
 * 
 */
export type ExamOptionQuestion = $Result.DefaultSelection<Prisma.$ExamOptionQuestionPayload>
/**
 * Model MaterialContentType
 * 
 */
export type MaterialContentType = $Result.DefaultSelection<Prisma.$MaterialContentTypePayload>
/**
 * Model MaterialContent
 * 
 */
export type MaterialContent = $Result.DefaultSelection<Prisma.$MaterialContentPayload>
/**
 * Model MaterialContentLearning
 * 
 */
export type MaterialContentLearning = $Result.DefaultSelection<Prisma.$MaterialContentLearningPayload>
/**
 * Model MaterialContentTest
 * 
 */
export type MaterialContentTest = $Result.DefaultSelection<Prisma.$MaterialContentTestPayload>
/**
 * Model MaterialContentFile
 * 
 */
export type MaterialContentFile = $Result.DefaultSelection<Prisma.$MaterialContentFilePayload>
/**
 * Model MaterialContentAttachment
 * 
 */
export type MaterialContentAttachment = $Result.DefaultSelection<Prisma.$MaterialContentAttachmentPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const CourseAs: {
  OWNER: 'OWNER',
  COLLABORATOR: 'COLLABORATOR'
};

export type CourseAs = (typeof CourseAs)[keyof typeof CourseAs]


export const SyllabusContentType: {
  EXAM: 'EXAM',
  MATERIAL: 'MATERIAL'
};

export type SyllabusContentType = (typeof SyllabusContentType)[keyof typeof SyllabusContentType]


export const TypeQuestion: {
  MULTIPLE_CHOICE: 'MULTIPLE_CHOICE',
  MULTIPLE_CHOICE_COMPLEX: 'MULTIPLE_CHOICE_COMPLEX'
};

export type TypeQuestion = (typeof TypeQuestion)[keyof typeof TypeQuestion]


export const TypeMaterialContent: {
  VIDEO: 'VIDEO',
  READING: 'READING',
  PRE_TEST: 'PRE_TEST',
  POST_TEST: 'POST_TEST'
};

export type TypeMaterialContent = (typeof TypeMaterialContent)[keyof typeof TypeMaterialContent]

}

export type CourseAs = $Enums.CourseAs

export const CourseAs: typeof $Enums.CourseAs

export type SyllabusContentType = $Enums.SyllabusContentType

export const SyllabusContentType: typeof $Enums.SyllabusContentType

export type TypeQuestion = $Enums.TypeQuestion

export const TypeQuestion: typeof $Enums.TypeQuestion

export type TypeMaterialContent = $Enums.TypeMaterialContent

export const TypeMaterialContent: typeof $Enums.TypeMaterialContent

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.users.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.users.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.users`: Exposes CRUD operations for the **Users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.UsersDelegate<ExtArgs>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.CourseDelegate<ExtArgs>;

  /**
   * `prisma.courseCreator`: Exposes CRUD operations for the **CourseCreator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseCreators
    * const courseCreators = await prisma.courseCreator.findMany()
    * ```
    */
  get courseCreator(): Prisma.CourseCreatorDelegate<ExtArgs>;

  /**
   * `prisma.courseLogging`: Exposes CRUD operations for the **CourseLogging** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseLoggings
    * const courseLoggings = await prisma.courseLogging.findMany()
    * ```
    */
  get courseLogging(): Prisma.CourseLoggingDelegate<ExtArgs>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs>;

  /**
   * `prisma.subCategory`: Exposes CRUD operations for the **SubCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubCategories
    * const subCategories = await prisma.subCategory.findMany()
    * ```
    */
  get subCategory(): Prisma.SubCategoryDelegate<ExtArgs>;

  /**
   * `prisma.topic`: Exposes CRUD operations for the **Topic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Topics
    * const topics = await prisma.topic.findMany()
    * ```
    */
  get topic(): Prisma.TopicDelegate<ExtArgs>;

  /**
   * `prisma.courseTopic`: Exposes CRUD operations for the **CourseTopic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseTopics
    * const courseTopics = await prisma.courseTopic.findMany()
    * ```
    */
  get courseTopic(): Prisma.CourseTopicDelegate<ExtArgs>;

  /**
   * `prisma.syllabus`: Exposes CRUD operations for the **Syllabus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Syllabi
    * const syllabi = await prisma.syllabus.findMany()
    * ```
    */
  get syllabus(): Prisma.SyllabusDelegate<ExtArgs>;

  /**
   * `prisma.syllabusContent`: Exposes CRUD operations for the **SyllabusContent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SyllabusContents
    * const syllabusContents = await prisma.syllabusContent.findMany()
    * ```
    */
  get syllabusContent(): Prisma.SyllabusContentDelegate<ExtArgs>;

  /**
   * `prisma.exam`: Exposes CRUD operations for the **Exam** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exams
    * const exams = await prisma.exam.findMany()
    * ```
    */
  get exam(): Prisma.ExamDelegate<ExtArgs>;

  /**
   * `prisma.examQuestion`: Exposes CRUD operations for the **ExamQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExamQuestions
    * const examQuestions = await prisma.examQuestion.findMany()
    * ```
    */
  get examQuestion(): Prisma.ExamQuestionDelegate<ExtArgs>;

  /**
   * `prisma.examOptionQuestion`: Exposes CRUD operations for the **ExamOptionQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExamOptionQuestions
    * const examOptionQuestions = await prisma.examOptionQuestion.findMany()
    * ```
    */
  get examOptionQuestion(): Prisma.ExamOptionQuestionDelegate<ExtArgs>;

  /**
   * `prisma.materialContentType`: Exposes CRUD operations for the **MaterialContentType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaterialContentTypes
    * const materialContentTypes = await prisma.materialContentType.findMany()
    * ```
    */
  get materialContentType(): Prisma.MaterialContentTypeDelegate<ExtArgs>;

  /**
   * `prisma.materialContent`: Exposes CRUD operations for the **MaterialContent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaterialContents
    * const materialContents = await prisma.materialContent.findMany()
    * ```
    */
  get materialContent(): Prisma.MaterialContentDelegate<ExtArgs>;

  /**
   * `prisma.materialContentLearning`: Exposes CRUD operations for the **MaterialContentLearning** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaterialContentLearnings
    * const materialContentLearnings = await prisma.materialContentLearning.findMany()
    * ```
    */
  get materialContentLearning(): Prisma.MaterialContentLearningDelegate<ExtArgs>;

  /**
   * `prisma.materialContentTest`: Exposes CRUD operations for the **MaterialContentTest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaterialContentTests
    * const materialContentTests = await prisma.materialContentTest.findMany()
    * ```
    */
  get materialContentTest(): Prisma.MaterialContentTestDelegate<ExtArgs>;

  /**
   * `prisma.materialContentFile`: Exposes CRUD operations for the **MaterialContentFile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaterialContentFiles
    * const materialContentFiles = await prisma.materialContentFile.findMany()
    * ```
    */
  get materialContentFile(): Prisma.MaterialContentFileDelegate<ExtArgs>;

  /**
   * `prisma.materialContentAttachment`: Exposes CRUD operations for the **MaterialContentAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaterialContentAttachments
    * const materialContentAttachments = await prisma.materialContentAttachment.findMany()
    * ```
    */
  get materialContentAttachment(): Prisma.MaterialContentAttachmentDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.17.0
   * Query Engine version: 393aa359c9ad4a4bb28630fb5613f9c281cde053
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Users: 'Users',
    Course: 'Course',
    CourseCreator: 'CourseCreator',
    CourseLogging: 'CourseLogging',
    Category: 'Category',
    SubCategory: 'SubCategory',
    Topic: 'Topic',
    CourseTopic: 'CourseTopic',
    Syllabus: 'Syllabus',
    SyllabusContent: 'SyllabusContent',
    Exam: 'Exam',
    ExamQuestion: 'ExamQuestion',
    ExamOptionQuestion: 'ExamOptionQuestion',
    MaterialContentType: 'MaterialContentType',
    MaterialContent: 'MaterialContent',
    MaterialContentLearning: 'MaterialContentLearning',
    MaterialContentTest: 'MaterialContentTest',
    MaterialContentFile: 'MaterialContentFile',
    MaterialContentAttachment: 'MaterialContentAttachment'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "users" | "course" | "courseCreator" | "courseLogging" | "category" | "subCategory" | "topic" | "courseTopic" | "syllabus" | "syllabusContent" | "exam" | "examQuestion" | "examOptionQuestion" | "materialContentType" | "materialContent" | "materialContentLearning" | "materialContentTest" | "materialContentFile" | "materialContentAttachment"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Users: {
        payload: Prisma.$UsersPayload<ExtArgs>
        fields: Prisma.UsersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findFirst: {
            args: Prisma.UsersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findMany: {
            args: Prisma.UsersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          create: {
            args: Prisma.UsersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          createMany: {
            args: Prisma.UsersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UsersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          update: {
            args: Prisma.UsersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          deleteMany: {
            args: Prisma.UsersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.UsersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      Course: {
        payload: Prisma.$CoursePayload<ExtArgs>
        fields: Prisma.CourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findFirst: {
            args: Prisma.CourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findMany: {
            args: Prisma.CourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          create: {
            args: Prisma.CourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          createMany: {
            args: Prisma.CourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          update: {
            args: Prisma.CourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          deleteMany: {
            args: Prisma.CourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          aggregate: {
            args: Prisma.CourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse>
          }
          groupBy: {
            args: Prisma.CourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCountAggregateOutputType> | number
          }
        }
      }
      CourseCreator: {
        payload: Prisma.$CourseCreatorPayload<ExtArgs>
        fields: Prisma.CourseCreatorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseCreatorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCreatorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseCreatorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCreatorPayload>
          }
          findFirst: {
            args: Prisma.CourseCreatorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCreatorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseCreatorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCreatorPayload>
          }
          findMany: {
            args: Prisma.CourseCreatorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCreatorPayload>[]
          }
          create: {
            args: Prisma.CourseCreatorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCreatorPayload>
          }
          createMany: {
            args: Prisma.CourseCreatorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CourseCreatorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCreatorPayload>
          }
          update: {
            args: Prisma.CourseCreatorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCreatorPayload>
          }
          deleteMany: {
            args: Prisma.CourseCreatorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseCreatorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseCreatorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCreatorPayload>
          }
          aggregate: {
            args: Prisma.CourseCreatorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseCreator>
          }
          groupBy: {
            args: Prisma.CourseCreatorGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseCreatorGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCreatorCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCreatorCountAggregateOutputType> | number
          }
        }
      }
      CourseLogging: {
        payload: Prisma.$CourseLoggingPayload<ExtArgs>
        fields: Prisma.CourseLoggingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseLoggingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLoggingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseLoggingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLoggingPayload>
          }
          findFirst: {
            args: Prisma.CourseLoggingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLoggingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseLoggingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLoggingPayload>
          }
          findMany: {
            args: Prisma.CourseLoggingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLoggingPayload>[]
          }
          create: {
            args: Prisma.CourseLoggingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLoggingPayload>
          }
          createMany: {
            args: Prisma.CourseLoggingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CourseLoggingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLoggingPayload>
          }
          update: {
            args: Prisma.CourseLoggingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLoggingPayload>
          }
          deleteMany: {
            args: Prisma.CourseLoggingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseLoggingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseLoggingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLoggingPayload>
          }
          aggregate: {
            args: Prisma.CourseLoggingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseLogging>
          }
          groupBy: {
            args: Prisma.CourseLoggingGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseLoggingGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseLoggingCountArgs<ExtArgs>
            result: $Utils.Optional<CourseLoggingCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      SubCategory: {
        payload: Prisma.$SubCategoryPayload<ExtArgs>
        fields: Prisma.SubCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload>
          }
          findFirst: {
            args: Prisma.SubCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload>
          }
          findMany: {
            args: Prisma.SubCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload>[]
          }
          create: {
            args: Prisma.SubCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload>
          }
          createMany: {
            args: Prisma.SubCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SubCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload>
          }
          update: {
            args: Prisma.SubCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload>
          }
          deleteMany: {
            args: Prisma.SubCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload>
          }
          aggregate: {
            args: Prisma.SubCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubCategory>
          }
          groupBy: {
            args: Prisma.SubCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<SubCategoryCountAggregateOutputType> | number
          }
        }
      }
      Topic: {
        payload: Prisma.$TopicPayload<ExtArgs>
        fields: Prisma.TopicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TopicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TopicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          findFirst: {
            args: Prisma.TopicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TopicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          findMany: {
            args: Prisma.TopicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>[]
          }
          create: {
            args: Prisma.TopicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          createMany: {
            args: Prisma.TopicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TopicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          update: {
            args: Prisma.TopicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          deleteMany: {
            args: Prisma.TopicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TopicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TopicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          aggregate: {
            args: Prisma.TopicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTopic>
          }
          groupBy: {
            args: Prisma.TopicGroupByArgs<ExtArgs>
            result: $Utils.Optional<TopicGroupByOutputType>[]
          }
          count: {
            args: Prisma.TopicCountArgs<ExtArgs>
            result: $Utils.Optional<TopicCountAggregateOutputType> | number
          }
        }
      }
      CourseTopic: {
        payload: Prisma.$CourseTopicPayload<ExtArgs>
        fields: Prisma.CourseTopicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseTopicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTopicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseTopicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTopicPayload>
          }
          findFirst: {
            args: Prisma.CourseTopicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTopicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseTopicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTopicPayload>
          }
          findMany: {
            args: Prisma.CourseTopicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTopicPayload>[]
          }
          create: {
            args: Prisma.CourseTopicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTopicPayload>
          }
          createMany: {
            args: Prisma.CourseTopicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CourseTopicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTopicPayload>
          }
          update: {
            args: Prisma.CourseTopicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTopicPayload>
          }
          deleteMany: {
            args: Prisma.CourseTopicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseTopicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseTopicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTopicPayload>
          }
          aggregate: {
            args: Prisma.CourseTopicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseTopic>
          }
          groupBy: {
            args: Prisma.CourseTopicGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseTopicGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseTopicCountArgs<ExtArgs>
            result: $Utils.Optional<CourseTopicCountAggregateOutputType> | number
          }
        }
      }
      Syllabus: {
        payload: Prisma.$SyllabusPayload<ExtArgs>
        fields: Prisma.SyllabusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SyllabusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SyllabusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusPayload>
          }
          findFirst: {
            args: Prisma.SyllabusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SyllabusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusPayload>
          }
          findMany: {
            args: Prisma.SyllabusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusPayload>[]
          }
          create: {
            args: Prisma.SyllabusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusPayload>
          }
          createMany: {
            args: Prisma.SyllabusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SyllabusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusPayload>
          }
          update: {
            args: Prisma.SyllabusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusPayload>
          }
          deleteMany: {
            args: Prisma.SyllabusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SyllabusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SyllabusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusPayload>
          }
          aggregate: {
            args: Prisma.SyllabusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSyllabus>
          }
          groupBy: {
            args: Prisma.SyllabusGroupByArgs<ExtArgs>
            result: $Utils.Optional<SyllabusGroupByOutputType>[]
          }
          count: {
            args: Prisma.SyllabusCountArgs<ExtArgs>
            result: $Utils.Optional<SyllabusCountAggregateOutputType> | number
          }
        }
      }
      SyllabusContent: {
        payload: Prisma.$SyllabusContentPayload<ExtArgs>
        fields: Prisma.SyllabusContentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SyllabusContentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusContentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SyllabusContentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusContentPayload>
          }
          findFirst: {
            args: Prisma.SyllabusContentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusContentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SyllabusContentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusContentPayload>
          }
          findMany: {
            args: Prisma.SyllabusContentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusContentPayload>[]
          }
          create: {
            args: Prisma.SyllabusContentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusContentPayload>
          }
          createMany: {
            args: Prisma.SyllabusContentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SyllabusContentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusContentPayload>
          }
          update: {
            args: Prisma.SyllabusContentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusContentPayload>
          }
          deleteMany: {
            args: Prisma.SyllabusContentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SyllabusContentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SyllabusContentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusContentPayload>
          }
          aggregate: {
            args: Prisma.SyllabusContentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSyllabusContent>
          }
          groupBy: {
            args: Prisma.SyllabusContentGroupByArgs<ExtArgs>
            result: $Utils.Optional<SyllabusContentGroupByOutputType>[]
          }
          count: {
            args: Prisma.SyllabusContentCountArgs<ExtArgs>
            result: $Utils.Optional<SyllabusContentCountAggregateOutputType> | number
          }
        }
      }
      Exam: {
        payload: Prisma.$ExamPayload<ExtArgs>
        fields: Prisma.ExamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          findFirst: {
            args: Prisma.ExamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          findMany: {
            args: Prisma.ExamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>[]
          }
          create: {
            args: Prisma.ExamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          createMany: {
            args: Prisma.ExamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ExamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          update: {
            args: Prisma.ExamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          deleteMany: {
            args: Prisma.ExamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          aggregate: {
            args: Prisma.ExamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExam>
          }
          groupBy: {
            args: Prisma.ExamGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamCountArgs<ExtArgs>
            result: $Utils.Optional<ExamCountAggregateOutputType> | number
          }
        }
      }
      ExamQuestion: {
        payload: Prisma.$ExamQuestionPayload<ExtArgs>
        fields: Prisma.ExamQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamQuestionPayload>
          }
          findFirst: {
            args: Prisma.ExamQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamQuestionPayload>
          }
          findMany: {
            args: Prisma.ExamQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamQuestionPayload>[]
          }
          create: {
            args: Prisma.ExamQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamQuestionPayload>
          }
          createMany: {
            args: Prisma.ExamQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ExamQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamQuestionPayload>
          }
          update: {
            args: Prisma.ExamQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamQuestionPayload>
          }
          deleteMany: {
            args: Prisma.ExamQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExamQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamQuestionPayload>
          }
          aggregate: {
            args: Prisma.ExamQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExamQuestion>
          }
          groupBy: {
            args: Prisma.ExamQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<ExamQuestionCountAggregateOutputType> | number
          }
        }
      }
      ExamOptionQuestion: {
        payload: Prisma.$ExamOptionQuestionPayload<ExtArgs>
        fields: Prisma.ExamOptionQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamOptionQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamOptionQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamOptionQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamOptionQuestionPayload>
          }
          findFirst: {
            args: Prisma.ExamOptionQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamOptionQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamOptionQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamOptionQuestionPayload>
          }
          findMany: {
            args: Prisma.ExamOptionQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamOptionQuestionPayload>[]
          }
          create: {
            args: Prisma.ExamOptionQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamOptionQuestionPayload>
          }
          createMany: {
            args: Prisma.ExamOptionQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ExamOptionQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamOptionQuestionPayload>
          }
          update: {
            args: Prisma.ExamOptionQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamOptionQuestionPayload>
          }
          deleteMany: {
            args: Prisma.ExamOptionQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamOptionQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExamOptionQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamOptionQuestionPayload>
          }
          aggregate: {
            args: Prisma.ExamOptionQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExamOptionQuestion>
          }
          groupBy: {
            args: Prisma.ExamOptionQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamOptionQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamOptionQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<ExamOptionQuestionCountAggregateOutputType> | number
          }
        }
      }
      MaterialContentType: {
        payload: Prisma.$MaterialContentTypePayload<ExtArgs>
        fields: Prisma.MaterialContentTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterialContentTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterialContentTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentTypePayload>
          }
          findFirst: {
            args: Prisma.MaterialContentTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterialContentTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentTypePayload>
          }
          findMany: {
            args: Prisma.MaterialContentTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentTypePayload>[]
          }
          create: {
            args: Prisma.MaterialContentTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentTypePayload>
          }
          createMany: {
            args: Prisma.MaterialContentTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MaterialContentTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentTypePayload>
          }
          update: {
            args: Prisma.MaterialContentTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentTypePayload>
          }
          deleteMany: {
            args: Prisma.MaterialContentTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaterialContentTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MaterialContentTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentTypePayload>
          }
          aggregate: {
            args: Prisma.MaterialContentTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaterialContentType>
          }
          groupBy: {
            args: Prisma.MaterialContentTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterialContentTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterialContentTypeCountArgs<ExtArgs>
            result: $Utils.Optional<MaterialContentTypeCountAggregateOutputType> | number
          }
        }
      }
      MaterialContent: {
        payload: Prisma.$MaterialContentPayload<ExtArgs>
        fields: Prisma.MaterialContentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterialContentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterialContentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentPayload>
          }
          findFirst: {
            args: Prisma.MaterialContentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterialContentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentPayload>
          }
          findMany: {
            args: Prisma.MaterialContentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentPayload>[]
          }
          create: {
            args: Prisma.MaterialContentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentPayload>
          }
          createMany: {
            args: Prisma.MaterialContentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MaterialContentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentPayload>
          }
          update: {
            args: Prisma.MaterialContentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentPayload>
          }
          deleteMany: {
            args: Prisma.MaterialContentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaterialContentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MaterialContentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentPayload>
          }
          aggregate: {
            args: Prisma.MaterialContentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaterialContent>
          }
          groupBy: {
            args: Prisma.MaterialContentGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterialContentGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterialContentCountArgs<ExtArgs>
            result: $Utils.Optional<MaterialContentCountAggregateOutputType> | number
          }
        }
      }
      MaterialContentLearning: {
        payload: Prisma.$MaterialContentLearningPayload<ExtArgs>
        fields: Prisma.MaterialContentLearningFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterialContentLearningFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentLearningPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterialContentLearningFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentLearningPayload>
          }
          findFirst: {
            args: Prisma.MaterialContentLearningFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentLearningPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterialContentLearningFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentLearningPayload>
          }
          findMany: {
            args: Prisma.MaterialContentLearningFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentLearningPayload>[]
          }
          create: {
            args: Prisma.MaterialContentLearningCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentLearningPayload>
          }
          createMany: {
            args: Prisma.MaterialContentLearningCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MaterialContentLearningDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentLearningPayload>
          }
          update: {
            args: Prisma.MaterialContentLearningUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentLearningPayload>
          }
          deleteMany: {
            args: Prisma.MaterialContentLearningDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaterialContentLearningUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MaterialContentLearningUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentLearningPayload>
          }
          aggregate: {
            args: Prisma.MaterialContentLearningAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaterialContentLearning>
          }
          groupBy: {
            args: Prisma.MaterialContentLearningGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterialContentLearningGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterialContentLearningCountArgs<ExtArgs>
            result: $Utils.Optional<MaterialContentLearningCountAggregateOutputType> | number
          }
        }
      }
      MaterialContentTest: {
        payload: Prisma.$MaterialContentTestPayload<ExtArgs>
        fields: Prisma.MaterialContentTestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterialContentTestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentTestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterialContentTestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentTestPayload>
          }
          findFirst: {
            args: Prisma.MaterialContentTestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentTestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterialContentTestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentTestPayload>
          }
          findMany: {
            args: Prisma.MaterialContentTestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentTestPayload>[]
          }
          create: {
            args: Prisma.MaterialContentTestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentTestPayload>
          }
          createMany: {
            args: Prisma.MaterialContentTestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MaterialContentTestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentTestPayload>
          }
          update: {
            args: Prisma.MaterialContentTestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentTestPayload>
          }
          deleteMany: {
            args: Prisma.MaterialContentTestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaterialContentTestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MaterialContentTestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentTestPayload>
          }
          aggregate: {
            args: Prisma.MaterialContentTestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaterialContentTest>
          }
          groupBy: {
            args: Prisma.MaterialContentTestGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterialContentTestGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterialContentTestCountArgs<ExtArgs>
            result: $Utils.Optional<MaterialContentTestCountAggregateOutputType> | number
          }
        }
      }
      MaterialContentFile: {
        payload: Prisma.$MaterialContentFilePayload<ExtArgs>
        fields: Prisma.MaterialContentFileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterialContentFileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentFilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterialContentFileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentFilePayload>
          }
          findFirst: {
            args: Prisma.MaterialContentFileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentFilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterialContentFileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentFilePayload>
          }
          findMany: {
            args: Prisma.MaterialContentFileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentFilePayload>[]
          }
          create: {
            args: Prisma.MaterialContentFileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentFilePayload>
          }
          createMany: {
            args: Prisma.MaterialContentFileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MaterialContentFileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentFilePayload>
          }
          update: {
            args: Prisma.MaterialContentFileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentFilePayload>
          }
          deleteMany: {
            args: Prisma.MaterialContentFileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaterialContentFileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MaterialContentFileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentFilePayload>
          }
          aggregate: {
            args: Prisma.MaterialContentFileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaterialContentFile>
          }
          groupBy: {
            args: Prisma.MaterialContentFileGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterialContentFileGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterialContentFileCountArgs<ExtArgs>
            result: $Utils.Optional<MaterialContentFileCountAggregateOutputType> | number
          }
        }
      }
      MaterialContentAttachment: {
        payload: Prisma.$MaterialContentAttachmentPayload<ExtArgs>
        fields: Prisma.MaterialContentAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterialContentAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterialContentAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentAttachmentPayload>
          }
          findFirst: {
            args: Prisma.MaterialContentAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterialContentAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentAttachmentPayload>
          }
          findMany: {
            args: Prisma.MaterialContentAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentAttachmentPayload>[]
          }
          create: {
            args: Prisma.MaterialContentAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentAttachmentPayload>
          }
          createMany: {
            args: Prisma.MaterialContentAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MaterialContentAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentAttachmentPayload>
          }
          update: {
            args: Prisma.MaterialContentAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.MaterialContentAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaterialContentAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MaterialContentAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialContentAttachmentPayload>
          }
          aggregate: {
            args: Prisma.MaterialContentAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaterialContentAttachment>
          }
          groupBy: {
            args: Prisma.MaterialContentAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterialContentAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterialContentAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<MaterialContentAttachmentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    CourseCreator: number
    CourseLogging: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CourseCreator?: boolean | UsersCountOutputTypeCountCourseCreatorArgs
    CourseLogging?: boolean | UsersCountOutputTypeCountCourseLoggingArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountCourseCreatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseCreatorWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountCourseLoggingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseLoggingWhereInput
  }


  /**
   * Count Type CourseCountOutputType
   */

  export type CourseCountOutputType = {
    CourseLoggings: number
    CourseTopics: number
    Syllabus: number
    CourseCreator: number
  }

  export type CourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CourseLoggings?: boolean | CourseCountOutputTypeCountCourseLoggingsArgs
    CourseTopics?: boolean | CourseCountOutputTypeCountCourseTopicsArgs
    Syllabus?: boolean | CourseCountOutputTypeCountSyllabusArgs
    CourseCreator?: boolean | CourseCountOutputTypeCountCourseCreatorArgs
  }

  // Custom InputTypes
  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCountOutputType
     */
    select?: CourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountCourseLoggingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseLoggingWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountCourseTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseTopicWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountSyllabusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyllabusWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountCourseCreatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseCreatorWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    SubCategories: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SubCategories?: boolean | CategoryCountOutputTypeCountSubCategoriesArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountSubCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubCategoryWhereInput
  }


  /**
   * Count Type SubCategoryCountOutputType
   */

  export type SubCategoryCountOutputType = {
    Topics: number
  }

  export type SubCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Topics?: boolean | SubCategoryCountOutputTypeCountTopicsArgs
  }

  // Custom InputTypes
  /**
   * SubCategoryCountOutputType without action
   */
  export type SubCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoryCountOutputType
     */
    select?: SubCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubCategoryCountOutputType without action
   */
  export type SubCategoryCountOutputTypeCountTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicWhereInput
  }


  /**
   * Count Type TopicCountOutputType
   */

  export type TopicCountOutputType = {
    CourseTopics: number
  }

  export type TopicCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CourseTopics?: boolean | TopicCountOutputTypeCountCourseTopicsArgs
  }

  // Custom InputTypes
  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicCountOutputType
     */
    select?: TopicCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountCourseTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseTopicWhereInput
  }


  /**
   * Count Type SyllabusCountOutputType
   */

  export type SyllabusCountOutputType = {
    SyllabusContent: number
  }

  export type SyllabusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SyllabusContent?: boolean | SyllabusCountOutputTypeCountSyllabusContentArgs
  }

  // Custom InputTypes
  /**
   * SyllabusCountOutputType without action
   */
  export type SyllabusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusCountOutputType
     */
    select?: SyllabusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SyllabusCountOutputType without action
   */
  export type SyllabusCountOutputTypeCountSyllabusContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyllabusContentWhereInput
  }


  /**
   * Count Type SyllabusContentCountOutputType
   */

  export type SyllabusContentCountOutputType = {
    Exams: number
    MaterialContents: number
    CourseLogging: number
  }

  export type SyllabusContentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Exams?: boolean | SyllabusContentCountOutputTypeCountExamsArgs
    MaterialContents?: boolean | SyllabusContentCountOutputTypeCountMaterialContentsArgs
    CourseLogging?: boolean | SyllabusContentCountOutputTypeCountCourseLoggingArgs
  }

  // Custom InputTypes
  /**
   * SyllabusContentCountOutputType without action
   */
  export type SyllabusContentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusContentCountOutputType
     */
    select?: SyllabusContentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SyllabusContentCountOutputType without action
   */
  export type SyllabusContentCountOutputTypeCountExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
  }

  /**
   * SyllabusContentCountOutputType without action
   */
  export type SyllabusContentCountOutputTypeCountMaterialContentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialContentWhereInput
  }

  /**
   * SyllabusContentCountOutputType without action
   */
  export type SyllabusContentCountOutputTypeCountCourseLoggingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseLoggingWhereInput
  }


  /**
   * Count Type ExamCountOutputType
   */

  export type ExamCountOutputType = {
    ExamQuestions: number
    CourseLogging: number
  }

  export type ExamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ExamQuestions?: boolean | ExamCountOutputTypeCountExamQuestionsArgs
    CourseLogging?: boolean | ExamCountOutputTypeCountCourseLoggingArgs
  }

  // Custom InputTypes
  /**
   * ExamCountOutputType without action
   */
  export type ExamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamCountOutputType
     */
    select?: ExamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExamCountOutputType without action
   */
  export type ExamCountOutputTypeCountExamQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamQuestionWhereInput
  }

  /**
   * ExamCountOutputType without action
   */
  export type ExamCountOutputTypeCountCourseLoggingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseLoggingWhereInput
  }


  /**
   * Count Type ExamQuestionCountOutputType
   */

  export type ExamQuestionCountOutputType = {
    ExamOptions: number
  }

  export type ExamQuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ExamOptions?: boolean | ExamQuestionCountOutputTypeCountExamOptionsArgs
  }

  // Custom InputTypes
  /**
   * ExamQuestionCountOutputType without action
   */
  export type ExamQuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestionCountOutputType
     */
    select?: ExamQuestionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExamQuestionCountOutputType without action
   */
  export type ExamQuestionCountOutputTypeCountExamOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamOptionQuestionWhereInput
  }


  /**
   * Count Type MaterialContentTypeCountOutputType
   */

  export type MaterialContentTypeCountOutputType = {
    MaterialContents: number
  }

  export type MaterialContentTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MaterialContents?: boolean | MaterialContentTypeCountOutputTypeCountMaterialContentsArgs
  }

  // Custom InputTypes
  /**
   * MaterialContentTypeCountOutputType without action
   */
  export type MaterialContentTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentTypeCountOutputType
     */
    select?: MaterialContentTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaterialContentTypeCountOutputType without action
   */
  export type MaterialContentTypeCountOutputTypeCountMaterialContentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialContentWhereInput
  }


  /**
   * Count Type MaterialContentCountOutputType
   */

  export type MaterialContentCountOutputType = {
    Attachments: number
    CourseLogging: number
  }

  export type MaterialContentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Attachments?: boolean | MaterialContentCountOutputTypeCountAttachmentsArgs
    CourseLogging?: boolean | MaterialContentCountOutputTypeCountCourseLoggingArgs
  }

  // Custom InputTypes
  /**
   * MaterialContentCountOutputType without action
   */
  export type MaterialContentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentCountOutputType
     */
    select?: MaterialContentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaterialContentCountOutputType without action
   */
  export type MaterialContentCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialContentAttachmentWhereInput
  }

  /**
   * MaterialContentCountOutputType without action
   */
  export type MaterialContentCountOutputTypeCountCourseLoggingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseLoggingWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    user_type: number | null
  }

  export type UsersSumAggregateOutputType = {
    user_type: number | null
  }

  export type UsersMinAggregateOutputType = {
    gid: string | null
    full_name: string | null
    email: string | null
    phone: string | null
    school: string | null
    user_type: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    gid: string | null
    full_name: string | null
    email: string | null
    phone: string | null
    school: string | null
    user_type: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersCountAggregateOutputType = {
    gid: number
    full_name: number
    email: number
    phone: number
    school: number
    user_type: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    user_type?: true
  }

  export type UsersSumAggregateInputType = {
    user_type?: true
  }

  export type UsersMinAggregateInputType = {
    gid?: true
    full_name?: true
    email?: true
    phone?: true
    school?: true
    user_type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersMaxAggregateInputType = {
    gid?: true
    full_name?: true
    email?: true
    phone?: true
    school?: true
    user_type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersCountAggregateInputType = {
    gid?: true
    full_name?: true
    email?: true
    phone?: true
    school?: true
    user_type?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to aggregate.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithAggregationInput | UsersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: UsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    gid: string
    full_name: string | null
    email: string | null
    phone: string | null
    school: string | null
    user_type: number | null
    createdAt: Date
    updatedAt: Date
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type UsersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    gid?: boolean
    full_name?: boolean
    email?: boolean
    phone?: boolean
    school?: boolean
    user_type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    CourseCreator?: boolean | Users$CourseCreatorArgs<ExtArgs>
    CourseLogging?: boolean | Users$CourseLoggingArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>


  export type UsersSelectScalar = {
    gid?: boolean
    full_name?: boolean
    email?: boolean
    phone?: boolean
    school?: boolean
    user_type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UsersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CourseCreator?: boolean | Users$CourseCreatorArgs<ExtArgs>
    CourseLogging?: boolean | Users$CourseLoggingArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UsersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Users"
    objects: {
      CourseCreator: Prisma.$CourseCreatorPayload<ExtArgs>[]
      CourseLogging: Prisma.$CourseLoggingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      gid: string
      full_name: string | null
      email: string | null
      phone: string | null
      school: string | null
      user_type: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type UsersGetPayload<S extends boolean | null | undefined | UsersDefaultArgs> = $Result.GetResult<Prisma.$UsersPayload, S>

  type UsersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface UsersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Users'], meta: { name: 'Users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {UsersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsersFindUniqueArgs>(args: SelectSubset<T, UsersFindUniqueArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsersFindUniqueOrThrowArgs>(args: SelectSubset<T, UsersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsersFindFirstArgs>(args?: SelectSubset<T, UsersFindFirstArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsersFindFirstOrThrowArgs>(args?: SelectSubset<T, UsersFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `gid`
     * const usersWithGidOnly = await prisma.users.findMany({ select: { gid: true } })
     * 
     */
    findMany<T extends UsersFindManyArgs>(args?: SelectSubset<T, UsersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Users.
     * @param {UsersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends UsersCreateArgs>(args: SelectSubset<T, UsersCreateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UsersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsersCreateManyArgs>(args?: SelectSubset<T, UsersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {UsersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends UsersDeleteArgs>(args: SelectSubset<T, UsersDeleteArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Users.
     * @param {UsersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsersUpdateArgs>(args: SelectSubset<T, UsersUpdateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UsersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsersDeleteManyArgs>(args?: SelectSubset<T, UsersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsersUpdateManyArgs>(args: SelectSubset<T, UsersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {UsersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends UsersUpsertArgs>(args: SelectSubset<T, UsersUpsertArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UsersCountArgs>(
      args?: Subset<T, UsersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Users model
   */
  readonly fields: UsersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CourseCreator<T extends Users$CourseCreatorArgs<ExtArgs> = {}>(args?: Subset<T, Users$CourseCreatorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseCreatorPayload<ExtArgs>, T, "findMany"> | Null>
    CourseLogging<T extends Users$CourseLoggingArgs<ExtArgs> = {}>(args?: Subset<T, Users$CourseLoggingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseLoggingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Users model
   */ 
  interface UsersFieldRefs {
    readonly gid: FieldRef<"Users", 'String'>
    readonly full_name: FieldRef<"Users", 'String'>
    readonly email: FieldRef<"Users", 'String'>
    readonly phone: FieldRef<"Users", 'String'>
    readonly school: FieldRef<"Users", 'String'>
    readonly user_type: FieldRef<"Users", 'Int'>
    readonly createdAt: FieldRef<"Users", 'DateTime'>
    readonly updatedAt: FieldRef<"Users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Users findUnique
   */
  export type UsersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findUniqueOrThrow
   */
  export type UsersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findFirst
   */
  export type UsersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findFirstOrThrow
   */
  export type UsersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findMany
   */
  export type UsersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users create
   */
  export type UsersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to create a Users.
     */
    data: XOR<UsersCreateInput, UsersUncheckedCreateInput>
  }

  /**
   * Users createMany
   */
  export type UsersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Users update
   */
  export type UsersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to update a Users.
     */
    data: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
    /**
     * Choose, which Users to update.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users updateMany
   */
  export type UsersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
  }

  /**
   * Users upsert
   */
  export type UsersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The filter to search for the Users to update in case it exists.
     */
    where: UsersWhereUniqueInput
    /**
     * In case the Users found by the `where` argument doesn't exist, create a new Users with this data.
     */
    create: XOR<UsersCreateInput, UsersUncheckedCreateInput>
    /**
     * In case the Users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
  }

  /**
   * Users delete
   */
  export type UsersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter which Users to delete.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users deleteMany
   */
  export type UsersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UsersWhereInput
  }

  /**
   * Users.CourseCreator
   */
  export type Users$CourseCreatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCreator
     */
    select?: CourseCreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCreatorInclude<ExtArgs> | null
    where?: CourseCreatorWhereInput
    orderBy?: CourseCreatorOrderByWithRelationInput | CourseCreatorOrderByWithRelationInput[]
    cursor?: CourseCreatorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseCreatorScalarFieldEnum | CourseCreatorScalarFieldEnum[]
  }

  /**
   * Users.CourseLogging
   */
  export type Users$CourseLoggingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLogging
     */
    select?: CourseLoggingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLoggingInclude<ExtArgs> | null
    where?: CourseLoggingWhereInput
    orderBy?: CourseLoggingOrderByWithRelationInput | CourseLoggingOrderByWithRelationInput[]
    cursor?: CourseLoggingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseLoggingScalarFieldEnum | CourseLoggingScalarFieldEnum[]
  }

  /**
   * Users without action
   */
  export type UsersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
  }


  /**
   * Model Course
   */

  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseAvgAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type CourseSumAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type CourseMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    cover: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    price: number | null
    slug: string | null
  }

  export type CourseMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    cover: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    price: number | null
    slug: string | null
  }

  export type CourseCountAggregateOutputType = {
    id: number
    title: number
    description: number
    cover: number
    isActive: number
    createdAt: number
    updatedAt: number
    price: number
    slug: number
    _all: number
  }


  export type CourseAvgAggregateInputType = {
    id?: true
    price?: true
  }

  export type CourseSumAggregateInputType = {
    id?: true
    price?: true
  }

  export type CourseMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    cover?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    price?: true
    slug?: true
  }

  export type CourseMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    cover?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    price?: true
    slug?: true
  }

  export type CourseCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    cover?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    price?: true
    slug?: true
    _all?: true
  }

  export type CourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Course to aggregate.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type CourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithAggregationInput | CourseOrderByWithAggregationInput[]
    by: CourseScalarFieldEnum[] | CourseScalarFieldEnum
    having?: CourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _avg?: CourseAvgAggregateInputType
    _sum?: CourseSumAggregateInputType
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }

  export type CourseGroupByOutputType = {
    id: number
    title: string
    description: string
    cover: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    price: number
    slug: string
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type CourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    cover?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    price?: boolean
    slug?: boolean
    CourseLoggings?: boolean | Course$CourseLoggingsArgs<ExtArgs>
    CourseTopics?: boolean | Course$CourseTopicsArgs<ExtArgs>
    Syllabus?: boolean | Course$SyllabusArgs<ExtArgs>
    CourseCreator?: boolean | Course$CourseCreatorArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>


  export type CourseSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    cover?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    price?: boolean
    slug?: boolean
  }

  export type CourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CourseLoggings?: boolean | Course$CourseLoggingsArgs<ExtArgs>
    CourseTopics?: boolean | Course$CourseTopicsArgs<ExtArgs>
    Syllabus?: boolean | Course$SyllabusArgs<ExtArgs>
    CourseCreator?: boolean | Course$CourseCreatorArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Course"
    objects: {
      CourseLoggings: Prisma.$CourseLoggingPayload<ExtArgs>[]
      CourseTopics: Prisma.$CourseTopicPayload<ExtArgs>[]
      Syllabus: Prisma.$SyllabusPayload<ExtArgs>[]
      CourseCreator: Prisma.$CourseCreatorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string
      cover: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      price: number
      slug: string
    }, ExtArgs["result"]["course"]>
    composites: {}
  }

  type CourseGetPayload<S extends boolean | null | undefined | CourseDefaultArgs> = $Result.GetResult<Prisma.$CoursePayload, S>

  type CourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CourseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourseCountAggregateInputType | true
    }

  export interface CourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Course'], meta: { name: 'Course' } }
    /**
     * Find zero or one Course that matches the filter.
     * @param {CourseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseFindUniqueArgs>(args: SelectSubset<T, CourseFindUniqueArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Course that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CourseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseFindFirstArgs>(args?: SelectSubset<T, CourseFindFirstArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Course that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseWithIdOnly = await prisma.course.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseFindManyArgs>(args?: SelectSubset<T, CourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Course.
     * @param {CourseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
     */
    create<T extends CourseCreateArgs>(args: SelectSubset<T, CourseCreateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Courses.
     * @param {CourseCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseCreateManyArgs>(args?: SelectSubset<T, CourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Course.
     * @param {CourseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
     */
    delete<T extends CourseDeleteArgs>(args: SelectSubset<T, CourseDeleteArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Course.
     * @param {CourseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseUpdateArgs>(args: SelectSubset<T, CourseUpdateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Courses.
     * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseDeleteManyArgs>(args?: SelectSubset<T, CourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseUpdateManyArgs>(args: SelectSubset<T, CourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Course.
     * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
     */
    upsert<T extends CourseUpsertArgs>(args: SelectSubset<T, CourseUpsertArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CourseCountArgs>(
      args?: Subset<T, CourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): Prisma.PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Course model
   */
  readonly fields: CourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CourseLoggings<T extends Course$CourseLoggingsArgs<ExtArgs> = {}>(args?: Subset<T, Course$CourseLoggingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseLoggingPayload<ExtArgs>, T, "findMany"> | Null>
    CourseTopics<T extends Course$CourseTopicsArgs<ExtArgs> = {}>(args?: Subset<T, Course$CourseTopicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseTopicPayload<ExtArgs>, T, "findMany"> | Null>
    Syllabus<T extends Course$SyllabusArgs<ExtArgs> = {}>(args?: Subset<T, Course$SyllabusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyllabusPayload<ExtArgs>, T, "findMany"> | Null>
    CourseCreator<T extends Course$CourseCreatorArgs<ExtArgs> = {}>(args?: Subset<T, Course$CourseCreatorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseCreatorPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Course model
   */ 
  interface CourseFieldRefs {
    readonly id: FieldRef<"Course", 'Int'>
    readonly title: FieldRef<"Course", 'String'>
    readonly description: FieldRef<"Course", 'String'>
    readonly cover: FieldRef<"Course", 'String'>
    readonly isActive: FieldRef<"Course", 'Boolean'>
    readonly createdAt: FieldRef<"Course", 'DateTime'>
    readonly updatedAt: FieldRef<"Course", 'DateTime'>
    readonly price: FieldRef<"Course", 'Int'>
    readonly slug: FieldRef<"Course", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Course findUnique
   */
  export type CourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findUniqueOrThrow
   */
  export type CourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findFirst
   */
  export type CourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findFirstOrThrow
   */
  export type CourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findMany
   */
  export type CourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course create
   */
  export type CourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to create a Course.
     */
    data: XOR<CourseCreateInput, CourseUncheckedCreateInput>
  }

  /**
   * Course createMany
   */
  export type CourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Course update
   */
  export type CourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to update a Course.
     */
    data: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
    /**
     * Choose, which Course to update.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course updateMany
   */
  export type CourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
  }

  /**
   * Course upsert
   */
  export type CourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The filter to search for the Course to update in case it exists.
     */
    where: CourseWhereUniqueInput
    /**
     * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
     */
    create: XOR<CourseCreateInput, CourseUncheckedCreateInput>
    /**
     * In case the Course was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
  }

  /**
   * Course delete
   */
  export type CourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter which Course to delete.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course deleteMany
   */
  export type CourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CourseWhereInput
  }

  /**
   * Course.CourseLoggings
   */
  export type Course$CourseLoggingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLogging
     */
    select?: CourseLoggingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLoggingInclude<ExtArgs> | null
    where?: CourseLoggingWhereInput
    orderBy?: CourseLoggingOrderByWithRelationInput | CourseLoggingOrderByWithRelationInput[]
    cursor?: CourseLoggingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseLoggingScalarFieldEnum | CourseLoggingScalarFieldEnum[]
  }

  /**
   * Course.CourseTopics
   */
  export type Course$CourseTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTopic
     */
    select?: CourseTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTopicInclude<ExtArgs> | null
    where?: CourseTopicWhereInput
    orderBy?: CourseTopicOrderByWithRelationInput | CourseTopicOrderByWithRelationInput[]
    cursor?: CourseTopicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseTopicScalarFieldEnum | CourseTopicScalarFieldEnum[]
  }

  /**
   * Course.Syllabus
   */
  export type Course$SyllabusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syllabus
     */
    select?: SyllabusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusInclude<ExtArgs> | null
    where?: SyllabusWhereInput
    orderBy?: SyllabusOrderByWithRelationInput | SyllabusOrderByWithRelationInput[]
    cursor?: SyllabusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SyllabusScalarFieldEnum | SyllabusScalarFieldEnum[]
  }

  /**
   * Course.CourseCreator
   */
  export type Course$CourseCreatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCreator
     */
    select?: CourseCreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCreatorInclude<ExtArgs> | null
    where?: CourseCreatorWhereInput
    orderBy?: CourseCreatorOrderByWithRelationInput | CourseCreatorOrderByWithRelationInput[]
    cursor?: CourseCreatorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseCreatorScalarFieldEnum | CourseCreatorScalarFieldEnum[]
  }

  /**
   * Course without action
   */
  export type CourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
  }


  /**
   * Model CourseCreator
   */

  export type AggregateCourseCreator = {
    _count: CourseCreatorCountAggregateOutputType | null
    _avg: CourseCreatorAvgAggregateOutputType | null
    _sum: CourseCreatorSumAggregateOutputType | null
    _min: CourseCreatorMinAggregateOutputType | null
    _max: CourseCreatorMaxAggregateOutputType | null
  }

  export type CourseCreatorAvgAggregateOutputType = {
    id: number | null
    courseId: number | null
  }

  export type CourseCreatorSumAggregateOutputType = {
    id: number | null
    courseId: number | null
  }

  export type CourseCreatorMinAggregateOutputType = {
    id: number | null
    courseId: number | null
    userId: string | null
    as: $Enums.CourseAs | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseCreatorMaxAggregateOutputType = {
    id: number | null
    courseId: number | null
    userId: string | null
    as: $Enums.CourseAs | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseCreatorCountAggregateOutputType = {
    id: number
    courseId: number
    userId: number
    as: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CourseCreatorAvgAggregateInputType = {
    id?: true
    courseId?: true
  }

  export type CourseCreatorSumAggregateInputType = {
    id?: true
    courseId?: true
  }

  export type CourseCreatorMinAggregateInputType = {
    id?: true
    courseId?: true
    userId?: true
    as?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseCreatorMaxAggregateInputType = {
    id?: true
    courseId?: true
    userId?: true
    as?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseCreatorCountAggregateInputType = {
    id?: true
    courseId?: true
    userId?: true
    as?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CourseCreatorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseCreator to aggregate.
     */
    where?: CourseCreatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseCreators to fetch.
     */
    orderBy?: CourseCreatorOrderByWithRelationInput | CourseCreatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseCreatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseCreators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseCreators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseCreators
    **/
    _count?: true | CourseCreatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseCreatorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseCreatorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseCreatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseCreatorMaxAggregateInputType
  }

  export type GetCourseCreatorAggregateType<T extends CourseCreatorAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseCreator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseCreator[P]>
      : GetScalarType<T[P], AggregateCourseCreator[P]>
  }




  export type CourseCreatorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseCreatorWhereInput
    orderBy?: CourseCreatorOrderByWithAggregationInput | CourseCreatorOrderByWithAggregationInput[]
    by: CourseCreatorScalarFieldEnum[] | CourseCreatorScalarFieldEnum
    having?: CourseCreatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCreatorCountAggregateInputType | true
    _avg?: CourseCreatorAvgAggregateInputType
    _sum?: CourseCreatorSumAggregateInputType
    _min?: CourseCreatorMinAggregateInputType
    _max?: CourseCreatorMaxAggregateInputType
  }

  export type CourseCreatorGroupByOutputType = {
    id: number
    courseId: number
    userId: string
    as: $Enums.CourseAs
    createdAt: Date
    updatedAt: Date
    _count: CourseCreatorCountAggregateOutputType | null
    _avg: CourseCreatorAvgAggregateOutputType | null
    _sum: CourseCreatorSumAggregateOutputType | null
    _min: CourseCreatorMinAggregateOutputType | null
    _max: CourseCreatorMaxAggregateOutputType | null
  }

  type GetCourseCreatorGroupByPayload<T extends CourseCreatorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseCreatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseCreatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseCreatorGroupByOutputType[P]>
            : GetScalarType<T[P], CourseCreatorGroupByOutputType[P]>
        }
      >
    >


  export type CourseCreatorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    userId?: boolean
    as?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Course?: boolean | CourseDefaultArgs<ExtArgs>
    User?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseCreator"]>


  export type CourseCreatorSelectScalar = {
    id?: boolean
    courseId?: boolean
    userId?: boolean
    as?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CourseCreatorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Course?: boolean | CourseDefaultArgs<ExtArgs>
    User?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $CourseCreatorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseCreator"
    objects: {
      Course: Prisma.$CoursePayload<ExtArgs>
      User: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      courseId: number
      userId: string
      as: $Enums.CourseAs
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["courseCreator"]>
    composites: {}
  }

  type CourseCreatorGetPayload<S extends boolean | null | undefined | CourseCreatorDefaultArgs> = $Result.GetResult<Prisma.$CourseCreatorPayload, S>

  type CourseCreatorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CourseCreatorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourseCreatorCountAggregateInputType | true
    }

  export interface CourseCreatorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseCreator'], meta: { name: 'CourseCreator' } }
    /**
     * Find zero or one CourseCreator that matches the filter.
     * @param {CourseCreatorFindUniqueArgs} args - Arguments to find a CourseCreator
     * @example
     * // Get one CourseCreator
     * const courseCreator = await prisma.courseCreator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseCreatorFindUniqueArgs>(args: SelectSubset<T, CourseCreatorFindUniqueArgs<ExtArgs>>): Prisma__CourseCreatorClient<$Result.GetResult<Prisma.$CourseCreatorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CourseCreator that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CourseCreatorFindUniqueOrThrowArgs} args - Arguments to find a CourseCreator
     * @example
     * // Get one CourseCreator
     * const courseCreator = await prisma.courseCreator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseCreatorFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseCreatorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseCreatorClient<$Result.GetResult<Prisma.$CourseCreatorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CourseCreator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCreatorFindFirstArgs} args - Arguments to find a CourseCreator
     * @example
     * // Get one CourseCreator
     * const courseCreator = await prisma.courseCreator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseCreatorFindFirstArgs>(args?: SelectSubset<T, CourseCreatorFindFirstArgs<ExtArgs>>): Prisma__CourseCreatorClient<$Result.GetResult<Prisma.$CourseCreatorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CourseCreator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCreatorFindFirstOrThrowArgs} args - Arguments to find a CourseCreator
     * @example
     * // Get one CourseCreator
     * const courseCreator = await prisma.courseCreator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseCreatorFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseCreatorFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseCreatorClient<$Result.GetResult<Prisma.$CourseCreatorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CourseCreators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCreatorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseCreators
     * const courseCreators = await prisma.courseCreator.findMany()
     * 
     * // Get first 10 CourseCreators
     * const courseCreators = await prisma.courseCreator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseCreatorWithIdOnly = await prisma.courseCreator.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseCreatorFindManyArgs>(args?: SelectSubset<T, CourseCreatorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseCreatorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CourseCreator.
     * @param {CourseCreatorCreateArgs} args - Arguments to create a CourseCreator.
     * @example
     * // Create one CourseCreator
     * const CourseCreator = await prisma.courseCreator.create({
     *   data: {
     *     // ... data to create a CourseCreator
     *   }
     * })
     * 
     */
    create<T extends CourseCreatorCreateArgs>(args: SelectSubset<T, CourseCreatorCreateArgs<ExtArgs>>): Prisma__CourseCreatorClient<$Result.GetResult<Prisma.$CourseCreatorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CourseCreators.
     * @param {CourseCreatorCreateManyArgs} args - Arguments to create many CourseCreators.
     * @example
     * // Create many CourseCreators
     * const courseCreator = await prisma.courseCreator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseCreatorCreateManyArgs>(args?: SelectSubset<T, CourseCreatorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CourseCreator.
     * @param {CourseCreatorDeleteArgs} args - Arguments to delete one CourseCreator.
     * @example
     * // Delete one CourseCreator
     * const CourseCreator = await prisma.courseCreator.delete({
     *   where: {
     *     // ... filter to delete one CourseCreator
     *   }
     * })
     * 
     */
    delete<T extends CourseCreatorDeleteArgs>(args: SelectSubset<T, CourseCreatorDeleteArgs<ExtArgs>>): Prisma__CourseCreatorClient<$Result.GetResult<Prisma.$CourseCreatorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CourseCreator.
     * @param {CourseCreatorUpdateArgs} args - Arguments to update one CourseCreator.
     * @example
     * // Update one CourseCreator
     * const courseCreator = await prisma.courseCreator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseCreatorUpdateArgs>(args: SelectSubset<T, CourseCreatorUpdateArgs<ExtArgs>>): Prisma__CourseCreatorClient<$Result.GetResult<Prisma.$CourseCreatorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CourseCreators.
     * @param {CourseCreatorDeleteManyArgs} args - Arguments to filter CourseCreators to delete.
     * @example
     * // Delete a few CourseCreators
     * const { count } = await prisma.courseCreator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseCreatorDeleteManyArgs>(args?: SelectSubset<T, CourseCreatorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseCreators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCreatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseCreators
     * const courseCreator = await prisma.courseCreator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseCreatorUpdateManyArgs>(args: SelectSubset<T, CourseCreatorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CourseCreator.
     * @param {CourseCreatorUpsertArgs} args - Arguments to update or create a CourseCreator.
     * @example
     * // Update or create a CourseCreator
     * const courseCreator = await prisma.courseCreator.upsert({
     *   create: {
     *     // ... data to create a CourseCreator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseCreator we want to update
     *   }
     * })
     */
    upsert<T extends CourseCreatorUpsertArgs>(args: SelectSubset<T, CourseCreatorUpsertArgs<ExtArgs>>): Prisma__CourseCreatorClient<$Result.GetResult<Prisma.$CourseCreatorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CourseCreators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCreatorCountArgs} args - Arguments to filter CourseCreators to count.
     * @example
     * // Count the number of CourseCreators
     * const count = await prisma.courseCreator.count({
     *   where: {
     *     // ... the filter for the CourseCreators we want to count
     *   }
     * })
    **/
    count<T extends CourseCreatorCountArgs>(
      args?: Subset<T, CourseCreatorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCreatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseCreator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCreatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseCreatorAggregateArgs>(args: Subset<T, CourseCreatorAggregateArgs>): Prisma.PrismaPromise<GetCourseCreatorAggregateType<T>>

    /**
     * Group by CourseCreator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCreatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseCreatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseCreatorGroupByArgs['orderBy'] }
        : { orderBy?: CourseCreatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseCreatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseCreatorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseCreator model
   */
  readonly fields: CourseCreatorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseCreator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseCreatorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    User<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseCreator model
   */ 
  interface CourseCreatorFieldRefs {
    readonly id: FieldRef<"CourseCreator", 'Int'>
    readonly courseId: FieldRef<"CourseCreator", 'Int'>
    readonly userId: FieldRef<"CourseCreator", 'String'>
    readonly as: FieldRef<"CourseCreator", 'CourseAs'>
    readonly createdAt: FieldRef<"CourseCreator", 'DateTime'>
    readonly updatedAt: FieldRef<"CourseCreator", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CourseCreator findUnique
   */
  export type CourseCreatorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCreator
     */
    select?: CourseCreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCreatorInclude<ExtArgs> | null
    /**
     * Filter, which CourseCreator to fetch.
     */
    where: CourseCreatorWhereUniqueInput
  }

  /**
   * CourseCreator findUniqueOrThrow
   */
  export type CourseCreatorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCreator
     */
    select?: CourseCreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCreatorInclude<ExtArgs> | null
    /**
     * Filter, which CourseCreator to fetch.
     */
    where: CourseCreatorWhereUniqueInput
  }

  /**
   * CourseCreator findFirst
   */
  export type CourseCreatorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCreator
     */
    select?: CourseCreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCreatorInclude<ExtArgs> | null
    /**
     * Filter, which CourseCreator to fetch.
     */
    where?: CourseCreatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseCreators to fetch.
     */
    orderBy?: CourseCreatorOrderByWithRelationInput | CourseCreatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseCreators.
     */
    cursor?: CourseCreatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseCreators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseCreators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseCreators.
     */
    distinct?: CourseCreatorScalarFieldEnum | CourseCreatorScalarFieldEnum[]
  }

  /**
   * CourseCreator findFirstOrThrow
   */
  export type CourseCreatorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCreator
     */
    select?: CourseCreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCreatorInclude<ExtArgs> | null
    /**
     * Filter, which CourseCreator to fetch.
     */
    where?: CourseCreatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseCreators to fetch.
     */
    orderBy?: CourseCreatorOrderByWithRelationInput | CourseCreatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseCreators.
     */
    cursor?: CourseCreatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseCreators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseCreators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseCreators.
     */
    distinct?: CourseCreatorScalarFieldEnum | CourseCreatorScalarFieldEnum[]
  }

  /**
   * CourseCreator findMany
   */
  export type CourseCreatorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCreator
     */
    select?: CourseCreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCreatorInclude<ExtArgs> | null
    /**
     * Filter, which CourseCreators to fetch.
     */
    where?: CourseCreatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseCreators to fetch.
     */
    orderBy?: CourseCreatorOrderByWithRelationInput | CourseCreatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseCreators.
     */
    cursor?: CourseCreatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseCreators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseCreators.
     */
    skip?: number
    distinct?: CourseCreatorScalarFieldEnum | CourseCreatorScalarFieldEnum[]
  }

  /**
   * CourseCreator create
   */
  export type CourseCreatorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCreator
     */
    select?: CourseCreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCreatorInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseCreator.
     */
    data: XOR<CourseCreatorCreateInput, CourseCreatorUncheckedCreateInput>
  }

  /**
   * CourseCreator createMany
   */
  export type CourseCreatorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseCreators.
     */
    data: CourseCreatorCreateManyInput | CourseCreatorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseCreator update
   */
  export type CourseCreatorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCreator
     */
    select?: CourseCreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCreatorInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseCreator.
     */
    data: XOR<CourseCreatorUpdateInput, CourseCreatorUncheckedUpdateInput>
    /**
     * Choose, which CourseCreator to update.
     */
    where: CourseCreatorWhereUniqueInput
  }

  /**
   * CourseCreator updateMany
   */
  export type CourseCreatorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseCreators.
     */
    data: XOR<CourseCreatorUpdateManyMutationInput, CourseCreatorUncheckedUpdateManyInput>
    /**
     * Filter which CourseCreators to update
     */
    where?: CourseCreatorWhereInput
  }

  /**
   * CourseCreator upsert
   */
  export type CourseCreatorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCreator
     */
    select?: CourseCreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCreatorInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseCreator to update in case it exists.
     */
    where: CourseCreatorWhereUniqueInput
    /**
     * In case the CourseCreator found by the `where` argument doesn't exist, create a new CourseCreator with this data.
     */
    create: XOR<CourseCreatorCreateInput, CourseCreatorUncheckedCreateInput>
    /**
     * In case the CourseCreator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseCreatorUpdateInput, CourseCreatorUncheckedUpdateInput>
  }

  /**
   * CourseCreator delete
   */
  export type CourseCreatorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCreator
     */
    select?: CourseCreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCreatorInclude<ExtArgs> | null
    /**
     * Filter which CourseCreator to delete.
     */
    where: CourseCreatorWhereUniqueInput
  }

  /**
   * CourseCreator deleteMany
   */
  export type CourseCreatorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseCreators to delete
     */
    where?: CourseCreatorWhereInput
  }

  /**
   * CourseCreator without action
   */
  export type CourseCreatorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCreator
     */
    select?: CourseCreatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCreatorInclude<ExtArgs> | null
  }


  /**
   * Model CourseLogging
   */

  export type AggregateCourseLogging = {
    _count: CourseLoggingCountAggregateOutputType | null
    _avg: CourseLoggingAvgAggregateOutputType | null
    _sum: CourseLoggingSumAggregateOutputType | null
    _min: CourseLoggingMinAggregateOutputType | null
    _max: CourseLoggingMaxAggregateOutputType | null
  }

  export type CourseLoggingAvgAggregateOutputType = {
    id: number | null
    courseId: number | null
    syllabusContentId: number | null
    materialContentId: number | null
    examId: number | null
  }

  export type CourseLoggingSumAggregateOutputType = {
    id: number | null
    courseId: number | null
    syllabusContentId: number | null
    materialContentId: number | null
    examId: number | null
  }

  export type CourseLoggingMinAggregateOutputType = {
    id: number | null
    courseId: number | null
    userId: string | null
    syllabusContentId: number | null
    materialContentId: number | null
    examId: number | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseLoggingMaxAggregateOutputType = {
    id: number | null
    courseId: number | null
    userId: string | null
    syllabusContentId: number | null
    materialContentId: number | null
    examId: number | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseLoggingCountAggregateOutputType = {
    id: number
    courseId: number
    userId: number
    syllabusContentId: number
    materialContentId: number
    examId: number
    isRead: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CourseLoggingAvgAggregateInputType = {
    id?: true
    courseId?: true
    syllabusContentId?: true
    materialContentId?: true
    examId?: true
  }

  export type CourseLoggingSumAggregateInputType = {
    id?: true
    courseId?: true
    syllabusContentId?: true
    materialContentId?: true
    examId?: true
  }

  export type CourseLoggingMinAggregateInputType = {
    id?: true
    courseId?: true
    userId?: true
    syllabusContentId?: true
    materialContentId?: true
    examId?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseLoggingMaxAggregateInputType = {
    id?: true
    courseId?: true
    userId?: true
    syllabusContentId?: true
    materialContentId?: true
    examId?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseLoggingCountAggregateInputType = {
    id?: true
    courseId?: true
    userId?: true
    syllabusContentId?: true
    materialContentId?: true
    examId?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CourseLoggingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseLogging to aggregate.
     */
    where?: CourseLoggingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseLoggings to fetch.
     */
    orderBy?: CourseLoggingOrderByWithRelationInput | CourseLoggingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseLoggingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseLoggings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseLoggings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseLoggings
    **/
    _count?: true | CourseLoggingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseLoggingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseLoggingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseLoggingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseLoggingMaxAggregateInputType
  }

  export type GetCourseLoggingAggregateType<T extends CourseLoggingAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseLogging]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseLogging[P]>
      : GetScalarType<T[P], AggregateCourseLogging[P]>
  }




  export type CourseLoggingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseLoggingWhereInput
    orderBy?: CourseLoggingOrderByWithAggregationInput | CourseLoggingOrderByWithAggregationInput[]
    by: CourseLoggingScalarFieldEnum[] | CourseLoggingScalarFieldEnum
    having?: CourseLoggingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseLoggingCountAggregateInputType | true
    _avg?: CourseLoggingAvgAggregateInputType
    _sum?: CourseLoggingSumAggregateInputType
    _min?: CourseLoggingMinAggregateInputType
    _max?: CourseLoggingMaxAggregateInputType
  }

  export type CourseLoggingGroupByOutputType = {
    id: number
    courseId: number
    userId: string
    syllabusContentId: number
    materialContentId: number | null
    examId: number | null
    isRead: boolean
    createdAt: Date
    updatedAt: Date
    _count: CourseLoggingCountAggregateOutputType | null
    _avg: CourseLoggingAvgAggregateOutputType | null
    _sum: CourseLoggingSumAggregateOutputType | null
    _min: CourseLoggingMinAggregateOutputType | null
    _max: CourseLoggingMaxAggregateOutputType | null
  }

  type GetCourseLoggingGroupByPayload<T extends CourseLoggingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseLoggingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseLoggingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseLoggingGroupByOutputType[P]>
            : GetScalarType<T[P], CourseLoggingGroupByOutputType[P]>
        }
      >
    >


  export type CourseLoggingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    userId?: boolean
    syllabusContentId?: boolean
    materialContentId?: boolean
    examId?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Course?: boolean | CourseDefaultArgs<ExtArgs>
    User?: boolean | UsersDefaultArgs<ExtArgs>
    SyllabusContent?: boolean | SyllabusContentDefaultArgs<ExtArgs>
    MaterialContent?: boolean | CourseLogging$MaterialContentArgs<ExtArgs>
    Exam?: boolean | CourseLogging$ExamArgs<ExtArgs>
  }, ExtArgs["result"]["courseLogging"]>


  export type CourseLoggingSelectScalar = {
    id?: boolean
    courseId?: boolean
    userId?: boolean
    syllabusContentId?: boolean
    materialContentId?: boolean
    examId?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CourseLoggingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Course?: boolean | CourseDefaultArgs<ExtArgs>
    User?: boolean | UsersDefaultArgs<ExtArgs>
    SyllabusContent?: boolean | SyllabusContentDefaultArgs<ExtArgs>
    MaterialContent?: boolean | CourseLogging$MaterialContentArgs<ExtArgs>
    Exam?: boolean | CourseLogging$ExamArgs<ExtArgs>
  }

  export type $CourseLoggingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseLogging"
    objects: {
      Course: Prisma.$CoursePayload<ExtArgs>
      User: Prisma.$UsersPayload<ExtArgs>
      SyllabusContent: Prisma.$SyllabusContentPayload<ExtArgs>
      MaterialContent: Prisma.$MaterialContentPayload<ExtArgs> | null
      Exam: Prisma.$ExamPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      courseId: number
      userId: string
      syllabusContentId: number
      materialContentId: number | null
      examId: number | null
      isRead: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["courseLogging"]>
    composites: {}
  }

  type CourseLoggingGetPayload<S extends boolean | null | undefined | CourseLoggingDefaultArgs> = $Result.GetResult<Prisma.$CourseLoggingPayload, S>

  type CourseLoggingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CourseLoggingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourseLoggingCountAggregateInputType | true
    }

  export interface CourseLoggingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseLogging'], meta: { name: 'CourseLogging' } }
    /**
     * Find zero or one CourseLogging that matches the filter.
     * @param {CourseLoggingFindUniqueArgs} args - Arguments to find a CourseLogging
     * @example
     * // Get one CourseLogging
     * const courseLogging = await prisma.courseLogging.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseLoggingFindUniqueArgs>(args: SelectSubset<T, CourseLoggingFindUniqueArgs<ExtArgs>>): Prisma__CourseLoggingClient<$Result.GetResult<Prisma.$CourseLoggingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CourseLogging that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CourseLoggingFindUniqueOrThrowArgs} args - Arguments to find a CourseLogging
     * @example
     * // Get one CourseLogging
     * const courseLogging = await prisma.courseLogging.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseLoggingFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseLoggingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseLoggingClient<$Result.GetResult<Prisma.$CourseLoggingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CourseLogging that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseLoggingFindFirstArgs} args - Arguments to find a CourseLogging
     * @example
     * // Get one CourseLogging
     * const courseLogging = await prisma.courseLogging.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseLoggingFindFirstArgs>(args?: SelectSubset<T, CourseLoggingFindFirstArgs<ExtArgs>>): Prisma__CourseLoggingClient<$Result.GetResult<Prisma.$CourseLoggingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CourseLogging that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseLoggingFindFirstOrThrowArgs} args - Arguments to find a CourseLogging
     * @example
     * // Get one CourseLogging
     * const courseLogging = await prisma.courseLogging.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseLoggingFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseLoggingFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseLoggingClient<$Result.GetResult<Prisma.$CourseLoggingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CourseLoggings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseLoggingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseLoggings
     * const courseLoggings = await prisma.courseLogging.findMany()
     * 
     * // Get first 10 CourseLoggings
     * const courseLoggings = await prisma.courseLogging.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseLoggingWithIdOnly = await prisma.courseLogging.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseLoggingFindManyArgs>(args?: SelectSubset<T, CourseLoggingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseLoggingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CourseLogging.
     * @param {CourseLoggingCreateArgs} args - Arguments to create a CourseLogging.
     * @example
     * // Create one CourseLogging
     * const CourseLogging = await prisma.courseLogging.create({
     *   data: {
     *     // ... data to create a CourseLogging
     *   }
     * })
     * 
     */
    create<T extends CourseLoggingCreateArgs>(args: SelectSubset<T, CourseLoggingCreateArgs<ExtArgs>>): Prisma__CourseLoggingClient<$Result.GetResult<Prisma.$CourseLoggingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CourseLoggings.
     * @param {CourseLoggingCreateManyArgs} args - Arguments to create many CourseLoggings.
     * @example
     * // Create many CourseLoggings
     * const courseLogging = await prisma.courseLogging.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseLoggingCreateManyArgs>(args?: SelectSubset<T, CourseLoggingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CourseLogging.
     * @param {CourseLoggingDeleteArgs} args - Arguments to delete one CourseLogging.
     * @example
     * // Delete one CourseLogging
     * const CourseLogging = await prisma.courseLogging.delete({
     *   where: {
     *     // ... filter to delete one CourseLogging
     *   }
     * })
     * 
     */
    delete<T extends CourseLoggingDeleteArgs>(args: SelectSubset<T, CourseLoggingDeleteArgs<ExtArgs>>): Prisma__CourseLoggingClient<$Result.GetResult<Prisma.$CourseLoggingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CourseLogging.
     * @param {CourseLoggingUpdateArgs} args - Arguments to update one CourseLogging.
     * @example
     * // Update one CourseLogging
     * const courseLogging = await prisma.courseLogging.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseLoggingUpdateArgs>(args: SelectSubset<T, CourseLoggingUpdateArgs<ExtArgs>>): Prisma__CourseLoggingClient<$Result.GetResult<Prisma.$CourseLoggingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CourseLoggings.
     * @param {CourseLoggingDeleteManyArgs} args - Arguments to filter CourseLoggings to delete.
     * @example
     * // Delete a few CourseLoggings
     * const { count } = await prisma.courseLogging.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseLoggingDeleteManyArgs>(args?: SelectSubset<T, CourseLoggingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseLoggings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseLoggingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseLoggings
     * const courseLogging = await prisma.courseLogging.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseLoggingUpdateManyArgs>(args: SelectSubset<T, CourseLoggingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CourseLogging.
     * @param {CourseLoggingUpsertArgs} args - Arguments to update or create a CourseLogging.
     * @example
     * // Update or create a CourseLogging
     * const courseLogging = await prisma.courseLogging.upsert({
     *   create: {
     *     // ... data to create a CourseLogging
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseLogging we want to update
     *   }
     * })
     */
    upsert<T extends CourseLoggingUpsertArgs>(args: SelectSubset<T, CourseLoggingUpsertArgs<ExtArgs>>): Prisma__CourseLoggingClient<$Result.GetResult<Prisma.$CourseLoggingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CourseLoggings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseLoggingCountArgs} args - Arguments to filter CourseLoggings to count.
     * @example
     * // Count the number of CourseLoggings
     * const count = await prisma.courseLogging.count({
     *   where: {
     *     // ... the filter for the CourseLoggings we want to count
     *   }
     * })
    **/
    count<T extends CourseLoggingCountArgs>(
      args?: Subset<T, CourseLoggingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseLoggingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseLogging.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseLoggingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseLoggingAggregateArgs>(args: Subset<T, CourseLoggingAggregateArgs>): Prisma.PrismaPromise<GetCourseLoggingAggregateType<T>>

    /**
     * Group by CourseLogging.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseLoggingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseLoggingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseLoggingGroupByArgs['orderBy'] }
        : { orderBy?: CourseLoggingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseLoggingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseLoggingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseLogging model
   */
  readonly fields: CourseLoggingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseLogging.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseLoggingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    User<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    SyllabusContent<T extends SyllabusContentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SyllabusContentDefaultArgs<ExtArgs>>): Prisma__SyllabusContentClient<$Result.GetResult<Prisma.$SyllabusContentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    MaterialContent<T extends CourseLogging$MaterialContentArgs<ExtArgs> = {}>(args?: Subset<T, CourseLogging$MaterialContentArgs<ExtArgs>>): Prisma__MaterialContentClient<$Result.GetResult<Prisma.$MaterialContentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Exam<T extends CourseLogging$ExamArgs<ExtArgs> = {}>(args?: Subset<T, CourseLogging$ExamArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseLogging model
   */ 
  interface CourseLoggingFieldRefs {
    readonly id: FieldRef<"CourseLogging", 'Int'>
    readonly courseId: FieldRef<"CourseLogging", 'Int'>
    readonly userId: FieldRef<"CourseLogging", 'String'>
    readonly syllabusContentId: FieldRef<"CourseLogging", 'Int'>
    readonly materialContentId: FieldRef<"CourseLogging", 'Int'>
    readonly examId: FieldRef<"CourseLogging", 'Int'>
    readonly isRead: FieldRef<"CourseLogging", 'Boolean'>
    readonly createdAt: FieldRef<"CourseLogging", 'DateTime'>
    readonly updatedAt: FieldRef<"CourseLogging", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CourseLogging findUnique
   */
  export type CourseLoggingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLogging
     */
    select?: CourseLoggingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLoggingInclude<ExtArgs> | null
    /**
     * Filter, which CourseLogging to fetch.
     */
    where: CourseLoggingWhereUniqueInput
  }

  /**
   * CourseLogging findUniqueOrThrow
   */
  export type CourseLoggingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLogging
     */
    select?: CourseLoggingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLoggingInclude<ExtArgs> | null
    /**
     * Filter, which CourseLogging to fetch.
     */
    where: CourseLoggingWhereUniqueInput
  }

  /**
   * CourseLogging findFirst
   */
  export type CourseLoggingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLogging
     */
    select?: CourseLoggingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLoggingInclude<ExtArgs> | null
    /**
     * Filter, which CourseLogging to fetch.
     */
    where?: CourseLoggingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseLoggings to fetch.
     */
    orderBy?: CourseLoggingOrderByWithRelationInput | CourseLoggingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseLoggings.
     */
    cursor?: CourseLoggingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseLoggings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseLoggings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseLoggings.
     */
    distinct?: CourseLoggingScalarFieldEnum | CourseLoggingScalarFieldEnum[]
  }

  /**
   * CourseLogging findFirstOrThrow
   */
  export type CourseLoggingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLogging
     */
    select?: CourseLoggingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLoggingInclude<ExtArgs> | null
    /**
     * Filter, which CourseLogging to fetch.
     */
    where?: CourseLoggingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseLoggings to fetch.
     */
    orderBy?: CourseLoggingOrderByWithRelationInput | CourseLoggingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseLoggings.
     */
    cursor?: CourseLoggingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseLoggings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseLoggings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseLoggings.
     */
    distinct?: CourseLoggingScalarFieldEnum | CourseLoggingScalarFieldEnum[]
  }

  /**
   * CourseLogging findMany
   */
  export type CourseLoggingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLogging
     */
    select?: CourseLoggingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLoggingInclude<ExtArgs> | null
    /**
     * Filter, which CourseLoggings to fetch.
     */
    where?: CourseLoggingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseLoggings to fetch.
     */
    orderBy?: CourseLoggingOrderByWithRelationInput | CourseLoggingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseLoggings.
     */
    cursor?: CourseLoggingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseLoggings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseLoggings.
     */
    skip?: number
    distinct?: CourseLoggingScalarFieldEnum | CourseLoggingScalarFieldEnum[]
  }

  /**
   * CourseLogging create
   */
  export type CourseLoggingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLogging
     */
    select?: CourseLoggingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLoggingInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseLogging.
     */
    data: XOR<CourseLoggingCreateInput, CourseLoggingUncheckedCreateInput>
  }

  /**
   * CourseLogging createMany
   */
  export type CourseLoggingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseLoggings.
     */
    data: CourseLoggingCreateManyInput | CourseLoggingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseLogging update
   */
  export type CourseLoggingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLogging
     */
    select?: CourseLoggingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLoggingInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseLogging.
     */
    data: XOR<CourseLoggingUpdateInput, CourseLoggingUncheckedUpdateInput>
    /**
     * Choose, which CourseLogging to update.
     */
    where: CourseLoggingWhereUniqueInput
  }

  /**
   * CourseLogging updateMany
   */
  export type CourseLoggingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseLoggings.
     */
    data: XOR<CourseLoggingUpdateManyMutationInput, CourseLoggingUncheckedUpdateManyInput>
    /**
     * Filter which CourseLoggings to update
     */
    where?: CourseLoggingWhereInput
  }

  /**
   * CourseLogging upsert
   */
  export type CourseLoggingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLogging
     */
    select?: CourseLoggingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLoggingInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseLogging to update in case it exists.
     */
    where: CourseLoggingWhereUniqueInput
    /**
     * In case the CourseLogging found by the `where` argument doesn't exist, create a new CourseLogging with this data.
     */
    create: XOR<CourseLoggingCreateInput, CourseLoggingUncheckedCreateInput>
    /**
     * In case the CourseLogging was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseLoggingUpdateInput, CourseLoggingUncheckedUpdateInput>
  }

  /**
   * CourseLogging delete
   */
  export type CourseLoggingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLogging
     */
    select?: CourseLoggingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLoggingInclude<ExtArgs> | null
    /**
     * Filter which CourseLogging to delete.
     */
    where: CourseLoggingWhereUniqueInput
  }

  /**
   * CourseLogging deleteMany
   */
  export type CourseLoggingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseLoggings to delete
     */
    where?: CourseLoggingWhereInput
  }

  /**
   * CourseLogging.MaterialContent
   */
  export type CourseLogging$MaterialContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContent
     */
    select?: MaterialContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentInclude<ExtArgs> | null
    where?: MaterialContentWhereInput
  }

  /**
   * CourseLogging.Exam
   */
  export type CourseLogging$ExamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    where?: ExamWhereInput
  }

  /**
   * CourseLogging without action
   */
  export type CourseLoggingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLogging
     */
    select?: CourseLoggingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLoggingInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
    order: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
    order: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    title: string | null
    isActive: boolean | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
    slug: string | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    title: string | null
    isActive: boolean | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
    slug: string | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    title: number
    isActive: number
    order: number
    createdAt: number
    updatedAt: number
    slug: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
    order?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
    order?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    title?: true
    isActive?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    slug?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    title?: true
    isActive?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    slug?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    title?: true
    isActive?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    slug?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: number
    title: string
    isActive: boolean
    order: number
    createdAt: Date
    updatedAt: Date
    slug: string
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    isActive?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    slug?: boolean
    SubCategories?: boolean | Category$SubCategoriesArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>


  export type CategorySelectScalar = {
    id?: boolean
    title?: boolean
    isActive?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    slug?: boolean
  }

  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SubCategories?: boolean | Category$SubCategoriesArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      SubCategories: Prisma.$SubCategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      isActive: boolean
      order: number
      createdAt: Date
      updatedAt: Date
      slug: string
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    SubCategories<T extends Category$SubCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Category$SubCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */ 
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'Int'>
    readonly title: FieldRef<"Category", 'String'>
    readonly isActive: FieldRef<"Category", 'Boolean'>
    readonly order: FieldRef<"Category", 'Int'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
    readonly slug: FieldRef<"Category", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
  }

  /**
   * Category.SubCategories
   */
  export type Category$SubCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    where?: SubCategoryWhereInput
    orderBy?: SubCategoryOrderByWithRelationInput | SubCategoryOrderByWithRelationInput[]
    cursor?: SubCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubCategoryScalarFieldEnum | SubCategoryScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model SubCategory
   */

  export type AggregateSubCategory = {
    _count: SubCategoryCountAggregateOutputType | null
    _avg: SubCategoryAvgAggregateOutputType | null
    _sum: SubCategorySumAggregateOutputType | null
    _min: SubCategoryMinAggregateOutputType | null
    _max: SubCategoryMaxAggregateOutputType | null
  }

  export type SubCategoryAvgAggregateOutputType = {
    id: number | null
    categoryId: number | null
    order: number | null
  }

  export type SubCategorySumAggregateOutputType = {
    id: number | null
    categoryId: number | null
    order: number | null
  }

  export type SubCategoryMinAggregateOutputType = {
    id: number | null
    title: string | null
    isActive: boolean | null
    categoryId: number | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
    slug: string | null
  }

  export type SubCategoryMaxAggregateOutputType = {
    id: number | null
    title: string | null
    isActive: boolean | null
    categoryId: number | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
    slug: string | null
  }

  export type SubCategoryCountAggregateOutputType = {
    id: number
    title: number
    isActive: number
    categoryId: number
    order: number
    createdAt: number
    updatedAt: number
    slug: number
    _all: number
  }


  export type SubCategoryAvgAggregateInputType = {
    id?: true
    categoryId?: true
    order?: true
  }

  export type SubCategorySumAggregateInputType = {
    id?: true
    categoryId?: true
    order?: true
  }

  export type SubCategoryMinAggregateInputType = {
    id?: true
    title?: true
    isActive?: true
    categoryId?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    slug?: true
  }

  export type SubCategoryMaxAggregateInputType = {
    id?: true
    title?: true
    isActive?: true
    categoryId?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    slug?: true
  }

  export type SubCategoryCountAggregateInputType = {
    id?: true
    title?: true
    isActive?: true
    categoryId?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    slug?: true
    _all?: true
  }

  export type SubCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubCategory to aggregate.
     */
    where?: SubCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategories to fetch.
     */
    orderBy?: SubCategoryOrderByWithRelationInput | SubCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubCategories
    **/
    _count?: true | SubCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubCategoryMaxAggregateInputType
  }

  export type GetSubCategoryAggregateType<T extends SubCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateSubCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubCategory[P]>
      : GetScalarType<T[P], AggregateSubCategory[P]>
  }




  export type SubCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubCategoryWhereInput
    orderBy?: SubCategoryOrderByWithAggregationInput | SubCategoryOrderByWithAggregationInput[]
    by: SubCategoryScalarFieldEnum[] | SubCategoryScalarFieldEnum
    having?: SubCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubCategoryCountAggregateInputType | true
    _avg?: SubCategoryAvgAggregateInputType
    _sum?: SubCategorySumAggregateInputType
    _min?: SubCategoryMinAggregateInputType
    _max?: SubCategoryMaxAggregateInputType
  }

  export type SubCategoryGroupByOutputType = {
    id: number
    title: string
    isActive: boolean
    categoryId: number
    order: number
    createdAt: Date
    updatedAt: Date
    slug: string
    _count: SubCategoryCountAggregateOutputType | null
    _avg: SubCategoryAvgAggregateOutputType | null
    _sum: SubCategorySumAggregateOutputType | null
    _min: SubCategoryMinAggregateOutputType | null
    _max: SubCategoryMaxAggregateOutputType | null
  }

  type GetSubCategoryGroupByPayload<T extends SubCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], SubCategoryGroupByOutputType[P]>
        }
      >
    >


  export type SubCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    isActive?: boolean
    categoryId?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    slug?: boolean
    Category?: boolean | CategoryDefaultArgs<ExtArgs>
    Topics?: boolean | SubCategory$TopicsArgs<ExtArgs>
    _count?: boolean | SubCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subCategory"]>


  export type SubCategorySelectScalar = {
    id?: boolean
    title?: boolean
    isActive?: boolean
    categoryId?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    slug?: boolean
  }

  export type SubCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Category?: boolean | CategoryDefaultArgs<ExtArgs>
    Topics?: boolean | SubCategory$TopicsArgs<ExtArgs>
    _count?: boolean | SubCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SubCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubCategory"
    objects: {
      Category: Prisma.$CategoryPayload<ExtArgs>
      Topics: Prisma.$TopicPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      isActive: boolean
      categoryId: number
      order: number
      createdAt: Date
      updatedAt: Date
      slug: string
    }, ExtArgs["result"]["subCategory"]>
    composites: {}
  }

  type SubCategoryGetPayload<S extends boolean | null | undefined | SubCategoryDefaultArgs> = $Result.GetResult<Prisma.$SubCategoryPayload, S>

  type SubCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubCategoryCountAggregateInputType | true
    }

  export interface SubCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubCategory'], meta: { name: 'SubCategory' } }
    /**
     * Find zero or one SubCategory that matches the filter.
     * @param {SubCategoryFindUniqueArgs} args - Arguments to find a SubCategory
     * @example
     * // Get one SubCategory
     * const subCategory = await prisma.subCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubCategoryFindUniqueArgs>(args: SelectSubset<T, SubCategoryFindUniqueArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SubCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubCategoryFindUniqueOrThrowArgs} args - Arguments to find a SubCategory
     * @example
     * // Get one SubCategory
     * const subCategory = await prisma.subCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, SubCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SubCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryFindFirstArgs} args - Arguments to find a SubCategory
     * @example
     * // Get one SubCategory
     * const subCategory = await prisma.subCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubCategoryFindFirstArgs>(args?: SelectSubset<T, SubCategoryFindFirstArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SubCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryFindFirstOrThrowArgs} args - Arguments to find a SubCategory
     * @example
     * // Get one SubCategory
     * const subCategory = await prisma.subCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, SubCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SubCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubCategories
     * const subCategories = await prisma.subCategory.findMany()
     * 
     * // Get first 10 SubCategories
     * const subCategories = await prisma.subCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subCategoryWithIdOnly = await prisma.subCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubCategoryFindManyArgs>(args?: SelectSubset<T, SubCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SubCategory.
     * @param {SubCategoryCreateArgs} args - Arguments to create a SubCategory.
     * @example
     * // Create one SubCategory
     * const SubCategory = await prisma.subCategory.create({
     *   data: {
     *     // ... data to create a SubCategory
     *   }
     * })
     * 
     */
    create<T extends SubCategoryCreateArgs>(args: SelectSubset<T, SubCategoryCreateArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SubCategories.
     * @param {SubCategoryCreateManyArgs} args - Arguments to create many SubCategories.
     * @example
     * // Create many SubCategories
     * const subCategory = await prisma.subCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubCategoryCreateManyArgs>(args?: SelectSubset<T, SubCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SubCategory.
     * @param {SubCategoryDeleteArgs} args - Arguments to delete one SubCategory.
     * @example
     * // Delete one SubCategory
     * const SubCategory = await prisma.subCategory.delete({
     *   where: {
     *     // ... filter to delete one SubCategory
     *   }
     * })
     * 
     */
    delete<T extends SubCategoryDeleteArgs>(args: SelectSubset<T, SubCategoryDeleteArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SubCategory.
     * @param {SubCategoryUpdateArgs} args - Arguments to update one SubCategory.
     * @example
     * // Update one SubCategory
     * const subCategory = await prisma.subCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubCategoryUpdateArgs>(args: SelectSubset<T, SubCategoryUpdateArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SubCategories.
     * @param {SubCategoryDeleteManyArgs} args - Arguments to filter SubCategories to delete.
     * @example
     * // Delete a few SubCategories
     * const { count } = await prisma.subCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubCategoryDeleteManyArgs>(args?: SelectSubset<T, SubCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubCategories
     * const subCategory = await prisma.subCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubCategoryUpdateManyArgs>(args: SelectSubset<T, SubCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubCategory.
     * @param {SubCategoryUpsertArgs} args - Arguments to update or create a SubCategory.
     * @example
     * // Update or create a SubCategory
     * const subCategory = await prisma.subCategory.upsert({
     *   create: {
     *     // ... data to create a SubCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubCategory we want to update
     *   }
     * })
     */
    upsert<T extends SubCategoryUpsertArgs>(args: SelectSubset<T, SubCategoryUpsertArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SubCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryCountArgs} args - Arguments to filter SubCategories to count.
     * @example
     * // Count the number of SubCategories
     * const count = await prisma.subCategory.count({
     *   where: {
     *     // ... the filter for the SubCategories we want to count
     *   }
     * })
    **/
    count<T extends SubCategoryCountArgs>(
      args?: Subset<T, SubCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubCategoryAggregateArgs>(args: Subset<T, SubCategoryAggregateArgs>): Prisma.PrismaPromise<GetSubCategoryAggregateType<T>>

    /**
     * Group by SubCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubCategoryGroupByArgs['orderBy'] }
        : { orderBy?: SubCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubCategory model
   */
  readonly fields: SubCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Topics<T extends SubCategory$TopicsArgs<ExtArgs> = {}>(args?: Subset<T, SubCategory$TopicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubCategory model
   */ 
  interface SubCategoryFieldRefs {
    readonly id: FieldRef<"SubCategory", 'Int'>
    readonly title: FieldRef<"SubCategory", 'String'>
    readonly isActive: FieldRef<"SubCategory", 'Boolean'>
    readonly categoryId: FieldRef<"SubCategory", 'Int'>
    readonly order: FieldRef<"SubCategory", 'Int'>
    readonly createdAt: FieldRef<"SubCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"SubCategory", 'DateTime'>
    readonly slug: FieldRef<"SubCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SubCategory findUnique
   */
  export type SubCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SubCategory to fetch.
     */
    where: SubCategoryWhereUniqueInput
  }

  /**
   * SubCategory findUniqueOrThrow
   */
  export type SubCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SubCategory to fetch.
     */
    where: SubCategoryWhereUniqueInput
  }

  /**
   * SubCategory findFirst
   */
  export type SubCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SubCategory to fetch.
     */
    where?: SubCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategories to fetch.
     */
    orderBy?: SubCategoryOrderByWithRelationInput | SubCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubCategories.
     */
    cursor?: SubCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubCategories.
     */
    distinct?: SubCategoryScalarFieldEnum | SubCategoryScalarFieldEnum[]
  }

  /**
   * SubCategory findFirstOrThrow
   */
  export type SubCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SubCategory to fetch.
     */
    where?: SubCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategories to fetch.
     */
    orderBy?: SubCategoryOrderByWithRelationInput | SubCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubCategories.
     */
    cursor?: SubCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubCategories.
     */
    distinct?: SubCategoryScalarFieldEnum | SubCategoryScalarFieldEnum[]
  }

  /**
   * SubCategory findMany
   */
  export type SubCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SubCategories to fetch.
     */
    where?: SubCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategories to fetch.
     */
    orderBy?: SubCategoryOrderByWithRelationInput | SubCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubCategories.
     */
    cursor?: SubCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategories.
     */
    skip?: number
    distinct?: SubCategoryScalarFieldEnum | SubCategoryScalarFieldEnum[]
  }

  /**
   * SubCategory create
   */
  export type SubCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a SubCategory.
     */
    data: XOR<SubCategoryCreateInput, SubCategoryUncheckedCreateInput>
  }

  /**
   * SubCategory createMany
   */
  export type SubCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubCategories.
     */
    data: SubCategoryCreateManyInput | SubCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubCategory update
   */
  export type SubCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a SubCategory.
     */
    data: XOR<SubCategoryUpdateInput, SubCategoryUncheckedUpdateInput>
    /**
     * Choose, which SubCategory to update.
     */
    where: SubCategoryWhereUniqueInput
  }

  /**
   * SubCategory updateMany
   */
  export type SubCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubCategories.
     */
    data: XOR<SubCategoryUpdateManyMutationInput, SubCategoryUncheckedUpdateManyInput>
    /**
     * Filter which SubCategories to update
     */
    where?: SubCategoryWhereInput
  }

  /**
   * SubCategory upsert
   */
  export type SubCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the SubCategory to update in case it exists.
     */
    where: SubCategoryWhereUniqueInput
    /**
     * In case the SubCategory found by the `where` argument doesn't exist, create a new SubCategory with this data.
     */
    create: XOR<SubCategoryCreateInput, SubCategoryUncheckedCreateInput>
    /**
     * In case the SubCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubCategoryUpdateInput, SubCategoryUncheckedUpdateInput>
  }

  /**
   * SubCategory delete
   */
  export type SubCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * Filter which SubCategory to delete.
     */
    where: SubCategoryWhereUniqueInput
  }

  /**
   * SubCategory deleteMany
   */
  export type SubCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubCategories to delete
     */
    where?: SubCategoryWhereInput
  }

  /**
   * SubCategory.Topics
   */
  export type SubCategory$TopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    where?: TopicWhereInput
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    cursor?: TopicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * SubCategory without action
   */
  export type SubCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Topic
   */

  export type AggregateTopic = {
    _count: TopicCountAggregateOutputType | null
    _avg: TopicAvgAggregateOutputType | null
    _sum: TopicSumAggregateOutputType | null
    _min: TopicMinAggregateOutputType | null
    _max: TopicMaxAggregateOutputType | null
  }

  export type TopicAvgAggregateOutputType = {
    id: number | null
    subCategoryId: number | null
    order: number | null
  }

  export type TopicSumAggregateOutputType = {
    id: number | null
    subCategoryId: number | null
    order: number | null
  }

  export type TopicMinAggregateOutputType = {
    id: number | null
    title: string | null
    isActive: boolean | null
    subCategoryId: number | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
    slug: string | null
  }

  export type TopicMaxAggregateOutputType = {
    id: number | null
    title: string | null
    isActive: boolean | null
    subCategoryId: number | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
    slug: string | null
  }

  export type TopicCountAggregateOutputType = {
    id: number
    title: number
    isActive: number
    subCategoryId: number
    order: number
    createdAt: number
    updatedAt: number
    slug: number
    _all: number
  }


  export type TopicAvgAggregateInputType = {
    id?: true
    subCategoryId?: true
    order?: true
  }

  export type TopicSumAggregateInputType = {
    id?: true
    subCategoryId?: true
    order?: true
  }

  export type TopicMinAggregateInputType = {
    id?: true
    title?: true
    isActive?: true
    subCategoryId?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    slug?: true
  }

  export type TopicMaxAggregateInputType = {
    id?: true
    title?: true
    isActive?: true
    subCategoryId?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    slug?: true
  }

  export type TopicCountAggregateInputType = {
    id?: true
    title?: true
    isActive?: true
    subCategoryId?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    slug?: true
    _all?: true
  }

  export type TopicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Topic to aggregate.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Topics
    **/
    _count?: true | TopicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TopicAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TopicSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TopicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TopicMaxAggregateInputType
  }

  export type GetTopicAggregateType<T extends TopicAggregateArgs> = {
        [P in keyof T & keyof AggregateTopic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTopic[P]>
      : GetScalarType<T[P], AggregateTopic[P]>
  }




  export type TopicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicWhereInput
    orderBy?: TopicOrderByWithAggregationInput | TopicOrderByWithAggregationInput[]
    by: TopicScalarFieldEnum[] | TopicScalarFieldEnum
    having?: TopicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TopicCountAggregateInputType | true
    _avg?: TopicAvgAggregateInputType
    _sum?: TopicSumAggregateInputType
    _min?: TopicMinAggregateInputType
    _max?: TopicMaxAggregateInputType
  }

  export type TopicGroupByOutputType = {
    id: number
    title: string
    isActive: boolean
    subCategoryId: number
    order: number
    createdAt: Date
    updatedAt: Date
    slug: string
    _count: TopicCountAggregateOutputType | null
    _avg: TopicAvgAggregateOutputType | null
    _sum: TopicSumAggregateOutputType | null
    _min: TopicMinAggregateOutputType | null
    _max: TopicMaxAggregateOutputType | null
  }

  type GetTopicGroupByPayload<T extends TopicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TopicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TopicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TopicGroupByOutputType[P]>
            : GetScalarType<T[P], TopicGroupByOutputType[P]>
        }
      >
    >


  export type TopicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    isActive?: boolean
    subCategoryId?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    slug?: boolean
    CourseTopics?: boolean | Topic$CourseTopicsArgs<ExtArgs>
    SubCategory?: boolean | SubCategoryDefaultArgs<ExtArgs>
    _count?: boolean | TopicCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topic"]>


  export type TopicSelectScalar = {
    id?: boolean
    title?: boolean
    isActive?: boolean
    subCategoryId?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    slug?: boolean
  }

  export type TopicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CourseTopics?: boolean | Topic$CourseTopicsArgs<ExtArgs>
    SubCategory?: boolean | SubCategoryDefaultArgs<ExtArgs>
    _count?: boolean | TopicCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TopicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Topic"
    objects: {
      CourseTopics: Prisma.$CourseTopicPayload<ExtArgs>[]
      SubCategory: Prisma.$SubCategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      isActive: boolean
      subCategoryId: number
      order: number
      createdAt: Date
      updatedAt: Date
      slug: string
    }, ExtArgs["result"]["topic"]>
    composites: {}
  }

  type TopicGetPayload<S extends boolean | null | undefined | TopicDefaultArgs> = $Result.GetResult<Prisma.$TopicPayload, S>

  type TopicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TopicFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TopicCountAggregateInputType | true
    }

  export interface TopicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Topic'], meta: { name: 'Topic' } }
    /**
     * Find zero or one Topic that matches the filter.
     * @param {TopicFindUniqueArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TopicFindUniqueArgs>(args: SelectSubset<T, TopicFindUniqueArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Topic that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TopicFindUniqueOrThrowArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TopicFindUniqueOrThrowArgs>(args: SelectSubset<T, TopicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Topic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindFirstArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TopicFindFirstArgs>(args?: SelectSubset<T, TopicFindFirstArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Topic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindFirstOrThrowArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TopicFindFirstOrThrowArgs>(args?: SelectSubset<T, TopicFindFirstOrThrowArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Topics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Topics
     * const topics = await prisma.topic.findMany()
     * 
     * // Get first 10 Topics
     * const topics = await prisma.topic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const topicWithIdOnly = await prisma.topic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TopicFindManyArgs>(args?: SelectSubset<T, TopicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Topic.
     * @param {TopicCreateArgs} args - Arguments to create a Topic.
     * @example
     * // Create one Topic
     * const Topic = await prisma.topic.create({
     *   data: {
     *     // ... data to create a Topic
     *   }
     * })
     * 
     */
    create<T extends TopicCreateArgs>(args: SelectSubset<T, TopicCreateArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Topics.
     * @param {TopicCreateManyArgs} args - Arguments to create many Topics.
     * @example
     * // Create many Topics
     * const topic = await prisma.topic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TopicCreateManyArgs>(args?: SelectSubset<T, TopicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Topic.
     * @param {TopicDeleteArgs} args - Arguments to delete one Topic.
     * @example
     * // Delete one Topic
     * const Topic = await prisma.topic.delete({
     *   where: {
     *     // ... filter to delete one Topic
     *   }
     * })
     * 
     */
    delete<T extends TopicDeleteArgs>(args: SelectSubset<T, TopicDeleteArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Topic.
     * @param {TopicUpdateArgs} args - Arguments to update one Topic.
     * @example
     * // Update one Topic
     * const topic = await prisma.topic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TopicUpdateArgs>(args: SelectSubset<T, TopicUpdateArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Topics.
     * @param {TopicDeleteManyArgs} args - Arguments to filter Topics to delete.
     * @example
     * // Delete a few Topics
     * const { count } = await prisma.topic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TopicDeleteManyArgs>(args?: SelectSubset<T, TopicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Topics
     * const topic = await prisma.topic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TopicUpdateManyArgs>(args: SelectSubset<T, TopicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Topic.
     * @param {TopicUpsertArgs} args - Arguments to update or create a Topic.
     * @example
     * // Update or create a Topic
     * const topic = await prisma.topic.upsert({
     *   create: {
     *     // ... data to create a Topic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Topic we want to update
     *   }
     * })
     */
    upsert<T extends TopicUpsertArgs>(args: SelectSubset<T, TopicUpsertArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicCountArgs} args - Arguments to filter Topics to count.
     * @example
     * // Count the number of Topics
     * const count = await prisma.topic.count({
     *   where: {
     *     // ... the filter for the Topics we want to count
     *   }
     * })
    **/
    count<T extends TopicCountArgs>(
      args?: Subset<T, TopicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TopicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Topic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TopicAggregateArgs>(args: Subset<T, TopicAggregateArgs>): Prisma.PrismaPromise<GetTopicAggregateType<T>>

    /**
     * Group by Topic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TopicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TopicGroupByArgs['orderBy'] }
        : { orderBy?: TopicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TopicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTopicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Topic model
   */
  readonly fields: TopicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Topic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TopicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CourseTopics<T extends Topic$CourseTopicsArgs<ExtArgs> = {}>(args?: Subset<T, Topic$CourseTopicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseTopicPayload<ExtArgs>, T, "findMany"> | Null>
    SubCategory<T extends SubCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubCategoryDefaultArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Topic model
   */ 
  interface TopicFieldRefs {
    readonly id: FieldRef<"Topic", 'Int'>
    readonly title: FieldRef<"Topic", 'String'>
    readonly isActive: FieldRef<"Topic", 'Boolean'>
    readonly subCategoryId: FieldRef<"Topic", 'Int'>
    readonly order: FieldRef<"Topic", 'Int'>
    readonly createdAt: FieldRef<"Topic", 'DateTime'>
    readonly updatedAt: FieldRef<"Topic", 'DateTime'>
    readonly slug: FieldRef<"Topic", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Topic findUnique
   */
  export type TopicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic findUniqueOrThrow
   */
  export type TopicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic findFirst
   */
  export type TopicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Topics.
     */
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic findFirstOrThrow
   */
  export type TopicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Topics.
     */
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic findMany
   */
  export type TopicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topics to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic create
   */
  export type TopicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The data needed to create a Topic.
     */
    data: XOR<TopicCreateInput, TopicUncheckedCreateInput>
  }

  /**
   * Topic createMany
   */
  export type TopicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Topics.
     */
    data: TopicCreateManyInput | TopicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Topic update
   */
  export type TopicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The data needed to update a Topic.
     */
    data: XOR<TopicUpdateInput, TopicUncheckedUpdateInput>
    /**
     * Choose, which Topic to update.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic updateMany
   */
  export type TopicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Topics.
     */
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyInput>
    /**
     * Filter which Topics to update
     */
    where?: TopicWhereInput
  }

  /**
   * Topic upsert
   */
  export type TopicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The filter to search for the Topic to update in case it exists.
     */
    where: TopicWhereUniqueInput
    /**
     * In case the Topic found by the `where` argument doesn't exist, create a new Topic with this data.
     */
    create: XOR<TopicCreateInput, TopicUncheckedCreateInput>
    /**
     * In case the Topic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TopicUpdateInput, TopicUncheckedUpdateInput>
  }

  /**
   * Topic delete
   */
  export type TopicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter which Topic to delete.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic deleteMany
   */
  export type TopicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Topics to delete
     */
    where?: TopicWhereInput
  }

  /**
   * Topic.CourseTopics
   */
  export type Topic$CourseTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTopic
     */
    select?: CourseTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTopicInclude<ExtArgs> | null
    where?: CourseTopicWhereInput
    orderBy?: CourseTopicOrderByWithRelationInput | CourseTopicOrderByWithRelationInput[]
    cursor?: CourseTopicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseTopicScalarFieldEnum | CourseTopicScalarFieldEnum[]
  }

  /**
   * Topic without action
   */
  export type TopicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
  }


  /**
   * Model CourseTopic
   */

  export type AggregateCourseTopic = {
    _count: CourseTopicCountAggregateOutputType | null
    _avg: CourseTopicAvgAggregateOutputType | null
    _sum: CourseTopicSumAggregateOutputType | null
    _min: CourseTopicMinAggregateOutputType | null
    _max: CourseTopicMaxAggregateOutputType | null
  }

  export type CourseTopicAvgAggregateOutputType = {
    id: number | null
    courseId: number | null
    topicId: number | null
  }

  export type CourseTopicSumAggregateOutputType = {
    id: number | null
    courseId: number | null
    topicId: number | null
  }

  export type CourseTopicMinAggregateOutputType = {
    id: number | null
    courseId: number | null
    topicId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseTopicMaxAggregateOutputType = {
    id: number | null
    courseId: number | null
    topicId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseTopicCountAggregateOutputType = {
    id: number
    courseId: number
    topicId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CourseTopicAvgAggregateInputType = {
    id?: true
    courseId?: true
    topicId?: true
  }

  export type CourseTopicSumAggregateInputType = {
    id?: true
    courseId?: true
    topicId?: true
  }

  export type CourseTopicMinAggregateInputType = {
    id?: true
    courseId?: true
    topicId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseTopicMaxAggregateInputType = {
    id?: true
    courseId?: true
    topicId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseTopicCountAggregateInputType = {
    id?: true
    courseId?: true
    topicId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CourseTopicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseTopic to aggregate.
     */
    where?: CourseTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseTopics to fetch.
     */
    orderBy?: CourseTopicOrderByWithRelationInput | CourseTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseTopics
    **/
    _count?: true | CourseTopicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseTopicAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseTopicSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseTopicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseTopicMaxAggregateInputType
  }

  export type GetCourseTopicAggregateType<T extends CourseTopicAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseTopic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseTopic[P]>
      : GetScalarType<T[P], AggregateCourseTopic[P]>
  }




  export type CourseTopicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseTopicWhereInput
    orderBy?: CourseTopicOrderByWithAggregationInput | CourseTopicOrderByWithAggregationInput[]
    by: CourseTopicScalarFieldEnum[] | CourseTopicScalarFieldEnum
    having?: CourseTopicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseTopicCountAggregateInputType | true
    _avg?: CourseTopicAvgAggregateInputType
    _sum?: CourseTopicSumAggregateInputType
    _min?: CourseTopicMinAggregateInputType
    _max?: CourseTopicMaxAggregateInputType
  }

  export type CourseTopicGroupByOutputType = {
    id: number
    courseId: number
    topicId: number
    createdAt: Date
    updatedAt: Date
    _count: CourseTopicCountAggregateOutputType | null
    _avg: CourseTopicAvgAggregateOutputType | null
    _sum: CourseTopicSumAggregateOutputType | null
    _min: CourseTopicMinAggregateOutputType | null
    _max: CourseTopicMaxAggregateOutputType | null
  }

  type GetCourseTopicGroupByPayload<T extends CourseTopicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseTopicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseTopicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseTopicGroupByOutputType[P]>
            : GetScalarType<T[P], CourseTopicGroupByOutputType[P]>
        }
      >
    >


  export type CourseTopicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    topicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Course?: boolean | CourseDefaultArgs<ExtArgs>
    Topic?: boolean | TopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseTopic"]>


  export type CourseTopicSelectScalar = {
    id?: boolean
    courseId?: boolean
    topicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CourseTopicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Course?: boolean | CourseDefaultArgs<ExtArgs>
    Topic?: boolean | TopicDefaultArgs<ExtArgs>
  }

  export type $CourseTopicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseTopic"
    objects: {
      Course: Prisma.$CoursePayload<ExtArgs>
      Topic: Prisma.$TopicPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      courseId: number
      topicId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["courseTopic"]>
    composites: {}
  }

  type CourseTopicGetPayload<S extends boolean | null | undefined | CourseTopicDefaultArgs> = $Result.GetResult<Prisma.$CourseTopicPayload, S>

  type CourseTopicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CourseTopicFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourseTopicCountAggregateInputType | true
    }

  export interface CourseTopicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseTopic'], meta: { name: 'CourseTopic' } }
    /**
     * Find zero or one CourseTopic that matches the filter.
     * @param {CourseTopicFindUniqueArgs} args - Arguments to find a CourseTopic
     * @example
     * // Get one CourseTopic
     * const courseTopic = await prisma.courseTopic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseTopicFindUniqueArgs>(args: SelectSubset<T, CourseTopicFindUniqueArgs<ExtArgs>>): Prisma__CourseTopicClient<$Result.GetResult<Prisma.$CourseTopicPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CourseTopic that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CourseTopicFindUniqueOrThrowArgs} args - Arguments to find a CourseTopic
     * @example
     * // Get one CourseTopic
     * const courseTopic = await prisma.courseTopic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseTopicFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseTopicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseTopicClient<$Result.GetResult<Prisma.$CourseTopicPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CourseTopic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTopicFindFirstArgs} args - Arguments to find a CourseTopic
     * @example
     * // Get one CourseTopic
     * const courseTopic = await prisma.courseTopic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseTopicFindFirstArgs>(args?: SelectSubset<T, CourseTopicFindFirstArgs<ExtArgs>>): Prisma__CourseTopicClient<$Result.GetResult<Prisma.$CourseTopicPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CourseTopic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTopicFindFirstOrThrowArgs} args - Arguments to find a CourseTopic
     * @example
     * // Get one CourseTopic
     * const courseTopic = await prisma.courseTopic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseTopicFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseTopicFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseTopicClient<$Result.GetResult<Prisma.$CourseTopicPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CourseTopics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTopicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseTopics
     * const courseTopics = await prisma.courseTopic.findMany()
     * 
     * // Get first 10 CourseTopics
     * const courseTopics = await prisma.courseTopic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseTopicWithIdOnly = await prisma.courseTopic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseTopicFindManyArgs>(args?: SelectSubset<T, CourseTopicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseTopicPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CourseTopic.
     * @param {CourseTopicCreateArgs} args - Arguments to create a CourseTopic.
     * @example
     * // Create one CourseTopic
     * const CourseTopic = await prisma.courseTopic.create({
     *   data: {
     *     // ... data to create a CourseTopic
     *   }
     * })
     * 
     */
    create<T extends CourseTopicCreateArgs>(args: SelectSubset<T, CourseTopicCreateArgs<ExtArgs>>): Prisma__CourseTopicClient<$Result.GetResult<Prisma.$CourseTopicPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CourseTopics.
     * @param {CourseTopicCreateManyArgs} args - Arguments to create many CourseTopics.
     * @example
     * // Create many CourseTopics
     * const courseTopic = await prisma.courseTopic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseTopicCreateManyArgs>(args?: SelectSubset<T, CourseTopicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CourseTopic.
     * @param {CourseTopicDeleteArgs} args - Arguments to delete one CourseTopic.
     * @example
     * // Delete one CourseTopic
     * const CourseTopic = await prisma.courseTopic.delete({
     *   where: {
     *     // ... filter to delete one CourseTopic
     *   }
     * })
     * 
     */
    delete<T extends CourseTopicDeleteArgs>(args: SelectSubset<T, CourseTopicDeleteArgs<ExtArgs>>): Prisma__CourseTopicClient<$Result.GetResult<Prisma.$CourseTopicPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CourseTopic.
     * @param {CourseTopicUpdateArgs} args - Arguments to update one CourseTopic.
     * @example
     * // Update one CourseTopic
     * const courseTopic = await prisma.courseTopic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseTopicUpdateArgs>(args: SelectSubset<T, CourseTopicUpdateArgs<ExtArgs>>): Prisma__CourseTopicClient<$Result.GetResult<Prisma.$CourseTopicPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CourseTopics.
     * @param {CourseTopicDeleteManyArgs} args - Arguments to filter CourseTopics to delete.
     * @example
     * // Delete a few CourseTopics
     * const { count } = await prisma.courseTopic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseTopicDeleteManyArgs>(args?: SelectSubset<T, CourseTopicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTopicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseTopics
     * const courseTopic = await prisma.courseTopic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseTopicUpdateManyArgs>(args: SelectSubset<T, CourseTopicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CourseTopic.
     * @param {CourseTopicUpsertArgs} args - Arguments to update or create a CourseTopic.
     * @example
     * // Update or create a CourseTopic
     * const courseTopic = await prisma.courseTopic.upsert({
     *   create: {
     *     // ... data to create a CourseTopic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseTopic we want to update
     *   }
     * })
     */
    upsert<T extends CourseTopicUpsertArgs>(args: SelectSubset<T, CourseTopicUpsertArgs<ExtArgs>>): Prisma__CourseTopicClient<$Result.GetResult<Prisma.$CourseTopicPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CourseTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTopicCountArgs} args - Arguments to filter CourseTopics to count.
     * @example
     * // Count the number of CourseTopics
     * const count = await prisma.courseTopic.count({
     *   where: {
     *     // ... the filter for the CourseTopics we want to count
     *   }
     * })
    **/
    count<T extends CourseTopicCountArgs>(
      args?: Subset<T, CourseTopicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseTopicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseTopic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTopicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseTopicAggregateArgs>(args: Subset<T, CourseTopicAggregateArgs>): Prisma.PrismaPromise<GetCourseTopicAggregateType<T>>

    /**
     * Group by CourseTopic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTopicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseTopicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseTopicGroupByArgs['orderBy'] }
        : { orderBy?: CourseTopicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseTopicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseTopicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseTopic model
   */
  readonly fields: CourseTopicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseTopic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseTopicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Topic<T extends TopicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TopicDefaultArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseTopic model
   */ 
  interface CourseTopicFieldRefs {
    readonly id: FieldRef<"CourseTopic", 'Int'>
    readonly courseId: FieldRef<"CourseTopic", 'Int'>
    readonly topicId: FieldRef<"CourseTopic", 'Int'>
    readonly createdAt: FieldRef<"CourseTopic", 'DateTime'>
    readonly updatedAt: FieldRef<"CourseTopic", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CourseTopic findUnique
   */
  export type CourseTopicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTopic
     */
    select?: CourseTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTopicInclude<ExtArgs> | null
    /**
     * Filter, which CourseTopic to fetch.
     */
    where: CourseTopicWhereUniqueInput
  }

  /**
   * CourseTopic findUniqueOrThrow
   */
  export type CourseTopicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTopic
     */
    select?: CourseTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTopicInclude<ExtArgs> | null
    /**
     * Filter, which CourseTopic to fetch.
     */
    where: CourseTopicWhereUniqueInput
  }

  /**
   * CourseTopic findFirst
   */
  export type CourseTopicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTopic
     */
    select?: CourseTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTopicInclude<ExtArgs> | null
    /**
     * Filter, which CourseTopic to fetch.
     */
    where?: CourseTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseTopics to fetch.
     */
    orderBy?: CourseTopicOrderByWithRelationInput | CourseTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseTopics.
     */
    cursor?: CourseTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseTopics.
     */
    distinct?: CourseTopicScalarFieldEnum | CourseTopicScalarFieldEnum[]
  }

  /**
   * CourseTopic findFirstOrThrow
   */
  export type CourseTopicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTopic
     */
    select?: CourseTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTopicInclude<ExtArgs> | null
    /**
     * Filter, which CourseTopic to fetch.
     */
    where?: CourseTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseTopics to fetch.
     */
    orderBy?: CourseTopicOrderByWithRelationInput | CourseTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseTopics.
     */
    cursor?: CourseTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseTopics.
     */
    distinct?: CourseTopicScalarFieldEnum | CourseTopicScalarFieldEnum[]
  }

  /**
   * CourseTopic findMany
   */
  export type CourseTopicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTopic
     */
    select?: CourseTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTopicInclude<ExtArgs> | null
    /**
     * Filter, which CourseTopics to fetch.
     */
    where?: CourseTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseTopics to fetch.
     */
    orderBy?: CourseTopicOrderByWithRelationInput | CourseTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseTopics.
     */
    cursor?: CourseTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseTopics.
     */
    skip?: number
    distinct?: CourseTopicScalarFieldEnum | CourseTopicScalarFieldEnum[]
  }

  /**
   * CourseTopic create
   */
  export type CourseTopicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTopic
     */
    select?: CourseTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTopicInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseTopic.
     */
    data: XOR<CourseTopicCreateInput, CourseTopicUncheckedCreateInput>
  }

  /**
   * CourseTopic createMany
   */
  export type CourseTopicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseTopics.
     */
    data: CourseTopicCreateManyInput | CourseTopicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseTopic update
   */
  export type CourseTopicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTopic
     */
    select?: CourseTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTopicInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseTopic.
     */
    data: XOR<CourseTopicUpdateInput, CourseTopicUncheckedUpdateInput>
    /**
     * Choose, which CourseTopic to update.
     */
    where: CourseTopicWhereUniqueInput
  }

  /**
   * CourseTopic updateMany
   */
  export type CourseTopicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseTopics.
     */
    data: XOR<CourseTopicUpdateManyMutationInput, CourseTopicUncheckedUpdateManyInput>
    /**
     * Filter which CourseTopics to update
     */
    where?: CourseTopicWhereInput
  }

  /**
   * CourseTopic upsert
   */
  export type CourseTopicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTopic
     */
    select?: CourseTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTopicInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseTopic to update in case it exists.
     */
    where: CourseTopicWhereUniqueInput
    /**
     * In case the CourseTopic found by the `where` argument doesn't exist, create a new CourseTopic with this data.
     */
    create: XOR<CourseTopicCreateInput, CourseTopicUncheckedCreateInput>
    /**
     * In case the CourseTopic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseTopicUpdateInput, CourseTopicUncheckedUpdateInput>
  }

  /**
   * CourseTopic delete
   */
  export type CourseTopicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTopic
     */
    select?: CourseTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTopicInclude<ExtArgs> | null
    /**
     * Filter which CourseTopic to delete.
     */
    where: CourseTopicWhereUniqueInput
  }

  /**
   * CourseTopic deleteMany
   */
  export type CourseTopicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseTopics to delete
     */
    where?: CourseTopicWhereInput
  }

  /**
   * CourseTopic without action
   */
  export type CourseTopicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTopic
     */
    select?: CourseTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTopicInclude<ExtArgs> | null
  }


  /**
   * Model Syllabus
   */

  export type AggregateSyllabus = {
    _count: SyllabusCountAggregateOutputType | null
    _avg: SyllabusAvgAggregateOutputType | null
    _sum: SyllabusSumAggregateOutputType | null
    _min: SyllabusMinAggregateOutputType | null
    _max: SyllabusMaxAggregateOutputType | null
  }

  export type SyllabusAvgAggregateOutputType = {
    id: number | null
    courseId: number | null
  }

  export type SyllabusSumAggregateOutputType = {
    id: number | null
    courseId: number | null
  }

  export type SyllabusMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    courseId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SyllabusMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    courseId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SyllabusCountAggregateOutputType = {
    id: number
    title: number
    description: number
    courseId: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SyllabusAvgAggregateInputType = {
    id?: true
    courseId?: true
  }

  export type SyllabusSumAggregateInputType = {
    id?: true
    courseId?: true
  }

  export type SyllabusMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    courseId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SyllabusMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    courseId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SyllabusCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    courseId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SyllabusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Syllabus to aggregate.
     */
    where?: SyllabusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Syllabi to fetch.
     */
    orderBy?: SyllabusOrderByWithRelationInput | SyllabusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SyllabusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Syllabi from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Syllabi.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Syllabi
    **/
    _count?: true | SyllabusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SyllabusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SyllabusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SyllabusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SyllabusMaxAggregateInputType
  }

  export type GetSyllabusAggregateType<T extends SyllabusAggregateArgs> = {
        [P in keyof T & keyof AggregateSyllabus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSyllabus[P]>
      : GetScalarType<T[P], AggregateSyllabus[P]>
  }




  export type SyllabusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyllabusWhereInput
    orderBy?: SyllabusOrderByWithAggregationInput | SyllabusOrderByWithAggregationInput[]
    by: SyllabusScalarFieldEnum[] | SyllabusScalarFieldEnum
    having?: SyllabusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SyllabusCountAggregateInputType | true
    _avg?: SyllabusAvgAggregateInputType
    _sum?: SyllabusSumAggregateInputType
    _min?: SyllabusMinAggregateInputType
    _max?: SyllabusMaxAggregateInputType
  }

  export type SyllabusGroupByOutputType = {
    id: number
    title: string
    description: string
    courseId: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: SyllabusCountAggregateOutputType | null
    _avg: SyllabusAvgAggregateOutputType | null
    _sum: SyllabusSumAggregateOutputType | null
    _min: SyllabusMinAggregateOutputType | null
    _max: SyllabusMaxAggregateOutputType | null
  }

  type GetSyllabusGroupByPayload<T extends SyllabusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SyllabusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SyllabusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SyllabusGroupByOutputType[P]>
            : GetScalarType<T[P], SyllabusGroupByOutputType[P]>
        }
      >
    >


  export type SyllabusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    courseId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Course?: boolean | CourseDefaultArgs<ExtArgs>
    SyllabusContent?: boolean | Syllabus$SyllabusContentArgs<ExtArgs>
    _count?: boolean | SyllabusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["syllabus"]>


  export type SyllabusSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    courseId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SyllabusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Course?: boolean | CourseDefaultArgs<ExtArgs>
    SyllabusContent?: boolean | Syllabus$SyllabusContentArgs<ExtArgs>
    _count?: boolean | SyllabusCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SyllabusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Syllabus"
    objects: {
      Course: Prisma.$CoursePayload<ExtArgs>
      SyllabusContent: Prisma.$SyllabusContentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string
      courseId: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["syllabus"]>
    composites: {}
  }

  type SyllabusGetPayload<S extends boolean | null | undefined | SyllabusDefaultArgs> = $Result.GetResult<Prisma.$SyllabusPayload, S>

  type SyllabusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SyllabusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SyllabusCountAggregateInputType | true
    }

  export interface SyllabusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Syllabus'], meta: { name: 'Syllabus' } }
    /**
     * Find zero or one Syllabus that matches the filter.
     * @param {SyllabusFindUniqueArgs} args - Arguments to find a Syllabus
     * @example
     * // Get one Syllabus
     * const syllabus = await prisma.syllabus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SyllabusFindUniqueArgs>(args: SelectSubset<T, SyllabusFindUniqueArgs<ExtArgs>>): Prisma__SyllabusClient<$Result.GetResult<Prisma.$SyllabusPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Syllabus that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SyllabusFindUniqueOrThrowArgs} args - Arguments to find a Syllabus
     * @example
     * // Get one Syllabus
     * const syllabus = await prisma.syllabus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SyllabusFindUniqueOrThrowArgs>(args: SelectSubset<T, SyllabusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SyllabusClient<$Result.GetResult<Prisma.$SyllabusPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Syllabus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusFindFirstArgs} args - Arguments to find a Syllabus
     * @example
     * // Get one Syllabus
     * const syllabus = await prisma.syllabus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SyllabusFindFirstArgs>(args?: SelectSubset<T, SyllabusFindFirstArgs<ExtArgs>>): Prisma__SyllabusClient<$Result.GetResult<Prisma.$SyllabusPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Syllabus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusFindFirstOrThrowArgs} args - Arguments to find a Syllabus
     * @example
     * // Get one Syllabus
     * const syllabus = await prisma.syllabus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SyllabusFindFirstOrThrowArgs>(args?: SelectSubset<T, SyllabusFindFirstOrThrowArgs<ExtArgs>>): Prisma__SyllabusClient<$Result.GetResult<Prisma.$SyllabusPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Syllabi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Syllabi
     * const syllabi = await prisma.syllabus.findMany()
     * 
     * // Get first 10 Syllabi
     * const syllabi = await prisma.syllabus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const syllabusWithIdOnly = await prisma.syllabus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SyllabusFindManyArgs>(args?: SelectSubset<T, SyllabusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyllabusPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Syllabus.
     * @param {SyllabusCreateArgs} args - Arguments to create a Syllabus.
     * @example
     * // Create one Syllabus
     * const Syllabus = await prisma.syllabus.create({
     *   data: {
     *     // ... data to create a Syllabus
     *   }
     * })
     * 
     */
    create<T extends SyllabusCreateArgs>(args: SelectSubset<T, SyllabusCreateArgs<ExtArgs>>): Prisma__SyllabusClient<$Result.GetResult<Prisma.$SyllabusPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Syllabi.
     * @param {SyllabusCreateManyArgs} args - Arguments to create many Syllabi.
     * @example
     * // Create many Syllabi
     * const syllabus = await prisma.syllabus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SyllabusCreateManyArgs>(args?: SelectSubset<T, SyllabusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Syllabus.
     * @param {SyllabusDeleteArgs} args - Arguments to delete one Syllabus.
     * @example
     * // Delete one Syllabus
     * const Syllabus = await prisma.syllabus.delete({
     *   where: {
     *     // ... filter to delete one Syllabus
     *   }
     * })
     * 
     */
    delete<T extends SyllabusDeleteArgs>(args: SelectSubset<T, SyllabusDeleteArgs<ExtArgs>>): Prisma__SyllabusClient<$Result.GetResult<Prisma.$SyllabusPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Syllabus.
     * @param {SyllabusUpdateArgs} args - Arguments to update one Syllabus.
     * @example
     * // Update one Syllabus
     * const syllabus = await prisma.syllabus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SyllabusUpdateArgs>(args: SelectSubset<T, SyllabusUpdateArgs<ExtArgs>>): Prisma__SyllabusClient<$Result.GetResult<Prisma.$SyllabusPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Syllabi.
     * @param {SyllabusDeleteManyArgs} args - Arguments to filter Syllabi to delete.
     * @example
     * // Delete a few Syllabi
     * const { count } = await prisma.syllabus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SyllabusDeleteManyArgs>(args?: SelectSubset<T, SyllabusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Syllabi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Syllabi
     * const syllabus = await prisma.syllabus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SyllabusUpdateManyArgs>(args: SelectSubset<T, SyllabusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Syllabus.
     * @param {SyllabusUpsertArgs} args - Arguments to update or create a Syllabus.
     * @example
     * // Update or create a Syllabus
     * const syllabus = await prisma.syllabus.upsert({
     *   create: {
     *     // ... data to create a Syllabus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Syllabus we want to update
     *   }
     * })
     */
    upsert<T extends SyllabusUpsertArgs>(args: SelectSubset<T, SyllabusUpsertArgs<ExtArgs>>): Prisma__SyllabusClient<$Result.GetResult<Prisma.$SyllabusPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Syllabi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusCountArgs} args - Arguments to filter Syllabi to count.
     * @example
     * // Count the number of Syllabi
     * const count = await prisma.syllabus.count({
     *   where: {
     *     // ... the filter for the Syllabi we want to count
     *   }
     * })
    **/
    count<T extends SyllabusCountArgs>(
      args?: Subset<T, SyllabusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SyllabusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Syllabus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SyllabusAggregateArgs>(args: Subset<T, SyllabusAggregateArgs>): Prisma.PrismaPromise<GetSyllabusAggregateType<T>>

    /**
     * Group by Syllabus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SyllabusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SyllabusGroupByArgs['orderBy'] }
        : { orderBy?: SyllabusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SyllabusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSyllabusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Syllabus model
   */
  readonly fields: SyllabusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Syllabus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SyllabusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    SyllabusContent<T extends Syllabus$SyllabusContentArgs<ExtArgs> = {}>(args?: Subset<T, Syllabus$SyllabusContentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyllabusContentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Syllabus model
   */ 
  interface SyllabusFieldRefs {
    readonly id: FieldRef<"Syllabus", 'Int'>
    readonly title: FieldRef<"Syllabus", 'String'>
    readonly description: FieldRef<"Syllabus", 'String'>
    readonly courseId: FieldRef<"Syllabus", 'Int'>
    readonly isActive: FieldRef<"Syllabus", 'Boolean'>
    readonly createdAt: FieldRef<"Syllabus", 'DateTime'>
    readonly updatedAt: FieldRef<"Syllabus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Syllabus findUnique
   */
  export type SyllabusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syllabus
     */
    select?: SyllabusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusInclude<ExtArgs> | null
    /**
     * Filter, which Syllabus to fetch.
     */
    where: SyllabusWhereUniqueInput
  }

  /**
   * Syllabus findUniqueOrThrow
   */
  export type SyllabusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syllabus
     */
    select?: SyllabusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusInclude<ExtArgs> | null
    /**
     * Filter, which Syllabus to fetch.
     */
    where: SyllabusWhereUniqueInput
  }

  /**
   * Syllabus findFirst
   */
  export type SyllabusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syllabus
     */
    select?: SyllabusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusInclude<ExtArgs> | null
    /**
     * Filter, which Syllabus to fetch.
     */
    where?: SyllabusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Syllabi to fetch.
     */
    orderBy?: SyllabusOrderByWithRelationInput | SyllabusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Syllabi.
     */
    cursor?: SyllabusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Syllabi from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Syllabi.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Syllabi.
     */
    distinct?: SyllabusScalarFieldEnum | SyllabusScalarFieldEnum[]
  }

  /**
   * Syllabus findFirstOrThrow
   */
  export type SyllabusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syllabus
     */
    select?: SyllabusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusInclude<ExtArgs> | null
    /**
     * Filter, which Syllabus to fetch.
     */
    where?: SyllabusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Syllabi to fetch.
     */
    orderBy?: SyllabusOrderByWithRelationInput | SyllabusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Syllabi.
     */
    cursor?: SyllabusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Syllabi from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Syllabi.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Syllabi.
     */
    distinct?: SyllabusScalarFieldEnum | SyllabusScalarFieldEnum[]
  }

  /**
   * Syllabus findMany
   */
  export type SyllabusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syllabus
     */
    select?: SyllabusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusInclude<ExtArgs> | null
    /**
     * Filter, which Syllabi to fetch.
     */
    where?: SyllabusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Syllabi to fetch.
     */
    orderBy?: SyllabusOrderByWithRelationInput | SyllabusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Syllabi.
     */
    cursor?: SyllabusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Syllabi from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Syllabi.
     */
    skip?: number
    distinct?: SyllabusScalarFieldEnum | SyllabusScalarFieldEnum[]
  }

  /**
   * Syllabus create
   */
  export type SyllabusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syllabus
     */
    select?: SyllabusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusInclude<ExtArgs> | null
    /**
     * The data needed to create a Syllabus.
     */
    data: XOR<SyllabusCreateInput, SyllabusUncheckedCreateInput>
  }

  /**
   * Syllabus createMany
   */
  export type SyllabusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Syllabi.
     */
    data: SyllabusCreateManyInput | SyllabusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Syllabus update
   */
  export type SyllabusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syllabus
     */
    select?: SyllabusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusInclude<ExtArgs> | null
    /**
     * The data needed to update a Syllabus.
     */
    data: XOR<SyllabusUpdateInput, SyllabusUncheckedUpdateInput>
    /**
     * Choose, which Syllabus to update.
     */
    where: SyllabusWhereUniqueInput
  }

  /**
   * Syllabus updateMany
   */
  export type SyllabusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Syllabi.
     */
    data: XOR<SyllabusUpdateManyMutationInput, SyllabusUncheckedUpdateManyInput>
    /**
     * Filter which Syllabi to update
     */
    where?: SyllabusWhereInput
  }

  /**
   * Syllabus upsert
   */
  export type SyllabusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syllabus
     */
    select?: SyllabusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusInclude<ExtArgs> | null
    /**
     * The filter to search for the Syllabus to update in case it exists.
     */
    where: SyllabusWhereUniqueInput
    /**
     * In case the Syllabus found by the `where` argument doesn't exist, create a new Syllabus with this data.
     */
    create: XOR<SyllabusCreateInput, SyllabusUncheckedCreateInput>
    /**
     * In case the Syllabus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SyllabusUpdateInput, SyllabusUncheckedUpdateInput>
  }

  /**
   * Syllabus delete
   */
  export type SyllabusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syllabus
     */
    select?: SyllabusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusInclude<ExtArgs> | null
    /**
     * Filter which Syllabus to delete.
     */
    where: SyllabusWhereUniqueInput
  }

  /**
   * Syllabus deleteMany
   */
  export type SyllabusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Syllabi to delete
     */
    where?: SyllabusWhereInput
  }

  /**
   * Syllabus.SyllabusContent
   */
  export type Syllabus$SyllabusContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusContent
     */
    select?: SyllabusContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusContentInclude<ExtArgs> | null
    where?: SyllabusContentWhereInput
    orderBy?: SyllabusContentOrderByWithRelationInput | SyllabusContentOrderByWithRelationInput[]
    cursor?: SyllabusContentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SyllabusContentScalarFieldEnum | SyllabusContentScalarFieldEnum[]
  }

  /**
   * Syllabus without action
   */
  export type SyllabusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syllabus
     */
    select?: SyllabusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusInclude<ExtArgs> | null
  }


  /**
   * Model SyllabusContent
   */

  export type AggregateSyllabusContent = {
    _count: SyllabusContentCountAggregateOutputType | null
    _avg: SyllabusContentAvgAggregateOutputType | null
    _sum: SyllabusContentSumAggregateOutputType | null
    _min: SyllabusContentMinAggregateOutputType | null
    _max: SyllabusContentMaxAggregateOutputType | null
  }

  export type SyllabusContentAvgAggregateOutputType = {
    id: number | null
    syllabusId: number | null
    order: number | null
  }

  export type SyllabusContentSumAggregateOutputType = {
    id: number | null
    syllabusId: number | null
    order: number | null
  }

  export type SyllabusContentMinAggregateOutputType = {
    id: number | null
    syllabusId: number | null
    title: string | null
    type: $Enums.SyllabusContentType | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
    slug: string | null
  }

  export type SyllabusContentMaxAggregateOutputType = {
    id: number | null
    syllabusId: number | null
    title: string | null
    type: $Enums.SyllabusContentType | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
    slug: string | null
  }

  export type SyllabusContentCountAggregateOutputType = {
    id: number
    syllabusId: number
    title: number
    type: number
    order: number
    createdAt: number
    updatedAt: number
    slug: number
    _all: number
  }


  export type SyllabusContentAvgAggregateInputType = {
    id?: true
    syllabusId?: true
    order?: true
  }

  export type SyllabusContentSumAggregateInputType = {
    id?: true
    syllabusId?: true
    order?: true
  }

  export type SyllabusContentMinAggregateInputType = {
    id?: true
    syllabusId?: true
    title?: true
    type?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    slug?: true
  }

  export type SyllabusContentMaxAggregateInputType = {
    id?: true
    syllabusId?: true
    title?: true
    type?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    slug?: true
  }

  export type SyllabusContentCountAggregateInputType = {
    id?: true
    syllabusId?: true
    title?: true
    type?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    slug?: true
    _all?: true
  }

  export type SyllabusContentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyllabusContent to aggregate.
     */
    where?: SyllabusContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyllabusContents to fetch.
     */
    orderBy?: SyllabusContentOrderByWithRelationInput | SyllabusContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SyllabusContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyllabusContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyllabusContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SyllabusContents
    **/
    _count?: true | SyllabusContentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SyllabusContentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SyllabusContentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SyllabusContentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SyllabusContentMaxAggregateInputType
  }

  export type GetSyllabusContentAggregateType<T extends SyllabusContentAggregateArgs> = {
        [P in keyof T & keyof AggregateSyllabusContent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSyllabusContent[P]>
      : GetScalarType<T[P], AggregateSyllabusContent[P]>
  }




  export type SyllabusContentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyllabusContentWhereInput
    orderBy?: SyllabusContentOrderByWithAggregationInput | SyllabusContentOrderByWithAggregationInput[]
    by: SyllabusContentScalarFieldEnum[] | SyllabusContentScalarFieldEnum
    having?: SyllabusContentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SyllabusContentCountAggregateInputType | true
    _avg?: SyllabusContentAvgAggregateInputType
    _sum?: SyllabusContentSumAggregateInputType
    _min?: SyllabusContentMinAggregateInputType
    _max?: SyllabusContentMaxAggregateInputType
  }

  export type SyllabusContentGroupByOutputType = {
    id: number
    syllabusId: number
    title: string
    type: $Enums.SyllabusContentType
    order: number
    createdAt: Date
    updatedAt: Date
    slug: string
    _count: SyllabusContentCountAggregateOutputType | null
    _avg: SyllabusContentAvgAggregateOutputType | null
    _sum: SyllabusContentSumAggregateOutputType | null
    _min: SyllabusContentMinAggregateOutputType | null
    _max: SyllabusContentMaxAggregateOutputType | null
  }

  type GetSyllabusContentGroupByPayload<T extends SyllabusContentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SyllabusContentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SyllabusContentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SyllabusContentGroupByOutputType[P]>
            : GetScalarType<T[P], SyllabusContentGroupByOutputType[P]>
        }
      >
    >


  export type SyllabusContentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    syllabusId?: boolean
    title?: boolean
    type?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    slug?: boolean
    Exams?: boolean | SyllabusContent$ExamsArgs<ExtArgs>
    MaterialContents?: boolean | SyllabusContent$MaterialContentsArgs<ExtArgs>
    Syllabus?: boolean | SyllabusDefaultArgs<ExtArgs>
    CourseLogging?: boolean | SyllabusContent$CourseLoggingArgs<ExtArgs>
    _count?: boolean | SyllabusContentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["syllabusContent"]>


  export type SyllabusContentSelectScalar = {
    id?: boolean
    syllabusId?: boolean
    title?: boolean
    type?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    slug?: boolean
  }

  export type SyllabusContentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Exams?: boolean | SyllabusContent$ExamsArgs<ExtArgs>
    MaterialContents?: boolean | SyllabusContent$MaterialContentsArgs<ExtArgs>
    Syllabus?: boolean | SyllabusDefaultArgs<ExtArgs>
    CourseLogging?: boolean | SyllabusContent$CourseLoggingArgs<ExtArgs>
    _count?: boolean | SyllabusContentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SyllabusContentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SyllabusContent"
    objects: {
      Exams: Prisma.$ExamPayload<ExtArgs>[]
      MaterialContents: Prisma.$MaterialContentPayload<ExtArgs>[]
      Syllabus: Prisma.$SyllabusPayload<ExtArgs>
      CourseLogging: Prisma.$CourseLoggingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      syllabusId: number
      title: string
      type: $Enums.SyllabusContentType
      order: number
      createdAt: Date
      updatedAt: Date
      slug: string
    }, ExtArgs["result"]["syllabusContent"]>
    composites: {}
  }

  type SyllabusContentGetPayload<S extends boolean | null | undefined | SyllabusContentDefaultArgs> = $Result.GetResult<Prisma.$SyllabusContentPayload, S>

  type SyllabusContentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SyllabusContentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SyllabusContentCountAggregateInputType | true
    }

  export interface SyllabusContentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SyllabusContent'], meta: { name: 'SyllabusContent' } }
    /**
     * Find zero or one SyllabusContent that matches the filter.
     * @param {SyllabusContentFindUniqueArgs} args - Arguments to find a SyllabusContent
     * @example
     * // Get one SyllabusContent
     * const syllabusContent = await prisma.syllabusContent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SyllabusContentFindUniqueArgs>(args: SelectSubset<T, SyllabusContentFindUniqueArgs<ExtArgs>>): Prisma__SyllabusContentClient<$Result.GetResult<Prisma.$SyllabusContentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SyllabusContent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SyllabusContentFindUniqueOrThrowArgs} args - Arguments to find a SyllabusContent
     * @example
     * // Get one SyllabusContent
     * const syllabusContent = await prisma.syllabusContent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SyllabusContentFindUniqueOrThrowArgs>(args: SelectSubset<T, SyllabusContentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SyllabusContentClient<$Result.GetResult<Prisma.$SyllabusContentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SyllabusContent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusContentFindFirstArgs} args - Arguments to find a SyllabusContent
     * @example
     * // Get one SyllabusContent
     * const syllabusContent = await prisma.syllabusContent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SyllabusContentFindFirstArgs>(args?: SelectSubset<T, SyllabusContentFindFirstArgs<ExtArgs>>): Prisma__SyllabusContentClient<$Result.GetResult<Prisma.$SyllabusContentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SyllabusContent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusContentFindFirstOrThrowArgs} args - Arguments to find a SyllabusContent
     * @example
     * // Get one SyllabusContent
     * const syllabusContent = await prisma.syllabusContent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SyllabusContentFindFirstOrThrowArgs>(args?: SelectSubset<T, SyllabusContentFindFirstOrThrowArgs<ExtArgs>>): Prisma__SyllabusContentClient<$Result.GetResult<Prisma.$SyllabusContentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SyllabusContents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusContentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SyllabusContents
     * const syllabusContents = await prisma.syllabusContent.findMany()
     * 
     * // Get first 10 SyllabusContents
     * const syllabusContents = await prisma.syllabusContent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const syllabusContentWithIdOnly = await prisma.syllabusContent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SyllabusContentFindManyArgs>(args?: SelectSubset<T, SyllabusContentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyllabusContentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SyllabusContent.
     * @param {SyllabusContentCreateArgs} args - Arguments to create a SyllabusContent.
     * @example
     * // Create one SyllabusContent
     * const SyllabusContent = await prisma.syllabusContent.create({
     *   data: {
     *     // ... data to create a SyllabusContent
     *   }
     * })
     * 
     */
    create<T extends SyllabusContentCreateArgs>(args: SelectSubset<T, SyllabusContentCreateArgs<ExtArgs>>): Prisma__SyllabusContentClient<$Result.GetResult<Prisma.$SyllabusContentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SyllabusContents.
     * @param {SyllabusContentCreateManyArgs} args - Arguments to create many SyllabusContents.
     * @example
     * // Create many SyllabusContents
     * const syllabusContent = await prisma.syllabusContent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SyllabusContentCreateManyArgs>(args?: SelectSubset<T, SyllabusContentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SyllabusContent.
     * @param {SyllabusContentDeleteArgs} args - Arguments to delete one SyllabusContent.
     * @example
     * // Delete one SyllabusContent
     * const SyllabusContent = await prisma.syllabusContent.delete({
     *   where: {
     *     // ... filter to delete one SyllabusContent
     *   }
     * })
     * 
     */
    delete<T extends SyllabusContentDeleteArgs>(args: SelectSubset<T, SyllabusContentDeleteArgs<ExtArgs>>): Prisma__SyllabusContentClient<$Result.GetResult<Prisma.$SyllabusContentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SyllabusContent.
     * @param {SyllabusContentUpdateArgs} args - Arguments to update one SyllabusContent.
     * @example
     * // Update one SyllabusContent
     * const syllabusContent = await prisma.syllabusContent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SyllabusContentUpdateArgs>(args: SelectSubset<T, SyllabusContentUpdateArgs<ExtArgs>>): Prisma__SyllabusContentClient<$Result.GetResult<Prisma.$SyllabusContentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SyllabusContents.
     * @param {SyllabusContentDeleteManyArgs} args - Arguments to filter SyllabusContents to delete.
     * @example
     * // Delete a few SyllabusContents
     * const { count } = await prisma.syllabusContent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SyllabusContentDeleteManyArgs>(args?: SelectSubset<T, SyllabusContentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyllabusContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusContentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SyllabusContents
     * const syllabusContent = await prisma.syllabusContent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SyllabusContentUpdateManyArgs>(args: SelectSubset<T, SyllabusContentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SyllabusContent.
     * @param {SyllabusContentUpsertArgs} args - Arguments to update or create a SyllabusContent.
     * @example
     * // Update or create a SyllabusContent
     * const syllabusContent = await prisma.syllabusContent.upsert({
     *   create: {
     *     // ... data to create a SyllabusContent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SyllabusContent we want to update
     *   }
     * })
     */
    upsert<T extends SyllabusContentUpsertArgs>(args: SelectSubset<T, SyllabusContentUpsertArgs<ExtArgs>>): Prisma__SyllabusContentClient<$Result.GetResult<Prisma.$SyllabusContentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SyllabusContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusContentCountArgs} args - Arguments to filter SyllabusContents to count.
     * @example
     * // Count the number of SyllabusContents
     * const count = await prisma.syllabusContent.count({
     *   where: {
     *     // ... the filter for the SyllabusContents we want to count
     *   }
     * })
    **/
    count<T extends SyllabusContentCountArgs>(
      args?: Subset<T, SyllabusContentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SyllabusContentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SyllabusContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusContentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SyllabusContentAggregateArgs>(args: Subset<T, SyllabusContentAggregateArgs>): Prisma.PrismaPromise<GetSyllabusContentAggregateType<T>>

    /**
     * Group by SyllabusContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusContentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SyllabusContentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SyllabusContentGroupByArgs['orderBy'] }
        : { orderBy?: SyllabusContentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SyllabusContentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSyllabusContentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SyllabusContent model
   */
  readonly fields: SyllabusContentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SyllabusContent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SyllabusContentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Exams<T extends SyllabusContent$ExamsArgs<ExtArgs> = {}>(args?: Subset<T, SyllabusContent$ExamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany"> | Null>
    MaterialContents<T extends SyllabusContent$MaterialContentsArgs<ExtArgs> = {}>(args?: Subset<T, SyllabusContent$MaterialContentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialContentPayload<ExtArgs>, T, "findMany"> | Null>
    Syllabus<T extends SyllabusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SyllabusDefaultArgs<ExtArgs>>): Prisma__SyllabusClient<$Result.GetResult<Prisma.$SyllabusPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    CourseLogging<T extends SyllabusContent$CourseLoggingArgs<ExtArgs> = {}>(args?: Subset<T, SyllabusContent$CourseLoggingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseLoggingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SyllabusContent model
   */ 
  interface SyllabusContentFieldRefs {
    readonly id: FieldRef<"SyllabusContent", 'Int'>
    readonly syllabusId: FieldRef<"SyllabusContent", 'Int'>
    readonly title: FieldRef<"SyllabusContent", 'String'>
    readonly type: FieldRef<"SyllabusContent", 'SyllabusContentType'>
    readonly order: FieldRef<"SyllabusContent", 'Int'>
    readonly createdAt: FieldRef<"SyllabusContent", 'DateTime'>
    readonly updatedAt: FieldRef<"SyllabusContent", 'DateTime'>
    readonly slug: FieldRef<"SyllabusContent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SyllabusContent findUnique
   */
  export type SyllabusContentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusContent
     */
    select?: SyllabusContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusContentInclude<ExtArgs> | null
    /**
     * Filter, which SyllabusContent to fetch.
     */
    where: SyllabusContentWhereUniqueInput
  }

  /**
   * SyllabusContent findUniqueOrThrow
   */
  export type SyllabusContentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusContent
     */
    select?: SyllabusContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusContentInclude<ExtArgs> | null
    /**
     * Filter, which SyllabusContent to fetch.
     */
    where: SyllabusContentWhereUniqueInput
  }

  /**
   * SyllabusContent findFirst
   */
  export type SyllabusContentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusContent
     */
    select?: SyllabusContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusContentInclude<ExtArgs> | null
    /**
     * Filter, which SyllabusContent to fetch.
     */
    where?: SyllabusContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyllabusContents to fetch.
     */
    orderBy?: SyllabusContentOrderByWithRelationInput | SyllabusContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyllabusContents.
     */
    cursor?: SyllabusContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyllabusContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyllabusContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyllabusContents.
     */
    distinct?: SyllabusContentScalarFieldEnum | SyllabusContentScalarFieldEnum[]
  }

  /**
   * SyllabusContent findFirstOrThrow
   */
  export type SyllabusContentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusContent
     */
    select?: SyllabusContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusContentInclude<ExtArgs> | null
    /**
     * Filter, which SyllabusContent to fetch.
     */
    where?: SyllabusContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyllabusContents to fetch.
     */
    orderBy?: SyllabusContentOrderByWithRelationInput | SyllabusContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyllabusContents.
     */
    cursor?: SyllabusContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyllabusContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyllabusContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyllabusContents.
     */
    distinct?: SyllabusContentScalarFieldEnum | SyllabusContentScalarFieldEnum[]
  }

  /**
   * SyllabusContent findMany
   */
  export type SyllabusContentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusContent
     */
    select?: SyllabusContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusContentInclude<ExtArgs> | null
    /**
     * Filter, which SyllabusContents to fetch.
     */
    where?: SyllabusContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyllabusContents to fetch.
     */
    orderBy?: SyllabusContentOrderByWithRelationInput | SyllabusContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SyllabusContents.
     */
    cursor?: SyllabusContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyllabusContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyllabusContents.
     */
    skip?: number
    distinct?: SyllabusContentScalarFieldEnum | SyllabusContentScalarFieldEnum[]
  }

  /**
   * SyllabusContent create
   */
  export type SyllabusContentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusContent
     */
    select?: SyllabusContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusContentInclude<ExtArgs> | null
    /**
     * The data needed to create a SyllabusContent.
     */
    data: XOR<SyllabusContentCreateInput, SyllabusContentUncheckedCreateInput>
  }

  /**
   * SyllabusContent createMany
   */
  export type SyllabusContentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SyllabusContents.
     */
    data: SyllabusContentCreateManyInput | SyllabusContentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SyllabusContent update
   */
  export type SyllabusContentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusContent
     */
    select?: SyllabusContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusContentInclude<ExtArgs> | null
    /**
     * The data needed to update a SyllabusContent.
     */
    data: XOR<SyllabusContentUpdateInput, SyllabusContentUncheckedUpdateInput>
    /**
     * Choose, which SyllabusContent to update.
     */
    where: SyllabusContentWhereUniqueInput
  }

  /**
   * SyllabusContent updateMany
   */
  export type SyllabusContentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SyllabusContents.
     */
    data: XOR<SyllabusContentUpdateManyMutationInput, SyllabusContentUncheckedUpdateManyInput>
    /**
     * Filter which SyllabusContents to update
     */
    where?: SyllabusContentWhereInput
  }

  /**
   * SyllabusContent upsert
   */
  export type SyllabusContentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusContent
     */
    select?: SyllabusContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusContentInclude<ExtArgs> | null
    /**
     * The filter to search for the SyllabusContent to update in case it exists.
     */
    where: SyllabusContentWhereUniqueInput
    /**
     * In case the SyllabusContent found by the `where` argument doesn't exist, create a new SyllabusContent with this data.
     */
    create: XOR<SyllabusContentCreateInput, SyllabusContentUncheckedCreateInput>
    /**
     * In case the SyllabusContent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SyllabusContentUpdateInput, SyllabusContentUncheckedUpdateInput>
  }

  /**
   * SyllabusContent delete
   */
  export type SyllabusContentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusContent
     */
    select?: SyllabusContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusContentInclude<ExtArgs> | null
    /**
     * Filter which SyllabusContent to delete.
     */
    where: SyllabusContentWhereUniqueInput
  }

  /**
   * SyllabusContent deleteMany
   */
  export type SyllabusContentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyllabusContents to delete
     */
    where?: SyllabusContentWhereInput
  }

  /**
   * SyllabusContent.Exams
   */
  export type SyllabusContent$ExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    cursor?: ExamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * SyllabusContent.MaterialContents
   */
  export type SyllabusContent$MaterialContentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContent
     */
    select?: MaterialContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentInclude<ExtArgs> | null
    where?: MaterialContentWhereInput
    orderBy?: MaterialContentOrderByWithRelationInput | MaterialContentOrderByWithRelationInput[]
    cursor?: MaterialContentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialContentScalarFieldEnum | MaterialContentScalarFieldEnum[]
  }

  /**
   * SyllabusContent.CourseLogging
   */
  export type SyllabusContent$CourseLoggingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLogging
     */
    select?: CourseLoggingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLoggingInclude<ExtArgs> | null
    where?: CourseLoggingWhereInput
    orderBy?: CourseLoggingOrderByWithRelationInput | CourseLoggingOrderByWithRelationInput[]
    cursor?: CourseLoggingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseLoggingScalarFieldEnum | CourseLoggingScalarFieldEnum[]
  }

  /**
   * SyllabusContent without action
   */
  export type SyllabusContentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusContent
     */
    select?: SyllabusContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusContentInclude<ExtArgs> | null
  }


  /**
   * Model Exam
   */

  export type AggregateExam = {
    _count: ExamCountAggregateOutputType | null
    _avg: ExamAvgAggregateOutputType | null
    _sum: ExamSumAggregateOutputType | null
    _min: ExamMinAggregateOutputType | null
    _max: ExamMaxAggregateOutputType | null
  }

  export type ExamAvgAggregateOutputType = {
    id: number | null
    syllabusContentId: number | null
  }

  export type ExamSumAggregateOutputType = {
    id: number | null
    syllabusContentId: number | null
  }

  export type ExamMinAggregateOutputType = {
    id: number | null
    title: string | null
    syllabusContentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    description: string | null
  }

  export type ExamMaxAggregateOutputType = {
    id: number | null
    title: string | null
    syllabusContentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    description: string | null
  }

  export type ExamCountAggregateOutputType = {
    id: number
    title: number
    syllabusContentId: number
    createdAt: number
    updatedAt: number
    description: number
    _all: number
  }


  export type ExamAvgAggregateInputType = {
    id?: true
    syllabusContentId?: true
  }

  export type ExamSumAggregateInputType = {
    id?: true
    syllabusContentId?: true
  }

  export type ExamMinAggregateInputType = {
    id?: true
    title?: true
    syllabusContentId?: true
    createdAt?: true
    updatedAt?: true
    description?: true
  }

  export type ExamMaxAggregateInputType = {
    id?: true
    title?: true
    syllabusContentId?: true
    createdAt?: true
    updatedAt?: true
    description?: true
  }

  export type ExamCountAggregateInputType = {
    id?: true
    title?: true
    syllabusContentId?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    _all?: true
  }

  export type ExamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exam to aggregate.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Exams
    **/
    _count?: true | ExamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamMaxAggregateInputType
  }

  export type GetExamAggregateType<T extends ExamAggregateArgs> = {
        [P in keyof T & keyof AggregateExam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExam[P]>
      : GetScalarType<T[P], AggregateExam[P]>
  }




  export type ExamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithAggregationInput | ExamOrderByWithAggregationInput[]
    by: ExamScalarFieldEnum[] | ExamScalarFieldEnum
    having?: ExamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamCountAggregateInputType | true
    _avg?: ExamAvgAggregateInputType
    _sum?: ExamSumAggregateInputType
    _min?: ExamMinAggregateInputType
    _max?: ExamMaxAggregateInputType
  }

  export type ExamGroupByOutputType = {
    id: number
    title: string
    syllabusContentId: number
    createdAt: Date
    updatedAt: Date
    description: string
    _count: ExamCountAggregateOutputType | null
    _avg: ExamAvgAggregateOutputType | null
    _sum: ExamSumAggregateOutputType | null
    _min: ExamMinAggregateOutputType | null
    _max: ExamMaxAggregateOutputType | null
  }

  type GetExamGroupByPayload<T extends ExamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamGroupByOutputType[P]>
            : GetScalarType<T[P], ExamGroupByOutputType[P]>
        }
      >
    >


  export type ExamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    syllabusContentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    SyllabusContent?: boolean | SyllabusContentDefaultArgs<ExtArgs>
    ExamQuestions?: boolean | Exam$ExamQuestionsArgs<ExtArgs>
    CourseLogging?: boolean | Exam$CourseLoggingArgs<ExtArgs>
    _count?: boolean | ExamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exam"]>


  export type ExamSelectScalar = {
    id?: boolean
    title?: boolean
    syllabusContentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
  }

  export type ExamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SyllabusContent?: boolean | SyllabusContentDefaultArgs<ExtArgs>
    ExamQuestions?: boolean | Exam$ExamQuestionsArgs<ExtArgs>
    CourseLogging?: boolean | Exam$CourseLoggingArgs<ExtArgs>
    _count?: boolean | ExamCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ExamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Exam"
    objects: {
      SyllabusContent: Prisma.$SyllabusContentPayload<ExtArgs>
      ExamQuestions: Prisma.$ExamQuestionPayload<ExtArgs>[]
      CourseLogging: Prisma.$CourseLoggingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      syllabusContentId: number
      createdAt: Date
      updatedAt: Date
      description: string
    }, ExtArgs["result"]["exam"]>
    composites: {}
  }

  type ExamGetPayload<S extends boolean | null | undefined | ExamDefaultArgs> = $Result.GetResult<Prisma.$ExamPayload, S>

  type ExamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExamFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExamCountAggregateInputType | true
    }

  export interface ExamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Exam'], meta: { name: 'Exam' } }
    /**
     * Find zero or one Exam that matches the filter.
     * @param {ExamFindUniqueArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamFindUniqueArgs>(args: SelectSubset<T, ExamFindUniqueArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Exam that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExamFindUniqueOrThrowArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Exam that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindFirstArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamFindFirstArgs>(args?: SelectSubset<T, ExamFindFirstArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Exam that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindFirstOrThrowArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Exams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exams
     * const exams = await prisma.exam.findMany()
     * 
     * // Get first 10 Exams
     * const exams = await prisma.exam.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examWithIdOnly = await prisma.exam.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamFindManyArgs>(args?: SelectSubset<T, ExamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Exam.
     * @param {ExamCreateArgs} args - Arguments to create a Exam.
     * @example
     * // Create one Exam
     * const Exam = await prisma.exam.create({
     *   data: {
     *     // ... data to create a Exam
     *   }
     * })
     * 
     */
    create<T extends ExamCreateArgs>(args: SelectSubset<T, ExamCreateArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Exams.
     * @param {ExamCreateManyArgs} args - Arguments to create many Exams.
     * @example
     * // Create many Exams
     * const exam = await prisma.exam.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamCreateManyArgs>(args?: SelectSubset<T, ExamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Exam.
     * @param {ExamDeleteArgs} args - Arguments to delete one Exam.
     * @example
     * // Delete one Exam
     * const Exam = await prisma.exam.delete({
     *   where: {
     *     // ... filter to delete one Exam
     *   }
     * })
     * 
     */
    delete<T extends ExamDeleteArgs>(args: SelectSubset<T, ExamDeleteArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Exam.
     * @param {ExamUpdateArgs} args - Arguments to update one Exam.
     * @example
     * // Update one Exam
     * const exam = await prisma.exam.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamUpdateArgs>(args: SelectSubset<T, ExamUpdateArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Exams.
     * @param {ExamDeleteManyArgs} args - Arguments to filter Exams to delete.
     * @example
     * // Delete a few Exams
     * const { count } = await prisma.exam.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamDeleteManyArgs>(args?: SelectSubset<T, ExamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exams
     * const exam = await prisma.exam.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamUpdateManyArgs>(args: SelectSubset<T, ExamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Exam.
     * @param {ExamUpsertArgs} args - Arguments to update or create a Exam.
     * @example
     * // Update or create a Exam
     * const exam = await prisma.exam.upsert({
     *   create: {
     *     // ... data to create a Exam
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exam we want to update
     *   }
     * })
     */
    upsert<T extends ExamUpsertArgs>(args: SelectSubset<T, ExamUpsertArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamCountArgs} args - Arguments to filter Exams to count.
     * @example
     * // Count the number of Exams
     * const count = await prisma.exam.count({
     *   where: {
     *     // ... the filter for the Exams we want to count
     *   }
     * })
    **/
    count<T extends ExamCountArgs>(
      args?: Subset<T, ExamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamAggregateArgs>(args: Subset<T, ExamAggregateArgs>): Prisma.PrismaPromise<GetExamAggregateType<T>>

    /**
     * Group by Exam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamGroupByArgs['orderBy'] }
        : { orderBy?: ExamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Exam model
   */
  readonly fields: ExamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Exam.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    SyllabusContent<T extends SyllabusContentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SyllabusContentDefaultArgs<ExtArgs>>): Prisma__SyllabusContentClient<$Result.GetResult<Prisma.$SyllabusContentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ExamQuestions<T extends Exam$ExamQuestionsArgs<ExtArgs> = {}>(args?: Subset<T, Exam$ExamQuestionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamQuestionPayload<ExtArgs>, T, "findMany"> | Null>
    CourseLogging<T extends Exam$CourseLoggingArgs<ExtArgs> = {}>(args?: Subset<T, Exam$CourseLoggingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseLoggingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Exam model
   */ 
  interface ExamFieldRefs {
    readonly id: FieldRef<"Exam", 'Int'>
    readonly title: FieldRef<"Exam", 'String'>
    readonly syllabusContentId: FieldRef<"Exam", 'Int'>
    readonly createdAt: FieldRef<"Exam", 'DateTime'>
    readonly updatedAt: FieldRef<"Exam", 'DateTime'>
    readonly description: FieldRef<"Exam", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Exam findUnique
   */
  export type ExamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam findUniqueOrThrow
   */
  export type ExamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam findFirst
   */
  export type ExamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exams.
     */
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam findFirstOrThrow
   */
  export type ExamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exams.
     */
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam findMany
   */
  export type ExamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exams to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam create
   */
  export type ExamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The data needed to create a Exam.
     */
    data: XOR<ExamCreateInput, ExamUncheckedCreateInput>
  }

  /**
   * Exam createMany
   */
  export type ExamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Exams.
     */
    data: ExamCreateManyInput | ExamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Exam update
   */
  export type ExamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The data needed to update a Exam.
     */
    data: XOR<ExamUpdateInput, ExamUncheckedUpdateInput>
    /**
     * Choose, which Exam to update.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam updateMany
   */
  export type ExamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Exams.
     */
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyInput>
    /**
     * Filter which Exams to update
     */
    where?: ExamWhereInput
  }

  /**
   * Exam upsert
   */
  export type ExamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The filter to search for the Exam to update in case it exists.
     */
    where: ExamWhereUniqueInput
    /**
     * In case the Exam found by the `where` argument doesn't exist, create a new Exam with this data.
     */
    create: XOR<ExamCreateInput, ExamUncheckedCreateInput>
    /**
     * In case the Exam was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamUpdateInput, ExamUncheckedUpdateInput>
  }

  /**
   * Exam delete
   */
  export type ExamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter which Exam to delete.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam deleteMany
   */
  export type ExamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exams to delete
     */
    where?: ExamWhereInput
  }

  /**
   * Exam.ExamQuestions
   */
  export type Exam$ExamQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestion
     */
    select?: ExamQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamQuestionInclude<ExtArgs> | null
    where?: ExamQuestionWhereInput
    orderBy?: ExamQuestionOrderByWithRelationInput | ExamQuestionOrderByWithRelationInput[]
    cursor?: ExamQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamQuestionScalarFieldEnum | ExamQuestionScalarFieldEnum[]
  }

  /**
   * Exam.CourseLogging
   */
  export type Exam$CourseLoggingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLogging
     */
    select?: CourseLoggingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLoggingInclude<ExtArgs> | null
    where?: CourseLoggingWhereInput
    orderBy?: CourseLoggingOrderByWithRelationInput | CourseLoggingOrderByWithRelationInput[]
    cursor?: CourseLoggingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseLoggingScalarFieldEnum | CourseLoggingScalarFieldEnum[]
  }

  /**
   * Exam without action
   */
  export type ExamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
  }


  /**
   * Model ExamQuestion
   */

  export type AggregateExamQuestion = {
    _count: ExamQuestionCountAggregateOutputType | null
    _avg: ExamQuestionAvgAggregateOutputType | null
    _sum: ExamQuestionSumAggregateOutputType | null
    _min: ExamQuestionMinAggregateOutputType | null
    _max: ExamQuestionMaxAggregateOutputType | null
  }

  export type ExamQuestionAvgAggregateOutputType = {
    id: number | null
    examId: number | null
  }

  export type ExamQuestionSumAggregateOutputType = {
    id: number | null
    examId: number | null
  }

  export type ExamQuestionMinAggregateOutputType = {
    id: number | null
    isActive: boolean | null
    examId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    description: string | null
    questionText: string | null
    typeQuestion: $Enums.TypeQuestion | null
  }

  export type ExamQuestionMaxAggregateOutputType = {
    id: number | null
    isActive: boolean | null
    examId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    description: string | null
    questionText: string | null
    typeQuestion: $Enums.TypeQuestion | null
  }

  export type ExamQuestionCountAggregateOutputType = {
    id: number
    isActive: number
    examId: number
    createdAt: number
    updatedAt: number
    description: number
    questionText: number
    typeQuestion: number
    _all: number
  }


  export type ExamQuestionAvgAggregateInputType = {
    id?: true
    examId?: true
  }

  export type ExamQuestionSumAggregateInputType = {
    id?: true
    examId?: true
  }

  export type ExamQuestionMinAggregateInputType = {
    id?: true
    isActive?: true
    examId?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    questionText?: true
    typeQuestion?: true
  }

  export type ExamQuestionMaxAggregateInputType = {
    id?: true
    isActive?: true
    examId?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    questionText?: true
    typeQuestion?: true
  }

  export type ExamQuestionCountAggregateInputType = {
    id?: true
    isActive?: true
    examId?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    questionText?: true
    typeQuestion?: true
    _all?: true
  }

  export type ExamQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamQuestion to aggregate.
     */
    where?: ExamQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamQuestions to fetch.
     */
    orderBy?: ExamQuestionOrderByWithRelationInput | ExamQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExamQuestions
    **/
    _count?: true | ExamQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamQuestionMaxAggregateInputType
  }

  export type GetExamQuestionAggregateType<T extends ExamQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateExamQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamQuestion[P]>
      : GetScalarType<T[P], AggregateExamQuestion[P]>
  }




  export type ExamQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamQuestionWhereInput
    orderBy?: ExamQuestionOrderByWithAggregationInput | ExamQuestionOrderByWithAggregationInput[]
    by: ExamQuestionScalarFieldEnum[] | ExamQuestionScalarFieldEnum
    having?: ExamQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamQuestionCountAggregateInputType | true
    _avg?: ExamQuestionAvgAggregateInputType
    _sum?: ExamQuestionSumAggregateInputType
    _min?: ExamQuestionMinAggregateInputType
    _max?: ExamQuestionMaxAggregateInputType
  }

  export type ExamQuestionGroupByOutputType = {
    id: number
    isActive: boolean
    examId: number
    createdAt: Date
    updatedAt: Date
    description: string | null
    questionText: string
    typeQuestion: $Enums.TypeQuestion
    _count: ExamQuestionCountAggregateOutputType | null
    _avg: ExamQuestionAvgAggregateOutputType | null
    _sum: ExamQuestionSumAggregateOutputType | null
    _min: ExamQuestionMinAggregateOutputType | null
    _max: ExamQuestionMaxAggregateOutputType | null
  }

  type GetExamQuestionGroupByPayload<T extends ExamQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], ExamQuestionGroupByOutputType[P]>
        }
      >
    >


  export type ExamQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isActive?: boolean
    examId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    questionText?: boolean
    typeQuestion?: boolean
    Exam?: boolean | ExamDefaultArgs<ExtArgs>
    ExamOptions?: boolean | ExamQuestion$ExamOptionsArgs<ExtArgs>
    _count?: boolean | ExamQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examQuestion"]>


  export type ExamQuestionSelectScalar = {
    id?: boolean
    isActive?: boolean
    examId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    questionText?: boolean
    typeQuestion?: boolean
  }

  export type ExamQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Exam?: boolean | ExamDefaultArgs<ExtArgs>
    ExamOptions?: boolean | ExamQuestion$ExamOptionsArgs<ExtArgs>
    _count?: boolean | ExamQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ExamQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExamQuestion"
    objects: {
      Exam: Prisma.$ExamPayload<ExtArgs>
      ExamOptions: Prisma.$ExamOptionQuestionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      isActive: boolean
      examId: number
      createdAt: Date
      updatedAt: Date
      description: string | null
      questionText: string
      typeQuestion: $Enums.TypeQuestion
    }, ExtArgs["result"]["examQuestion"]>
    composites: {}
  }

  type ExamQuestionGetPayload<S extends boolean | null | undefined | ExamQuestionDefaultArgs> = $Result.GetResult<Prisma.$ExamQuestionPayload, S>

  type ExamQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExamQuestionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExamQuestionCountAggregateInputType | true
    }

  export interface ExamQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExamQuestion'], meta: { name: 'ExamQuestion' } }
    /**
     * Find zero or one ExamQuestion that matches the filter.
     * @param {ExamQuestionFindUniqueArgs} args - Arguments to find a ExamQuestion
     * @example
     * // Get one ExamQuestion
     * const examQuestion = await prisma.examQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamQuestionFindUniqueArgs>(args: SelectSubset<T, ExamQuestionFindUniqueArgs<ExtArgs>>): Prisma__ExamQuestionClient<$Result.GetResult<Prisma.$ExamQuestionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExamQuestion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExamQuestionFindUniqueOrThrowArgs} args - Arguments to find a ExamQuestion
     * @example
     * // Get one ExamQuestion
     * const examQuestion = await prisma.examQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamQuestionClient<$Result.GetResult<Prisma.$ExamQuestionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExamQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamQuestionFindFirstArgs} args - Arguments to find a ExamQuestion
     * @example
     * // Get one ExamQuestion
     * const examQuestion = await prisma.examQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamQuestionFindFirstArgs>(args?: SelectSubset<T, ExamQuestionFindFirstArgs<ExtArgs>>): Prisma__ExamQuestionClient<$Result.GetResult<Prisma.$ExamQuestionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExamQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamQuestionFindFirstOrThrowArgs} args - Arguments to find a ExamQuestion
     * @example
     * // Get one ExamQuestion
     * const examQuestion = await prisma.examQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamQuestionClient<$Result.GetResult<Prisma.$ExamQuestionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExamQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExamQuestions
     * const examQuestions = await prisma.examQuestion.findMany()
     * 
     * // Get first 10 ExamQuestions
     * const examQuestions = await prisma.examQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examQuestionWithIdOnly = await prisma.examQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamQuestionFindManyArgs>(args?: SelectSubset<T, ExamQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamQuestionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExamQuestion.
     * @param {ExamQuestionCreateArgs} args - Arguments to create a ExamQuestion.
     * @example
     * // Create one ExamQuestion
     * const ExamQuestion = await prisma.examQuestion.create({
     *   data: {
     *     // ... data to create a ExamQuestion
     *   }
     * })
     * 
     */
    create<T extends ExamQuestionCreateArgs>(args: SelectSubset<T, ExamQuestionCreateArgs<ExtArgs>>): Prisma__ExamQuestionClient<$Result.GetResult<Prisma.$ExamQuestionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExamQuestions.
     * @param {ExamQuestionCreateManyArgs} args - Arguments to create many ExamQuestions.
     * @example
     * // Create many ExamQuestions
     * const examQuestion = await prisma.examQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamQuestionCreateManyArgs>(args?: SelectSubset<T, ExamQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ExamQuestion.
     * @param {ExamQuestionDeleteArgs} args - Arguments to delete one ExamQuestion.
     * @example
     * // Delete one ExamQuestion
     * const ExamQuestion = await prisma.examQuestion.delete({
     *   where: {
     *     // ... filter to delete one ExamQuestion
     *   }
     * })
     * 
     */
    delete<T extends ExamQuestionDeleteArgs>(args: SelectSubset<T, ExamQuestionDeleteArgs<ExtArgs>>): Prisma__ExamQuestionClient<$Result.GetResult<Prisma.$ExamQuestionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExamQuestion.
     * @param {ExamQuestionUpdateArgs} args - Arguments to update one ExamQuestion.
     * @example
     * // Update one ExamQuestion
     * const examQuestion = await prisma.examQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamQuestionUpdateArgs>(args: SelectSubset<T, ExamQuestionUpdateArgs<ExtArgs>>): Prisma__ExamQuestionClient<$Result.GetResult<Prisma.$ExamQuestionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExamQuestions.
     * @param {ExamQuestionDeleteManyArgs} args - Arguments to filter ExamQuestions to delete.
     * @example
     * // Delete a few ExamQuestions
     * const { count } = await prisma.examQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamQuestionDeleteManyArgs>(args?: SelectSubset<T, ExamQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExamQuestions
     * const examQuestion = await prisma.examQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamQuestionUpdateManyArgs>(args: SelectSubset<T, ExamQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExamQuestion.
     * @param {ExamQuestionUpsertArgs} args - Arguments to update or create a ExamQuestion.
     * @example
     * // Update or create a ExamQuestion
     * const examQuestion = await prisma.examQuestion.upsert({
     *   create: {
     *     // ... data to create a ExamQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExamQuestion we want to update
     *   }
     * })
     */
    upsert<T extends ExamQuestionUpsertArgs>(args: SelectSubset<T, ExamQuestionUpsertArgs<ExtArgs>>): Prisma__ExamQuestionClient<$Result.GetResult<Prisma.$ExamQuestionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExamQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamQuestionCountArgs} args - Arguments to filter ExamQuestions to count.
     * @example
     * // Count the number of ExamQuestions
     * const count = await prisma.examQuestion.count({
     *   where: {
     *     // ... the filter for the ExamQuestions we want to count
     *   }
     * })
    **/
    count<T extends ExamQuestionCountArgs>(
      args?: Subset<T, ExamQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExamQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamQuestionAggregateArgs>(args: Subset<T, ExamQuestionAggregateArgs>): Prisma.PrismaPromise<GetExamQuestionAggregateType<T>>

    /**
     * Group by ExamQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamQuestionGroupByArgs['orderBy'] }
        : { orderBy?: ExamQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExamQuestion model
   */
  readonly fields: ExamQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExamQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Exam<T extends ExamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamDefaultArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ExamOptions<T extends ExamQuestion$ExamOptionsArgs<ExtArgs> = {}>(args?: Subset<T, ExamQuestion$ExamOptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamOptionQuestionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExamQuestion model
   */ 
  interface ExamQuestionFieldRefs {
    readonly id: FieldRef<"ExamQuestion", 'Int'>
    readonly isActive: FieldRef<"ExamQuestion", 'Boolean'>
    readonly examId: FieldRef<"ExamQuestion", 'Int'>
    readonly createdAt: FieldRef<"ExamQuestion", 'DateTime'>
    readonly updatedAt: FieldRef<"ExamQuestion", 'DateTime'>
    readonly description: FieldRef<"ExamQuestion", 'String'>
    readonly questionText: FieldRef<"ExamQuestion", 'String'>
    readonly typeQuestion: FieldRef<"ExamQuestion", 'TypeQuestion'>
  }
    

  // Custom InputTypes
  /**
   * ExamQuestion findUnique
   */
  export type ExamQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestion
     */
    select?: ExamQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ExamQuestion to fetch.
     */
    where: ExamQuestionWhereUniqueInput
  }

  /**
   * ExamQuestion findUniqueOrThrow
   */
  export type ExamQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestion
     */
    select?: ExamQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ExamQuestion to fetch.
     */
    where: ExamQuestionWhereUniqueInput
  }

  /**
   * ExamQuestion findFirst
   */
  export type ExamQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestion
     */
    select?: ExamQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ExamQuestion to fetch.
     */
    where?: ExamQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamQuestions to fetch.
     */
    orderBy?: ExamQuestionOrderByWithRelationInput | ExamQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamQuestions.
     */
    cursor?: ExamQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamQuestions.
     */
    distinct?: ExamQuestionScalarFieldEnum | ExamQuestionScalarFieldEnum[]
  }

  /**
   * ExamQuestion findFirstOrThrow
   */
  export type ExamQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestion
     */
    select?: ExamQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ExamQuestion to fetch.
     */
    where?: ExamQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamQuestions to fetch.
     */
    orderBy?: ExamQuestionOrderByWithRelationInput | ExamQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamQuestions.
     */
    cursor?: ExamQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamQuestions.
     */
    distinct?: ExamQuestionScalarFieldEnum | ExamQuestionScalarFieldEnum[]
  }

  /**
   * ExamQuestion findMany
   */
  export type ExamQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestion
     */
    select?: ExamQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ExamQuestions to fetch.
     */
    where?: ExamQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamQuestions to fetch.
     */
    orderBy?: ExamQuestionOrderByWithRelationInput | ExamQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExamQuestions.
     */
    cursor?: ExamQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamQuestions.
     */
    skip?: number
    distinct?: ExamQuestionScalarFieldEnum | ExamQuestionScalarFieldEnum[]
  }

  /**
   * ExamQuestion create
   */
  export type ExamQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestion
     */
    select?: ExamQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a ExamQuestion.
     */
    data: XOR<ExamQuestionCreateInput, ExamQuestionUncheckedCreateInput>
  }

  /**
   * ExamQuestion createMany
   */
  export type ExamQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExamQuestions.
     */
    data: ExamQuestionCreateManyInput | ExamQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExamQuestion update
   */
  export type ExamQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestion
     */
    select?: ExamQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a ExamQuestion.
     */
    data: XOR<ExamQuestionUpdateInput, ExamQuestionUncheckedUpdateInput>
    /**
     * Choose, which ExamQuestion to update.
     */
    where: ExamQuestionWhereUniqueInput
  }

  /**
   * ExamQuestion updateMany
   */
  export type ExamQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExamQuestions.
     */
    data: XOR<ExamQuestionUpdateManyMutationInput, ExamQuestionUncheckedUpdateManyInput>
    /**
     * Filter which ExamQuestions to update
     */
    where?: ExamQuestionWhereInput
  }

  /**
   * ExamQuestion upsert
   */
  export type ExamQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestion
     */
    select?: ExamQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the ExamQuestion to update in case it exists.
     */
    where: ExamQuestionWhereUniqueInput
    /**
     * In case the ExamQuestion found by the `where` argument doesn't exist, create a new ExamQuestion with this data.
     */
    create: XOR<ExamQuestionCreateInput, ExamQuestionUncheckedCreateInput>
    /**
     * In case the ExamQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamQuestionUpdateInput, ExamQuestionUncheckedUpdateInput>
  }

  /**
   * ExamQuestion delete
   */
  export type ExamQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestion
     */
    select?: ExamQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamQuestionInclude<ExtArgs> | null
    /**
     * Filter which ExamQuestion to delete.
     */
    where: ExamQuestionWhereUniqueInput
  }

  /**
   * ExamQuestion deleteMany
   */
  export type ExamQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamQuestions to delete
     */
    where?: ExamQuestionWhereInput
  }

  /**
   * ExamQuestion.ExamOptions
   */
  export type ExamQuestion$ExamOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamOptionQuestion
     */
    select?: ExamOptionQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamOptionQuestionInclude<ExtArgs> | null
    where?: ExamOptionQuestionWhereInput
    orderBy?: ExamOptionQuestionOrderByWithRelationInput | ExamOptionQuestionOrderByWithRelationInput[]
    cursor?: ExamOptionQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamOptionQuestionScalarFieldEnum | ExamOptionQuestionScalarFieldEnum[]
  }

  /**
   * ExamQuestion without action
   */
  export type ExamQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestion
     */
    select?: ExamQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamQuestionInclude<ExtArgs> | null
  }


  /**
   * Model ExamOptionQuestion
   */

  export type AggregateExamOptionQuestion = {
    _count: ExamOptionQuestionCountAggregateOutputType | null
    _avg: ExamOptionQuestionAvgAggregateOutputType | null
    _sum: ExamOptionQuestionSumAggregateOutputType | null
    _min: ExamOptionQuestionMinAggregateOutputType | null
    _max: ExamOptionQuestionMaxAggregateOutputType | null
  }

  export type ExamOptionQuestionAvgAggregateOutputType = {
    id: number | null
    order: number | null
    examQuestionId: number | null
  }

  export type ExamOptionQuestionSumAggregateOutputType = {
    id: number | null
    order: number | null
    examQuestionId: number | null
  }

  export type ExamOptionQuestionMinAggregateOutputType = {
    id: number | null
    optionText: string | null
    isTrue: boolean | null
    reason: string | null
    order: number | null
    attachment: string | null
    examQuestionId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamOptionQuestionMaxAggregateOutputType = {
    id: number | null
    optionText: string | null
    isTrue: boolean | null
    reason: string | null
    order: number | null
    attachment: string | null
    examQuestionId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamOptionQuestionCountAggregateOutputType = {
    id: number
    optionText: number
    isTrue: number
    reason: number
    order: number
    attachment: number
    examQuestionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExamOptionQuestionAvgAggregateInputType = {
    id?: true
    order?: true
    examQuestionId?: true
  }

  export type ExamOptionQuestionSumAggregateInputType = {
    id?: true
    order?: true
    examQuestionId?: true
  }

  export type ExamOptionQuestionMinAggregateInputType = {
    id?: true
    optionText?: true
    isTrue?: true
    reason?: true
    order?: true
    attachment?: true
    examQuestionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamOptionQuestionMaxAggregateInputType = {
    id?: true
    optionText?: true
    isTrue?: true
    reason?: true
    order?: true
    attachment?: true
    examQuestionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamOptionQuestionCountAggregateInputType = {
    id?: true
    optionText?: true
    isTrue?: true
    reason?: true
    order?: true
    attachment?: true
    examQuestionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExamOptionQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamOptionQuestion to aggregate.
     */
    where?: ExamOptionQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamOptionQuestions to fetch.
     */
    orderBy?: ExamOptionQuestionOrderByWithRelationInput | ExamOptionQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamOptionQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamOptionQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamOptionQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExamOptionQuestions
    **/
    _count?: true | ExamOptionQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamOptionQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamOptionQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamOptionQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamOptionQuestionMaxAggregateInputType
  }

  export type GetExamOptionQuestionAggregateType<T extends ExamOptionQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateExamOptionQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamOptionQuestion[P]>
      : GetScalarType<T[P], AggregateExamOptionQuestion[P]>
  }




  export type ExamOptionQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamOptionQuestionWhereInput
    orderBy?: ExamOptionQuestionOrderByWithAggregationInput | ExamOptionQuestionOrderByWithAggregationInput[]
    by: ExamOptionQuestionScalarFieldEnum[] | ExamOptionQuestionScalarFieldEnum
    having?: ExamOptionQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamOptionQuestionCountAggregateInputType | true
    _avg?: ExamOptionQuestionAvgAggregateInputType
    _sum?: ExamOptionQuestionSumAggregateInputType
    _min?: ExamOptionQuestionMinAggregateInputType
    _max?: ExamOptionQuestionMaxAggregateInputType
  }

  export type ExamOptionQuestionGroupByOutputType = {
    id: number
    optionText: string
    isTrue: boolean | null
    reason: string | null
    order: number | null
    attachment: string | null
    examQuestionId: number
    createdAt: Date
    updatedAt: Date
    _count: ExamOptionQuestionCountAggregateOutputType | null
    _avg: ExamOptionQuestionAvgAggregateOutputType | null
    _sum: ExamOptionQuestionSumAggregateOutputType | null
    _min: ExamOptionQuestionMinAggregateOutputType | null
    _max: ExamOptionQuestionMaxAggregateOutputType | null
  }

  type GetExamOptionQuestionGroupByPayload<T extends ExamOptionQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamOptionQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamOptionQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamOptionQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], ExamOptionQuestionGroupByOutputType[P]>
        }
      >
    >


  export type ExamOptionQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    optionText?: boolean
    isTrue?: boolean
    reason?: boolean
    order?: boolean
    attachment?: boolean
    examQuestionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ExamQuestion?: boolean | ExamQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examOptionQuestion"]>


  export type ExamOptionQuestionSelectScalar = {
    id?: boolean
    optionText?: boolean
    isTrue?: boolean
    reason?: boolean
    order?: boolean
    attachment?: boolean
    examQuestionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExamOptionQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ExamQuestion?: boolean | ExamQuestionDefaultArgs<ExtArgs>
  }

  export type $ExamOptionQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExamOptionQuestion"
    objects: {
      ExamQuestion: Prisma.$ExamQuestionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      optionText: string
      isTrue: boolean | null
      reason: string | null
      order: number | null
      attachment: string | null
      examQuestionId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["examOptionQuestion"]>
    composites: {}
  }

  type ExamOptionQuestionGetPayload<S extends boolean | null | undefined | ExamOptionQuestionDefaultArgs> = $Result.GetResult<Prisma.$ExamOptionQuestionPayload, S>

  type ExamOptionQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExamOptionQuestionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExamOptionQuestionCountAggregateInputType | true
    }

  export interface ExamOptionQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExamOptionQuestion'], meta: { name: 'ExamOptionQuestion' } }
    /**
     * Find zero or one ExamOptionQuestion that matches the filter.
     * @param {ExamOptionQuestionFindUniqueArgs} args - Arguments to find a ExamOptionQuestion
     * @example
     * // Get one ExamOptionQuestion
     * const examOptionQuestion = await prisma.examOptionQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamOptionQuestionFindUniqueArgs>(args: SelectSubset<T, ExamOptionQuestionFindUniqueArgs<ExtArgs>>): Prisma__ExamOptionQuestionClient<$Result.GetResult<Prisma.$ExamOptionQuestionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExamOptionQuestion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExamOptionQuestionFindUniqueOrThrowArgs} args - Arguments to find a ExamOptionQuestion
     * @example
     * // Get one ExamOptionQuestion
     * const examOptionQuestion = await prisma.examOptionQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamOptionQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamOptionQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamOptionQuestionClient<$Result.GetResult<Prisma.$ExamOptionQuestionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExamOptionQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamOptionQuestionFindFirstArgs} args - Arguments to find a ExamOptionQuestion
     * @example
     * // Get one ExamOptionQuestion
     * const examOptionQuestion = await prisma.examOptionQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamOptionQuestionFindFirstArgs>(args?: SelectSubset<T, ExamOptionQuestionFindFirstArgs<ExtArgs>>): Prisma__ExamOptionQuestionClient<$Result.GetResult<Prisma.$ExamOptionQuestionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExamOptionQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamOptionQuestionFindFirstOrThrowArgs} args - Arguments to find a ExamOptionQuestion
     * @example
     * // Get one ExamOptionQuestion
     * const examOptionQuestion = await prisma.examOptionQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamOptionQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamOptionQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamOptionQuestionClient<$Result.GetResult<Prisma.$ExamOptionQuestionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExamOptionQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamOptionQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExamOptionQuestions
     * const examOptionQuestions = await prisma.examOptionQuestion.findMany()
     * 
     * // Get first 10 ExamOptionQuestions
     * const examOptionQuestions = await prisma.examOptionQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examOptionQuestionWithIdOnly = await prisma.examOptionQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamOptionQuestionFindManyArgs>(args?: SelectSubset<T, ExamOptionQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamOptionQuestionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExamOptionQuestion.
     * @param {ExamOptionQuestionCreateArgs} args - Arguments to create a ExamOptionQuestion.
     * @example
     * // Create one ExamOptionQuestion
     * const ExamOptionQuestion = await prisma.examOptionQuestion.create({
     *   data: {
     *     // ... data to create a ExamOptionQuestion
     *   }
     * })
     * 
     */
    create<T extends ExamOptionQuestionCreateArgs>(args: SelectSubset<T, ExamOptionQuestionCreateArgs<ExtArgs>>): Prisma__ExamOptionQuestionClient<$Result.GetResult<Prisma.$ExamOptionQuestionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExamOptionQuestions.
     * @param {ExamOptionQuestionCreateManyArgs} args - Arguments to create many ExamOptionQuestions.
     * @example
     * // Create many ExamOptionQuestions
     * const examOptionQuestion = await prisma.examOptionQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamOptionQuestionCreateManyArgs>(args?: SelectSubset<T, ExamOptionQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ExamOptionQuestion.
     * @param {ExamOptionQuestionDeleteArgs} args - Arguments to delete one ExamOptionQuestion.
     * @example
     * // Delete one ExamOptionQuestion
     * const ExamOptionQuestion = await prisma.examOptionQuestion.delete({
     *   where: {
     *     // ... filter to delete one ExamOptionQuestion
     *   }
     * })
     * 
     */
    delete<T extends ExamOptionQuestionDeleteArgs>(args: SelectSubset<T, ExamOptionQuestionDeleteArgs<ExtArgs>>): Prisma__ExamOptionQuestionClient<$Result.GetResult<Prisma.$ExamOptionQuestionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExamOptionQuestion.
     * @param {ExamOptionQuestionUpdateArgs} args - Arguments to update one ExamOptionQuestion.
     * @example
     * // Update one ExamOptionQuestion
     * const examOptionQuestion = await prisma.examOptionQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamOptionQuestionUpdateArgs>(args: SelectSubset<T, ExamOptionQuestionUpdateArgs<ExtArgs>>): Prisma__ExamOptionQuestionClient<$Result.GetResult<Prisma.$ExamOptionQuestionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExamOptionQuestions.
     * @param {ExamOptionQuestionDeleteManyArgs} args - Arguments to filter ExamOptionQuestions to delete.
     * @example
     * // Delete a few ExamOptionQuestions
     * const { count } = await prisma.examOptionQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamOptionQuestionDeleteManyArgs>(args?: SelectSubset<T, ExamOptionQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamOptionQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamOptionQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExamOptionQuestions
     * const examOptionQuestion = await prisma.examOptionQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamOptionQuestionUpdateManyArgs>(args: SelectSubset<T, ExamOptionQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExamOptionQuestion.
     * @param {ExamOptionQuestionUpsertArgs} args - Arguments to update or create a ExamOptionQuestion.
     * @example
     * // Update or create a ExamOptionQuestion
     * const examOptionQuestion = await prisma.examOptionQuestion.upsert({
     *   create: {
     *     // ... data to create a ExamOptionQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExamOptionQuestion we want to update
     *   }
     * })
     */
    upsert<T extends ExamOptionQuestionUpsertArgs>(args: SelectSubset<T, ExamOptionQuestionUpsertArgs<ExtArgs>>): Prisma__ExamOptionQuestionClient<$Result.GetResult<Prisma.$ExamOptionQuestionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExamOptionQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamOptionQuestionCountArgs} args - Arguments to filter ExamOptionQuestions to count.
     * @example
     * // Count the number of ExamOptionQuestions
     * const count = await prisma.examOptionQuestion.count({
     *   where: {
     *     // ... the filter for the ExamOptionQuestions we want to count
     *   }
     * })
    **/
    count<T extends ExamOptionQuestionCountArgs>(
      args?: Subset<T, ExamOptionQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamOptionQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExamOptionQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamOptionQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamOptionQuestionAggregateArgs>(args: Subset<T, ExamOptionQuestionAggregateArgs>): Prisma.PrismaPromise<GetExamOptionQuestionAggregateType<T>>

    /**
     * Group by ExamOptionQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamOptionQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamOptionQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamOptionQuestionGroupByArgs['orderBy'] }
        : { orderBy?: ExamOptionQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamOptionQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamOptionQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExamOptionQuestion model
   */
  readonly fields: ExamOptionQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExamOptionQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamOptionQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ExamQuestion<T extends ExamQuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamQuestionDefaultArgs<ExtArgs>>): Prisma__ExamQuestionClient<$Result.GetResult<Prisma.$ExamQuestionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExamOptionQuestion model
   */ 
  interface ExamOptionQuestionFieldRefs {
    readonly id: FieldRef<"ExamOptionQuestion", 'Int'>
    readonly optionText: FieldRef<"ExamOptionQuestion", 'String'>
    readonly isTrue: FieldRef<"ExamOptionQuestion", 'Boolean'>
    readonly reason: FieldRef<"ExamOptionQuestion", 'String'>
    readonly order: FieldRef<"ExamOptionQuestion", 'Int'>
    readonly attachment: FieldRef<"ExamOptionQuestion", 'String'>
    readonly examQuestionId: FieldRef<"ExamOptionQuestion", 'Int'>
    readonly createdAt: FieldRef<"ExamOptionQuestion", 'DateTime'>
    readonly updatedAt: FieldRef<"ExamOptionQuestion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExamOptionQuestion findUnique
   */
  export type ExamOptionQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamOptionQuestion
     */
    select?: ExamOptionQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamOptionQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ExamOptionQuestion to fetch.
     */
    where: ExamOptionQuestionWhereUniqueInput
  }

  /**
   * ExamOptionQuestion findUniqueOrThrow
   */
  export type ExamOptionQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamOptionQuestion
     */
    select?: ExamOptionQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamOptionQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ExamOptionQuestion to fetch.
     */
    where: ExamOptionQuestionWhereUniqueInput
  }

  /**
   * ExamOptionQuestion findFirst
   */
  export type ExamOptionQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamOptionQuestion
     */
    select?: ExamOptionQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamOptionQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ExamOptionQuestion to fetch.
     */
    where?: ExamOptionQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamOptionQuestions to fetch.
     */
    orderBy?: ExamOptionQuestionOrderByWithRelationInput | ExamOptionQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamOptionQuestions.
     */
    cursor?: ExamOptionQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamOptionQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamOptionQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamOptionQuestions.
     */
    distinct?: ExamOptionQuestionScalarFieldEnum | ExamOptionQuestionScalarFieldEnum[]
  }

  /**
   * ExamOptionQuestion findFirstOrThrow
   */
  export type ExamOptionQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamOptionQuestion
     */
    select?: ExamOptionQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamOptionQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ExamOptionQuestion to fetch.
     */
    where?: ExamOptionQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamOptionQuestions to fetch.
     */
    orderBy?: ExamOptionQuestionOrderByWithRelationInput | ExamOptionQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamOptionQuestions.
     */
    cursor?: ExamOptionQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamOptionQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamOptionQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamOptionQuestions.
     */
    distinct?: ExamOptionQuestionScalarFieldEnum | ExamOptionQuestionScalarFieldEnum[]
  }

  /**
   * ExamOptionQuestion findMany
   */
  export type ExamOptionQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamOptionQuestion
     */
    select?: ExamOptionQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamOptionQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ExamOptionQuestions to fetch.
     */
    where?: ExamOptionQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamOptionQuestions to fetch.
     */
    orderBy?: ExamOptionQuestionOrderByWithRelationInput | ExamOptionQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExamOptionQuestions.
     */
    cursor?: ExamOptionQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamOptionQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamOptionQuestions.
     */
    skip?: number
    distinct?: ExamOptionQuestionScalarFieldEnum | ExamOptionQuestionScalarFieldEnum[]
  }

  /**
   * ExamOptionQuestion create
   */
  export type ExamOptionQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamOptionQuestion
     */
    select?: ExamOptionQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamOptionQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a ExamOptionQuestion.
     */
    data: XOR<ExamOptionQuestionCreateInput, ExamOptionQuestionUncheckedCreateInput>
  }

  /**
   * ExamOptionQuestion createMany
   */
  export type ExamOptionQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExamOptionQuestions.
     */
    data: ExamOptionQuestionCreateManyInput | ExamOptionQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExamOptionQuestion update
   */
  export type ExamOptionQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamOptionQuestion
     */
    select?: ExamOptionQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamOptionQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a ExamOptionQuestion.
     */
    data: XOR<ExamOptionQuestionUpdateInput, ExamOptionQuestionUncheckedUpdateInput>
    /**
     * Choose, which ExamOptionQuestion to update.
     */
    where: ExamOptionQuestionWhereUniqueInput
  }

  /**
   * ExamOptionQuestion updateMany
   */
  export type ExamOptionQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExamOptionQuestions.
     */
    data: XOR<ExamOptionQuestionUpdateManyMutationInput, ExamOptionQuestionUncheckedUpdateManyInput>
    /**
     * Filter which ExamOptionQuestions to update
     */
    where?: ExamOptionQuestionWhereInput
  }

  /**
   * ExamOptionQuestion upsert
   */
  export type ExamOptionQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamOptionQuestion
     */
    select?: ExamOptionQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamOptionQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the ExamOptionQuestion to update in case it exists.
     */
    where: ExamOptionQuestionWhereUniqueInput
    /**
     * In case the ExamOptionQuestion found by the `where` argument doesn't exist, create a new ExamOptionQuestion with this data.
     */
    create: XOR<ExamOptionQuestionCreateInput, ExamOptionQuestionUncheckedCreateInput>
    /**
     * In case the ExamOptionQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamOptionQuestionUpdateInput, ExamOptionQuestionUncheckedUpdateInput>
  }

  /**
   * ExamOptionQuestion delete
   */
  export type ExamOptionQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamOptionQuestion
     */
    select?: ExamOptionQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamOptionQuestionInclude<ExtArgs> | null
    /**
     * Filter which ExamOptionQuestion to delete.
     */
    where: ExamOptionQuestionWhereUniqueInput
  }

  /**
   * ExamOptionQuestion deleteMany
   */
  export type ExamOptionQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamOptionQuestions to delete
     */
    where?: ExamOptionQuestionWhereInput
  }

  /**
   * ExamOptionQuestion without action
   */
  export type ExamOptionQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamOptionQuestion
     */
    select?: ExamOptionQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamOptionQuestionInclude<ExtArgs> | null
  }


  /**
   * Model MaterialContentType
   */

  export type AggregateMaterialContentType = {
    _count: MaterialContentTypeCountAggregateOutputType | null
    _avg: MaterialContentTypeAvgAggregateOutputType | null
    _sum: MaterialContentTypeSumAggregateOutputType | null
    _min: MaterialContentTypeMinAggregateOutputType | null
    _max: MaterialContentTypeMaxAggregateOutputType | null
  }

  export type MaterialContentTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type MaterialContentTypeSumAggregateOutputType = {
    id: number | null
  }

  export type MaterialContentTypeMinAggregateOutputType = {
    id: number | null
    title: $Enums.TypeMaterialContent | null
  }

  export type MaterialContentTypeMaxAggregateOutputType = {
    id: number | null
    title: $Enums.TypeMaterialContent | null
  }

  export type MaterialContentTypeCountAggregateOutputType = {
    id: number
    title: number
    _all: number
  }


  export type MaterialContentTypeAvgAggregateInputType = {
    id?: true
  }

  export type MaterialContentTypeSumAggregateInputType = {
    id?: true
  }

  export type MaterialContentTypeMinAggregateInputType = {
    id?: true
    title?: true
  }

  export type MaterialContentTypeMaxAggregateInputType = {
    id?: true
    title?: true
  }

  export type MaterialContentTypeCountAggregateInputType = {
    id?: true
    title?: true
    _all?: true
  }

  export type MaterialContentTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaterialContentType to aggregate.
     */
    where?: MaterialContentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialContentTypes to fetch.
     */
    orderBy?: MaterialContentTypeOrderByWithRelationInput | MaterialContentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialContentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialContentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialContentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaterialContentTypes
    **/
    _count?: true | MaterialContentTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialContentTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialContentTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialContentTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialContentTypeMaxAggregateInputType
  }

  export type GetMaterialContentTypeAggregateType<T extends MaterialContentTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterialContentType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterialContentType[P]>
      : GetScalarType<T[P], AggregateMaterialContentType[P]>
  }




  export type MaterialContentTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialContentTypeWhereInput
    orderBy?: MaterialContentTypeOrderByWithAggregationInput | MaterialContentTypeOrderByWithAggregationInput[]
    by: MaterialContentTypeScalarFieldEnum[] | MaterialContentTypeScalarFieldEnum
    having?: MaterialContentTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialContentTypeCountAggregateInputType | true
    _avg?: MaterialContentTypeAvgAggregateInputType
    _sum?: MaterialContentTypeSumAggregateInputType
    _min?: MaterialContentTypeMinAggregateInputType
    _max?: MaterialContentTypeMaxAggregateInputType
  }

  export type MaterialContentTypeGroupByOutputType = {
    id: number
    title: $Enums.TypeMaterialContent
    _count: MaterialContentTypeCountAggregateOutputType | null
    _avg: MaterialContentTypeAvgAggregateOutputType | null
    _sum: MaterialContentTypeSumAggregateOutputType | null
    _min: MaterialContentTypeMinAggregateOutputType | null
    _max: MaterialContentTypeMaxAggregateOutputType | null
  }

  type GetMaterialContentTypeGroupByPayload<T extends MaterialContentTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialContentTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialContentTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialContentTypeGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialContentTypeGroupByOutputType[P]>
        }
      >
    >


  export type MaterialContentTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    MaterialContents?: boolean | MaterialContentType$MaterialContentsArgs<ExtArgs>
    _count?: boolean | MaterialContentTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materialContentType"]>


  export type MaterialContentTypeSelectScalar = {
    id?: boolean
    title?: boolean
  }

  export type MaterialContentTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MaterialContents?: boolean | MaterialContentType$MaterialContentsArgs<ExtArgs>
    _count?: boolean | MaterialContentTypeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MaterialContentTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaterialContentType"
    objects: {
      MaterialContents: Prisma.$MaterialContentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: $Enums.TypeMaterialContent
    }, ExtArgs["result"]["materialContentType"]>
    composites: {}
  }

  type MaterialContentTypeGetPayload<S extends boolean | null | undefined | MaterialContentTypeDefaultArgs> = $Result.GetResult<Prisma.$MaterialContentTypePayload, S>

  type MaterialContentTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MaterialContentTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MaterialContentTypeCountAggregateInputType | true
    }

  export interface MaterialContentTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaterialContentType'], meta: { name: 'MaterialContentType' } }
    /**
     * Find zero or one MaterialContentType that matches the filter.
     * @param {MaterialContentTypeFindUniqueArgs} args - Arguments to find a MaterialContentType
     * @example
     * // Get one MaterialContentType
     * const materialContentType = await prisma.materialContentType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaterialContentTypeFindUniqueArgs>(args: SelectSubset<T, MaterialContentTypeFindUniqueArgs<ExtArgs>>): Prisma__MaterialContentTypeClient<$Result.GetResult<Prisma.$MaterialContentTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MaterialContentType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MaterialContentTypeFindUniqueOrThrowArgs} args - Arguments to find a MaterialContentType
     * @example
     * // Get one MaterialContentType
     * const materialContentType = await prisma.materialContentType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaterialContentTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, MaterialContentTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaterialContentTypeClient<$Result.GetResult<Prisma.$MaterialContentTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MaterialContentType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentTypeFindFirstArgs} args - Arguments to find a MaterialContentType
     * @example
     * // Get one MaterialContentType
     * const materialContentType = await prisma.materialContentType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaterialContentTypeFindFirstArgs>(args?: SelectSubset<T, MaterialContentTypeFindFirstArgs<ExtArgs>>): Prisma__MaterialContentTypeClient<$Result.GetResult<Prisma.$MaterialContentTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MaterialContentType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentTypeFindFirstOrThrowArgs} args - Arguments to find a MaterialContentType
     * @example
     * // Get one MaterialContentType
     * const materialContentType = await prisma.materialContentType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaterialContentTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, MaterialContentTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaterialContentTypeClient<$Result.GetResult<Prisma.$MaterialContentTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MaterialContentTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaterialContentTypes
     * const materialContentTypes = await prisma.materialContentType.findMany()
     * 
     * // Get first 10 MaterialContentTypes
     * const materialContentTypes = await prisma.materialContentType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialContentTypeWithIdOnly = await prisma.materialContentType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaterialContentTypeFindManyArgs>(args?: SelectSubset<T, MaterialContentTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialContentTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MaterialContentType.
     * @param {MaterialContentTypeCreateArgs} args - Arguments to create a MaterialContentType.
     * @example
     * // Create one MaterialContentType
     * const MaterialContentType = await prisma.materialContentType.create({
     *   data: {
     *     // ... data to create a MaterialContentType
     *   }
     * })
     * 
     */
    create<T extends MaterialContentTypeCreateArgs>(args: SelectSubset<T, MaterialContentTypeCreateArgs<ExtArgs>>): Prisma__MaterialContentTypeClient<$Result.GetResult<Prisma.$MaterialContentTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MaterialContentTypes.
     * @param {MaterialContentTypeCreateManyArgs} args - Arguments to create many MaterialContentTypes.
     * @example
     * // Create many MaterialContentTypes
     * const materialContentType = await prisma.materialContentType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaterialContentTypeCreateManyArgs>(args?: SelectSubset<T, MaterialContentTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MaterialContentType.
     * @param {MaterialContentTypeDeleteArgs} args - Arguments to delete one MaterialContentType.
     * @example
     * // Delete one MaterialContentType
     * const MaterialContentType = await prisma.materialContentType.delete({
     *   where: {
     *     // ... filter to delete one MaterialContentType
     *   }
     * })
     * 
     */
    delete<T extends MaterialContentTypeDeleteArgs>(args: SelectSubset<T, MaterialContentTypeDeleteArgs<ExtArgs>>): Prisma__MaterialContentTypeClient<$Result.GetResult<Prisma.$MaterialContentTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MaterialContentType.
     * @param {MaterialContentTypeUpdateArgs} args - Arguments to update one MaterialContentType.
     * @example
     * // Update one MaterialContentType
     * const materialContentType = await prisma.materialContentType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaterialContentTypeUpdateArgs>(args: SelectSubset<T, MaterialContentTypeUpdateArgs<ExtArgs>>): Prisma__MaterialContentTypeClient<$Result.GetResult<Prisma.$MaterialContentTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MaterialContentTypes.
     * @param {MaterialContentTypeDeleteManyArgs} args - Arguments to filter MaterialContentTypes to delete.
     * @example
     * // Delete a few MaterialContentTypes
     * const { count } = await prisma.materialContentType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaterialContentTypeDeleteManyArgs>(args?: SelectSubset<T, MaterialContentTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaterialContentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaterialContentTypes
     * const materialContentType = await prisma.materialContentType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaterialContentTypeUpdateManyArgs>(args: SelectSubset<T, MaterialContentTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MaterialContentType.
     * @param {MaterialContentTypeUpsertArgs} args - Arguments to update or create a MaterialContentType.
     * @example
     * // Update or create a MaterialContentType
     * const materialContentType = await prisma.materialContentType.upsert({
     *   create: {
     *     // ... data to create a MaterialContentType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaterialContentType we want to update
     *   }
     * })
     */
    upsert<T extends MaterialContentTypeUpsertArgs>(args: SelectSubset<T, MaterialContentTypeUpsertArgs<ExtArgs>>): Prisma__MaterialContentTypeClient<$Result.GetResult<Prisma.$MaterialContentTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MaterialContentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentTypeCountArgs} args - Arguments to filter MaterialContentTypes to count.
     * @example
     * // Count the number of MaterialContentTypes
     * const count = await prisma.materialContentType.count({
     *   where: {
     *     // ... the filter for the MaterialContentTypes we want to count
     *   }
     * })
    **/
    count<T extends MaterialContentTypeCountArgs>(
      args?: Subset<T, MaterialContentTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialContentTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaterialContentType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialContentTypeAggregateArgs>(args: Subset<T, MaterialContentTypeAggregateArgs>): Prisma.PrismaPromise<GetMaterialContentTypeAggregateType<T>>

    /**
     * Group by MaterialContentType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialContentTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialContentTypeGroupByArgs['orderBy'] }
        : { orderBy?: MaterialContentTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialContentTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialContentTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaterialContentType model
   */
  readonly fields: MaterialContentTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaterialContentType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterialContentTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    MaterialContents<T extends MaterialContentType$MaterialContentsArgs<ExtArgs> = {}>(args?: Subset<T, MaterialContentType$MaterialContentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialContentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaterialContentType model
   */ 
  interface MaterialContentTypeFieldRefs {
    readonly id: FieldRef<"MaterialContentType", 'Int'>
    readonly title: FieldRef<"MaterialContentType", 'TypeMaterialContent'>
  }
    

  // Custom InputTypes
  /**
   * MaterialContentType findUnique
   */
  export type MaterialContentTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentType
     */
    select?: MaterialContentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentTypeInclude<ExtArgs> | null
    /**
     * Filter, which MaterialContentType to fetch.
     */
    where: MaterialContentTypeWhereUniqueInput
  }

  /**
   * MaterialContentType findUniqueOrThrow
   */
  export type MaterialContentTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentType
     */
    select?: MaterialContentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentTypeInclude<ExtArgs> | null
    /**
     * Filter, which MaterialContentType to fetch.
     */
    where: MaterialContentTypeWhereUniqueInput
  }

  /**
   * MaterialContentType findFirst
   */
  export type MaterialContentTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentType
     */
    select?: MaterialContentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentTypeInclude<ExtArgs> | null
    /**
     * Filter, which MaterialContentType to fetch.
     */
    where?: MaterialContentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialContentTypes to fetch.
     */
    orderBy?: MaterialContentTypeOrderByWithRelationInput | MaterialContentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaterialContentTypes.
     */
    cursor?: MaterialContentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialContentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialContentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaterialContentTypes.
     */
    distinct?: MaterialContentTypeScalarFieldEnum | MaterialContentTypeScalarFieldEnum[]
  }

  /**
   * MaterialContentType findFirstOrThrow
   */
  export type MaterialContentTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentType
     */
    select?: MaterialContentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentTypeInclude<ExtArgs> | null
    /**
     * Filter, which MaterialContentType to fetch.
     */
    where?: MaterialContentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialContentTypes to fetch.
     */
    orderBy?: MaterialContentTypeOrderByWithRelationInput | MaterialContentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaterialContentTypes.
     */
    cursor?: MaterialContentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialContentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialContentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaterialContentTypes.
     */
    distinct?: MaterialContentTypeScalarFieldEnum | MaterialContentTypeScalarFieldEnum[]
  }

  /**
   * MaterialContentType findMany
   */
  export type MaterialContentTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentType
     */
    select?: MaterialContentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentTypeInclude<ExtArgs> | null
    /**
     * Filter, which MaterialContentTypes to fetch.
     */
    where?: MaterialContentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialContentTypes to fetch.
     */
    orderBy?: MaterialContentTypeOrderByWithRelationInput | MaterialContentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaterialContentTypes.
     */
    cursor?: MaterialContentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialContentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialContentTypes.
     */
    skip?: number
    distinct?: MaterialContentTypeScalarFieldEnum | MaterialContentTypeScalarFieldEnum[]
  }

  /**
   * MaterialContentType create
   */
  export type MaterialContentTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentType
     */
    select?: MaterialContentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a MaterialContentType.
     */
    data: XOR<MaterialContentTypeCreateInput, MaterialContentTypeUncheckedCreateInput>
  }

  /**
   * MaterialContentType createMany
   */
  export type MaterialContentTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaterialContentTypes.
     */
    data: MaterialContentTypeCreateManyInput | MaterialContentTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MaterialContentType update
   */
  export type MaterialContentTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentType
     */
    select?: MaterialContentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a MaterialContentType.
     */
    data: XOR<MaterialContentTypeUpdateInput, MaterialContentTypeUncheckedUpdateInput>
    /**
     * Choose, which MaterialContentType to update.
     */
    where: MaterialContentTypeWhereUniqueInput
  }

  /**
   * MaterialContentType updateMany
   */
  export type MaterialContentTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaterialContentTypes.
     */
    data: XOR<MaterialContentTypeUpdateManyMutationInput, MaterialContentTypeUncheckedUpdateManyInput>
    /**
     * Filter which MaterialContentTypes to update
     */
    where?: MaterialContentTypeWhereInput
  }

  /**
   * MaterialContentType upsert
   */
  export type MaterialContentTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentType
     */
    select?: MaterialContentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the MaterialContentType to update in case it exists.
     */
    where: MaterialContentTypeWhereUniqueInput
    /**
     * In case the MaterialContentType found by the `where` argument doesn't exist, create a new MaterialContentType with this data.
     */
    create: XOR<MaterialContentTypeCreateInput, MaterialContentTypeUncheckedCreateInput>
    /**
     * In case the MaterialContentType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialContentTypeUpdateInput, MaterialContentTypeUncheckedUpdateInput>
  }

  /**
   * MaterialContentType delete
   */
  export type MaterialContentTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentType
     */
    select?: MaterialContentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentTypeInclude<ExtArgs> | null
    /**
     * Filter which MaterialContentType to delete.
     */
    where: MaterialContentTypeWhereUniqueInput
  }

  /**
   * MaterialContentType deleteMany
   */
  export type MaterialContentTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaterialContentTypes to delete
     */
    where?: MaterialContentTypeWhereInput
  }

  /**
   * MaterialContentType.MaterialContents
   */
  export type MaterialContentType$MaterialContentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContent
     */
    select?: MaterialContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentInclude<ExtArgs> | null
    where?: MaterialContentWhereInput
    orderBy?: MaterialContentOrderByWithRelationInput | MaterialContentOrderByWithRelationInput[]
    cursor?: MaterialContentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialContentScalarFieldEnum | MaterialContentScalarFieldEnum[]
  }

  /**
   * MaterialContentType without action
   */
  export type MaterialContentTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentType
     */
    select?: MaterialContentTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentTypeInclude<ExtArgs> | null
  }


  /**
   * Model MaterialContent
   */

  export type AggregateMaterialContent = {
    _count: MaterialContentCountAggregateOutputType | null
    _avg: MaterialContentAvgAggregateOutputType | null
    _sum: MaterialContentSumAggregateOutputType | null
    _min: MaterialContentMinAggregateOutputType | null
    _max: MaterialContentMaxAggregateOutputType | null
  }

  export type MaterialContentAvgAggregateOutputType = {
    id: number | null
    materialContentTypeId: number | null
    order: number | null
    syllabusContentId: number | null
    estimatedTime: number | null
  }

  export type MaterialContentSumAggregateOutputType = {
    id: number | null
    materialContentTypeId: number | null
    order: number | null
    syllabusContentId: number | null
    estimatedTime: number | null
  }

  export type MaterialContentMinAggregateOutputType = {
    id: number | null
    title: string | null
    materialContentTypeId: number | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
    slug: string | null
    syllabusContentId: number | null
    estimatedTime: number | null
  }

  export type MaterialContentMaxAggregateOutputType = {
    id: number | null
    title: string | null
    materialContentTypeId: number | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
    slug: string | null
    syllabusContentId: number | null
    estimatedTime: number | null
  }

  export type MaterialContentCountAggregateOutputType = {
    id: number
    title: number
    materialContentTypeId: number
    order: number
    createdAt: number
    updatedAt: number
    slug: number
    syllabusContentId: number
    estimatedTime: number
    _all: number
  }


  export type MaterialContentAvgAggregateInputType = {
    id?: true
    materialContentTypeId?: true
    order?: true
    syllabusContentId?: true
    estimatedTime?: true
  }

  export type MaterialContentSumAggregateInputType = {
    id?: true
    materialContentTypeId?: true
    order?: true
    syllabusContentId?: true
    estimatedTime?: true
  }

  export type MaterialContentMinAggregateInputType = {
    id?: true
    title?: true
    materialContentTypeId?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    slug?: true
    syllabusContentId?: true
    estimatedTime?: true
  }

  export type MaterialContentMaxAggregateInputType = {
    id?: true
    title?: true
    materialContentTypeId?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    slug?: true
    syllabusContentId?: true
    estimatedTime?: true
  }

  export type MaterialContentCountAggregateInputType = {
    id?: true
    title?: true
    materialContentTypeId?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    slug?: true
    syllabusContentId?: true
    estimatedTime?: true
    _all?: true
  }

  export type MaterialContentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaterialContent to aggregate.
     */
    where?: MaterialContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialContents to fetch.
     */
    orderBy?: MaterialContentOrderByWithRelationInput | MaterialContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaterialContents
    **/
    _count?: true | MaterialContentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialContentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialContentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialContentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialContentMaxAggregateInputType
  }

  export type GetMaterialContentAggregateType<T extends MaterialContentAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterialContent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterialContent[P]>
      : GetScalarType<T[P], AggregateMaterialContent[P]>
  }




  export type MaterialContentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialContentWhereInput
    orderBy?: MaterialContentOrderByWithAggregationInput | MaterialContentOrderByWithAggregationInput[]
    by: MaterialContentScalarFieldEnum[] | MaterialContentScalarFieldEnum
    having?: MaterialContentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialContentCountAggregateInputType | true
    _avg?: MaterialContentAvgAggregateInputType
    _sum?: MaterialContentSumAggregateInputType
    _min?: MaterialContentMinAggregateInputType
    _max?: MaterialContentMaxAggregateInputType
  }

  export type MaterialContentGroupByOutputType = {
    id: number
    title: string
    materialContentTypeId: number
    order: number
    createdAt: Date
    updatedAt: Date
    slug: string
    syllabusContentId: number
    estimatedTime: number
    _count: MaterialContentCountAggregateOutputType | null
    _avg: MaterialContentAvgAggregateOutputType | null
    _sum: MaterialContentSumAggregateOutputType | null
    _min: MaterialContentMinAggregateOutputType | null
    _max: MaterialContentMaxAggregateOutputType | null
  }

  type GetMaterialContentGroupByPayload<T extends MaterialContentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialContentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialContentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialContentGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialContentGroupByOutputType[P]>
        }
      >
    >


  export type MaterialContentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    materialContentTypeId?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    slug?: boolean
    syllabusContentId?: boolean
    estimatedTime?: boolean
    Type?: boolean | MaterialContentTypeDefaultArgs<ExtArgs>
    SyllabusContent?: boolean | SyllabusContentDefaultArgs<ExtArgs>
    Attachments?: boolean | MaterialContent$AttachmentsArgs<ExtArgs>
    File?: boolean | MaterialContent$FileArgs<ExtArgs>
    MaterialContentLearning?: boolean | MaterialContent$MaterialContentLearningArgs<ExtArgs>
    MaterialContentTest?: boolean | MaterialContent$MaterialContentTestArgs<ExtArgs>
    CourseLogging?: boolean | MaterialContent$CourseLoggingArgs<ExtArgs>
    _count?: boolean | MaterialContentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materialContent"]>


  export type MaterialContentSelectScalar = {
    id?: boolean
    title?: boolean
    materialContentTypeId?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    slug?: boolean
    syllabusContentId?: boolean
    estimatedTime?: boolean
  }

  export type MaterialContentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Type?: boolean | MaterialContentTypeDefaultArgs<ExtArgs>
    SyllabusContent?: boolean | SyllabusContentDefaultArgs<ExtArgs>
    Attachments?: boolean | MaterialContent$AttachmentsArgs<ExtArgs>
    File?: boolean | MaterialContent$FileArgs<ExtArgs>
    MaterialContentLearning?: boolean | MaterialContent$MaterialContentLearningArgs<ExtArgs>
    MaterialContentTest?: boolean | MaterialContent$MaterialContentTestArgs<ExtArgs>
    CourseLogging?: boolean | MaterialContent$CourseLoggingArgs<ExtArgs>
    _count?: boolean | MaterialContentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MaterialContentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaterialContent"
    objects: {
      Type: Prisma.$MaterialContentTypePayload<ExtArgs>
      SyllabusContent: Prisma.$SyllabusContentPayload<ExtArgs>
      Attachments: Prisma.$MaterialContentAttachmentPayload<ExtArgs>[]
      File: Prisma.$MaterialContentFilePayload<ExtArgs> | null
      MaterialContentLearning: Prisma.$MaterialContentLearningPayload<ExtArgs> | null
      MaterialContentTest: Prisma.$MaterialContentTestPayload<ExtArgs> | null
      CourseLogging: Prisma.$CourseLoggingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      materialContentTypeId: number
      order: number
      createdAt: Date
      updatedAt: Date
      slug: string
      syllabusContentId: number
      estimatedTime: number
    }, ExtArgs["result"]["materialContent"]>
    composites: {}
  }

  type MaterialContentGetPayload<S extends boolean | null | undefined | MaterialContentDefaultArgs> = $Result.GetResult<Prisma.$MaterialContentPayload, S>

  type MaterialContentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MaterialContentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MaterialContentCountAggregateInputType | true
    }

  export interface MaterialContentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaterialContent'], meta: { name: 'MaterialContent' } }
    /**
     * Find zero or one MaterialContent that matches the filter.
     * @param {MaterialContentFindUniqueArgs} args - Arguments to find a MaterialContent
     * @example
     * // Get one MaterialContent
     * const materialContent = await prisma.materialContent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaterialContentFindUniqueArgs>(args: SelectSubset<T, MaterialContentFindUniqueArgs<ExtArgs>>): Prisma__MaterialContentClient<$Result.GetResult<Prisma.$MaterialContentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MaterialContent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MaterialContentFindUniqueOrThrowArgs} args - Arguments to find a MaterialContent
     * @example
     * // Get one MaterialContent
     * const materialContent = await prisma.materialContent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaterialContentFindUniqueOrThrowArgs>(args: SelectSubset<T, MaterialContentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaterialContentClient<$Result.GetResult<Prisma.$MaterialContentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MaterialContent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentFindFirstArgs} args - Arguments to find a MaterialContent
     * @example
     * // Get one MaterialContent
     * const materialContent = await prisma.materialContent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaterialContentFindFirstArgs>(args?: SelectSubset<T, MaterialContentFindFirstArgs<ExtArgs>>): Prisma__MaterialContentClient<$Result.GetResult<Prisma.$MaterialContentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MaterialContent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentFindFirstOrThrowArgs} args - Arguments to find a MaterialContent
     * @example
     * // Get one MaterialContent
     * const materialContent = await prisma.materialContent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaterialContentFindFirstOrThrowArgs>(args?: SelectSubset<T, MaterialContentFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaterialContentClient<$Result.GetResult<Prisma.$MaterialContentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MaterialContents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaterialContents
     * const materialContents = await prisma.materialContent.findMany()
     * 
     * // Get first 10 MaterialContents
     * const materialContents = await prisma.materialContent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialContentWithIdOnly = await prisma.materialContent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaterialContentFindManyArgs>(args?: SelectSubset<T, MaterialContentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialContentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MaterialContent.
     * @param {MaterialContentCreateArgs} args - Arguments to create a MaterialContent.
     * @example
     * // Create one MaterialContent
     * const MaterialContent = await prisma.materialContent.create({
     *   data: {
     *     // ... data to create a MaterialContent
     *   }
     * })
     * 
     */
    create<T extends MaterialContentCreateArgs>(args: SelectSubset<T, MaterialContentCreateArgs<ExtArgs>>): Prisma__MaterialContentClient<$Result.GetResult<Prisma.$MaterialContentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MaterialContents.
     * @param {MaterialContentCreateManyArgs} args - Arguments to create many MaterialContents.
     * @example
     * // Create many MaterialContents
     * const materialContent = await prisma.materialContent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaterialContentCreateManyArgs>(args?: SelectSubset<T, MaterialContentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MaterialContent.
     * @param {MaterialContentDeleteArgs} args - Arguments to delete one MaterialContent.
     * @example
     * // Delete one MaterialContent
     * const MaterialContent = await prisma.materialContent.delete({
     *   where: {
     *     // ... filter to delete one MaterialContent
     *   }
     * })
     * 
     */
    delete<T extends MaterialContentDeleteArgs>(args: SelectSubset<T, MaterialContentDeleteArgs<ExtArgs>>): Prisma__MaterialContentClient<$Result.GetResult<Prisma.$MaterialContentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MaterialContent.
     * @param {MaterialContentUpdateArgs} args - Arguments to update one MaterialContent.
     * @example
     * // Update one MaterialContent
     * const materialContent = await prisma.materialContent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaterialContentUpdateArgs>(args: SelectSubset<T, MaterialContentUpdateArgs<ExtArgs>>): Prisma__MaterialContentClient<$Result.GetResult<Prisma.$MaterialContentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MaterialContents.
     * @param {MaterialContentDeleteManyArgs} args - Arguments to filter MaterialContents to delete.
     * @example
     * // Delete a few MaterialContents
     * const { count } = await prisma.materialContent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaterialContentDeleteManyArgs>(args?: SelectSubset<T, MaterialContentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaterialContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaterialContents
     * const materialContent = await prisma.materialContent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaterialContentUpdateManyArgs>(args: SelectSubset<T, MaterialContentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MaterialContent.
     * @param {MaterialContentUpsertArgs} args - Arguments to update or create a MaterialContent.
     * @example
     * // Update or create a MaterialContent
     * const materialContent = await prisma.materialContent.upsert({
     *   create: {
     *     // ... data to create a MaterialContent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaterialContent we want to update
     *   }
     * })
     */
    upsert<T extends MaterialContentUpsertArgs>(args: SelectSubset<T, MaterialContentUpsertArgs<ExtArgs>>): Prisma__MaterialContentClient<$Result.GetResult<Prisma.$MaterialContentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MaterialContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentCountArgs} args - Arguments to filter MaterialContents to count.
     * @example
     * // Count the number of MaterialContents
     * const count = await prisma.materialContent.count({
     *   where: {
     *     // ... the filter for the MaterialContents we want to count
     *   }
     * })
    **/
    count<T extends MaterialContentCountArgs>(
      args?: Subset<T, MaterialContentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialContentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaterialContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialContentAggregateArgs>(args: Subset<T, MaterialContentAggregateArgs>): Prisma.PrismaPromise<GetMaterialContentAggregateType<T>>

    /**
     * Group by MaterialContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialContentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialContentGroupByArgs['orderBy'] }
        : { orderBy?: MaterialContentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialContentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialContentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaterialContent model
   */
  readonly fields: MaterialContentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaterialContent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterialContentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Type<T extends MaterialContentTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaterialContentTypeDefaultArgs<ExtArgs>>): Prisma__MaterialContentTypeClient<$Result.GetResult<Prisma.$MaterialContentTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    SyllabusContent<T extends SyllabusContentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SyllabusContentDefaultArgs<ExtArgs>>): Prisma__SyllabusContentClient<$Result.GetResult<Prisma.$SyllabusContentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Attachments<T extends MaterialContent$AttachmentsArgs<ExtArgs> = {}>(args?: Subset<T, MaterialContent$AttachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialContentAttachmentPayload<ExtArgs>, T, "findMany"> | Null>
    File<T extends MaterialContent$FileArgs<ExtArgs> = {}>(args?: Subset<T, MaterialContent$FileArgs<ExtArgs>>): Prisma__MaterialContentFileClient<$Result.GetResult<Prisma.$MaterialContentFilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    MaterialContentLearning<T extends MaterialContent$MaterialContentLearningArgs<ExtArgs> = {}>(args?: Subset<T, MaterialContent$MaterialContentLearningArgs<ExtArgs>>): Prisma__MaterialContentLearningClient<$Result.GetResult<Prisma.$MaterialContentLearningPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    MaterialContentTest<T extends MaterialContent$MaterialContentTestArgs<ExtArgs> = {}>(args?: Subset<T, MaterialContent$MaterialContentTestArgs<ExtArgs>>): Prisma__MaterialContentTestClient<$Result.GetResult<Prisma.$MaterialContentTestPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    CourseLogging<T extends MaterialContent$CourseLoggingArgs<ExtArgs> = {}>(args?: Subset<T, MaterialContent$CourseLoggingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseLoggingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaterialContent model
   */ 
  interface MaterialContentFieldRefs {
    readonly id: FieldRef<"MaterialContent", 'Int'>
    readonly title: FieldRef<"MaterialContent", 'String'>
    readonly materialContentTypeId: FieldRef<"MaterialContent", 'Int'>
    readonly order: FieldRef<"MaterialContent", 'Int'>
    readonly createdAt: FieldRef<"MaterialContent", 'DateTime'>
    readonly updatedAt: FieldRef<"MaterialContent", 'DateTime'>
    readonly slug: FieldRef<"MaterialContent", 'String'>
    readonly syllabusContentId: FieldRef<"MaterialContent", 'Int'>
    readonly estimatedTime: FieldRef<"MaterialContent", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * MaterialContent findUnique
   */
  export type MaterialContentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContent
     */
    select?: MaterialContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentInclude<ExtArgs> | null
    /**
     * Filter, which MaterialContent to fetch.
     */
    where: MaterialContentWhereUniqueInput
  }

  /**
   * MaterialContent findUniqueOrThrow
   */
  export type MaterialContentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContent
     */
    select?: MaterialContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentInclude<ExtArgs> | null
    /**
     * Filter, which MaterialContent to fetch.
     */
    where: MaterialContentWhereUniqueInput
  }

  /**
   * MaterialContent findFirst
   */
  export type MaterialContentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContent
     */
    select?: MaterialContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentInclude<ExtArgs> | null
    /**
     * Filter, which MaterialContent to fetch.
     */
    where?: MaterialContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialContents to fetch.
     */
    orderBy?: MaterialContentOrderByWithRelationInput | MaterialContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaterialContents.
     */
    cursor?: MaterialContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaterialContents.
     */
    distinct?: MaterialContentScalarFieldEnum | MaterialContentScalarFieldEnum[]
  }

  /**
   * MaterialContent findFirstOrThrow
   */
  export type MaterialContentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContent
     */
    select?: MaterialContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentInclude<ExtArgs> | null
    /**
     * Filter, which MaterialContent to fetch.
     */
    where?: MaterialContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialContents to fetch.
     */
    orderBy?: MaterialContentOrderByWithRelationInput | MaterialContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaterialContents.
     */
    cursor?: MaterialContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaterialContents.
     */
    distinct?: MaterialContentScalarFieldEnum | MaterialContentScalarFieldEnum[]
  }

  /**
   * MaterialContent findMany
   */
  export type MaterialContentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContent
     */
    select?: MaterialContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentInclude<ExtArgs> | null
    /**
     * Filter, which MaterialContents to fetch.
     */
    where?: MaterialContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialContents to fetch.
     */
    orderBy?: MaterialContentOrderByWithRelationInput | MaterialContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaterialContents.
     */
    cursor?: MaterialContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialContents.
     */
    skip?: number
    distinct?: MaterialContentScalarFieldEnum | MaterialContentScalarFieldEnum[]
  }

  /**
   * MaterialContent create
   */
  export type MaterialContentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContent
     */
    select?: MaterialContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentInclude<ExtArgs> | null
    /**
     * The data needed to create a MaterialContent.
     */
    data: XOR<MaterialContentCreateInput, MaterialContentUncheckedCreateInput>
  }

  /**
   * MaterialContent createMany
   */
  export type MaterialContentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaterialContents.
     */
    data: MaterialContentCreateManyInput | MaterialContentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MaterialContent update
   */
  export type MaterialContentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContent
     */
    select?: MaterialContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentInclude<ExtArgs> | null
    /**
     * The data needed to update a MaterialContent.
     */
    data: XOR<MaterialContentUpdateInput, MaterialContentUncheckedUpdateInput>
    /**
     * Choose, which MaterialContent to update.
     */
    where: MaterialContentWhereUniqueInput
  }

  /**
   * MaterialContent updateMany
   */
  export type MaterialContentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaterialContents.
     */
    data: XOR<MaterialContentUpdateManyMutationInput, MaterialContentUncheckedUpdateManyInput>
    /**
     * Filter which MaterialContents to update
     */
    where?: MaterialContentWhereInput
  }

  /**
   * MaterialContent upsert
   */
  export type MaterialContentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContent
     */
    select?: MaterialContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentInclude<ExtArgs> | null
    /**
     * The filter to search for the MaterialContent to update in case it exists.
     */
    where: MaterialContentWhereUniqueInput
    /**
     * In case the MaterialContent found by the `where` argument doesn't exist, create a new MaterialContent with this data.
     */
    create: XOR<MaterialContentCreateInput, MaterialContentUncheckedCreateInput>
    /**
     * In case the MaterialContent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialContentUpdateInput, MaterialContentUncheckedUpdateInput>
  }

  /**
   * MaterialContent delete
   */
  export type MaterialContentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContent
     */
    select?: MaterialContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentInclude<ExtArgs> | null
    /**
     * Filter which MaterialContent to delete.
     */
    where: MaterialContentWhereUniqueInput
  }

  /**
   * MaterialContent deleteMany
   */
  export type MaterialContentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaterialContents to delete
     */
    where?: MaterialContentWhereInput
  }

  /**
   * MaterialContent.Attachments
   */
  export type MaterialContent$AttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentAttachment
     */
    select?: MaterialContentAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentAttachmentInclude<ExtArgs> | null
    where?: MaterialContentAttachmentWhereInput
    orderBy?: MaterialContentAttachmentOrderByWithRelationInput | MaterialContentAttachmentOrderByWithRelationInput[]
    cursor?: MaterialContentAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialContentAttachmentScalarFieldEnum | MaterialContentAttachmentScalarFieldEnum[]
  }

  /**
   * MaterialContent.File
   */
  export type MaterialContent$FileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentFile
     */
    select?: MaterialContentFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentFileInclude<ExtArgs> | null
    where?: MaterialContentFileWhereInput
  }

  /**
   * MaterialContent.MaterialContentLearning
   */
  export type MaterialContent$MaterialContentLearningArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentLearning
     */
    select?: MaterialContentLearningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentLearningInclude<ExtArgs> | null
    where?: MaterialContentLearningWhereInput
  }

  /**
   * MaterialContent.MaterialContentTest
   */
  export type MaterialContent$MaterialContentTestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentTest
     */
    select?: MaterialContentTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentTestInclude<ExtArgs> | null
    where?: MaterialContentTestWhereInput
  }

  /**
   * MaterialContent.CourseLogging
   */
  export type MaterialContent$CourseLoggingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLogging
     */
    select?: CourseLoggingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLoggingInclude<ExtArgs> | null
    where?: CourseLoggingWhereInput
    orderBy?: CourseLoggingOrderByWithRelationInput | CourseLoggingOrderByWithRelationInput[]
    cursor?: CourseLoggingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseLoggingScalarFieldEnum | CourseLoggingScalarFieldEnum[]
  }

  /**
   * MaterialContent without action
   */
  export type MaterialContentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContent
     */
    select?: MaterialContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentInclude<ExtArgs> | null
  }


  /**
   * Model MaterialContentLearning
   */

  export type AggregateMaterialContentLearning = {
    _count: MaterialContentLearningCountAggregateOutputType | null
    _avg: MaterialContentLearningAvgAggregateOutputType | null
    _sum: MaterialContentLearningSumAggregateOutputType | null
    _min: MaterialContentLearningMinAggregateOutputType | null
    _max: MaterialContentLearningMaxAggregateOutputType | null
  }

  export type MaterialContentLearningAvgAggregateOutputType = {
    id: number | null
    materialContentId: number | null
  }

  export type MaterialContentLearningSumAggregateOutputType = {
    id: number | null
    materialContentId: number | null
  }

  export type MaterialContentLearningMinAggregateOutputType = {
    id: number | null
    materialContentId: number | null
    content: string | null
  }

  export type MaterialContentLearningMaxAggregateOutputType = {
    id: number | null
    materialContentId: number | null
    content: string | null
  }

  export type MaterialContentLearningCountAggregateOutputType = {
    id: number
    materialContentId: number
    content: number
    _all: number
  }


  export type MaterialContentLearningAvgAggregateInputType = {
    id?: true
    materialContentId?: true
  }

  export type MaterialContentLearningSumAggregateInputType = {
    id?: true
    materialContentId?: true
  }

  export type MaterialContentLearningMinAggregateInputType = {
    id?: true
    materialContentId?: true
    content?: true
  }

  export type MaterialContentLearningMaxAggregateInputType = {
    id?: true
    materialContentId?: true
    content?: true
  }

  export type MaterialContentLearningCountAggregateInputType = {
    id?: true
    materialContentId?: true
    content?: true
    _all?: true
  }

  export type MaterialContentLearningAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaterialContentLearning to aggregate.
     */
    where?: MaterialContentLearningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialContentLearnings to fetch.
     */
    orderBy?: MaterialContentLearningOrderByWithRelationInput | MaterialContentLearningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialContentLearningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialContentLearnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialContentLearnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaterialContentLearnings
    **/
    _count?: true | MaterialContentLearningCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialContentLearningAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialContentLearningSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialContentLearningMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialContentLearningMaxAggregateInputType
  }

  export type GetMaterialContentLearningAggregateType<T extends MaterialContentLearningAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterialContentLearning]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterialContentLearning[P]>
      : GetScalarType<T[P], AggregateMaterialContentLearning[P]>
  }




  export type MaterialContentLearningGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialContentLearningWhereInput
    orderBy?: MaterialContentLearningOrderByWithAggregationInput | MaterialContentLearningOrderByWithAggregationInput[]
    by: MaterialContentLearningScalarFieldEnum[] | MaterialContentLearningScalarFieldEnum
    having?: MaterialContentLearningScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialContentLearningCountAggregateInputType | true
    _avg?: MaterialContentLearningAvgAggregateInputType
    _sum?: MaterialContentLearningSumAggregateInputType
    _min?: MaterialContentLearningMinAggregateInputType
    _max?: MaterialContentLearningMaxAggregateInputType
  }

  export type MaterialContentLearningGroupByOutputType = {
    id: number
    materialContentId: number
    content: string
    _count: MaterialContentLearningCountAggregateOutputType | null
    _avg: MaterialContentLearningAvgAggregateOutputType | null
    _sum: MaterialContentLearningSumAggregateOutputType | null
    _min: MaterialContentLearningMinAggregateOutputType | null
    _max: MaterialContentLearningMaxAggregateOutputType | null
  }

  type GetMaterialContentLearningGroupByPayload<T extends MaterialContentLearningGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialContentLearningGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialContentLearningGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialContentLearningGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialContentLearningGroupByOutputType[P]>
        }
      >
    >


  export type MaterialContentLearningSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materialContentId?: boolean
    content?: boolean
    MaterialContent?: boolean | MaterialContentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materialContentLearning"]>


  export type MaterialContentLearningSelectScalar = {
    id?: boolean
    materialContentId?: boolean
    content?: boolean
  }

  export type MaterialContentLearningInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MaterialContent?: boolean | MaterialContentDefaultArgs<ExtArgs>
  }

  export type $MaterialContentLearningPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaterialContentLearning"
    objects: {
      MaterialContent: Prisma.$MaterialContentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      materialContentId: number
      content: string
    }, ExtArgs["result"]["materialContentLearning"]>
    composites: {}
  }

  type MaterialContentLearningGetPayload<S extends boolean | null | undefined | MaterialContentLearningDefaultArgs> = $Result.GetResult<Prisma.$MaterialContentLearningPayload, S>

  type MaterialContentLearningCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MaterialContentLearningFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MaterialContentLearningCountAggregateInputType | true
    }

  export interface MaterialContentLearningDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaterialContentLearning'], meta: { name: 'MaterialContentLearning' } }
    /**
     * Find zero or one MaterialContentLearning that matches the filter.
     * @param {MaterialContentLearningFindUniqueArgs} args - Arguments to find a MaterialContentLearning
     * @example
     * // Get one MaterialContentLearning
     * const materialContentLearning = await prisma.materialContentLearning.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaterialContentLearningFindUniqueArgs>(args: SelectSubset<T, MaterialContentLearningFindUniqueArgs<ExtArgs>>): Prisma__MaterialContentLearningClient<$Result.GetResult<Prisma.$MaterialContentLearningPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MaterialContentLearning that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MaterialContentLearningFindUniqueOrThrowArgs} args - Arguments to find a MaterialContentLearning
     * @example
     * // Get one MaterialContentLearning
     * const materialContentLearning = await prisma.materialContentLearning.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaterialContentLearningFindUniqueOrThrowArgs>(args: SelectSubset<T, MaterialContentLearningFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaterialContentLearningClient<$Result.GetResult<Prisma.$MaterialContentLearningPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MaterialContentLearning that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentLearningFindFirstArgs} args - Arguments to find a MaterialContentLearning
     * @example
     * // Get one MaterialContentLearning
     * const materialContentLearning = await prisma.materialContentLearning.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaterialContentLearningFindFirstArgs>(args?: SelectSubset<T, MaterialContentLearningFindFirstArgs<ExtArgs>>): Prisma__MaterialContentLearningClient<$Result.GetResult<Prisma.$MaterialContentLearningPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MaterialContentLearning that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentLearningFindFirstOrThrowArgs} args - Arguments to find a MaterialContentLearning
     * @example
     * // Get one MaterialContentLearning
     * const materialContentLearning = await prisma.materialContentLearning.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaterialContentLearningFindFirstOrThrowArgs>(args?: SelectSubset<T, MaterialContentLearningFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaterialContentLearningClient<$Result.GetResult<Prisma.$MaterialContentLearningPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MaterialContentLearnings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentLearningFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaterialContentLearnings
     * const materialContentLearnings = await prisma.materialContentLearning.findMany()
     * 
     * // Get first 10 MaterialContentLearnings
     * const materialContentLearnings = await prisma.materialContentLearning.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialContentLearningWithIdOnly = await prisma.materialContentLearning.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaterialContentLearningFindManyArgs>(args?: SelectSubset<T, MaterialContentLearningFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialContentLearningPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MaterialContentLearning.
     * @param {MaterialContentLearningCreateArgs} args - Arguments to create a MaterialContentLearning.
     * @example
     * // Create one MaterialContentLearning
     * const MaterialContentLearning = await prisma.materialContentLearning.create({
     *   data: {
     *     // ... data to create a MaterialContentLearning
     *   }
     * })
     * 
     */
    create<T extends MaterialContentLearningCreateArgs>(args: SelectSubset<T, MaterialContentLearningCreateArgs<ExtArgs>>): Prisma__MaterialContentLearningClient<$Result.GetResult<Prisma.$MaterialContentLearningPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MaterialContentLearnings.
     * @param {MaterialContentLearningCreateManyArgs} args - Arguments to create many MaterialContentLearnings.
     * @example
     * // Create many MaterialContentLearnings
     * const materialContentLearning = await prisma.materialContentLearning.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaterialContentLearningCreateManyArgs>(args?: SelectSubset<T, MaterialContentLearningCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MaterialContentLearning.
     * @param {MaterialContentLearningDeleteArgs} args - Arguments to delete one MaterialContentLearning.
     * @example
     * // Delete one MaterialContentLearning
     * const MaterialContentLearning = await prisma.materialContentLearning.delete({
     *   where: {
     *     // ... filter to delete one MaterialContentLearning
     *   }
     * })
     * 
     */
    delete<T extends MaterialContentLearningDeleteArgs>(args: SelectSubset<T, MaterialContentLearningDeleteArgs<ExtArgs>>): Prisma__MaterialContentLearningClient<$Result.GetResult<Prisma.$MaterialContentLearningPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MaterialContentLearning.
     * @param {MaterialContentLearningUpdateArgs} args - Arguments to update one MaterialContentLearning.
     * @example
     * // Update one MaterialContentLearning
     * const materialContentLearning = await prisma.materialContentLearning.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaterialContentLearningUpdateArgs>(args: SelectSubset<T, MaterialContentLearningUpdateArgs<ExtArgs>>): Prisma__MaterialContentLearningClient<$Result.GetResult<Prisma.$MaterialContentLearningPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MaterialContentLearnings.
     * @param {MaterialContentLearningDeleteManyArgs} args - Arguments to filter MaterialContentLearnings to delete.
     * @example
     * // Delete a few MaterialContentLearnings
     * const { count } = await prisma.materialContentLearning.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaterialContentLearningDeleteManyArgs>(args?: SelectSubset<T, MaterialContentLearningDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaterialContentLearnings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentLearningUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaterialContentLearnings
     * const materialContentLearning = await prisma.materialContentLearning.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaterialContentLearningUpdateManyArgs>(args: SelectSubset<T, MaterialContentLearningUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MaterialContentLearning.
     * @param {MaterialContentLearningUpsertArgs} args - Arguments to update or create a MaterialContentLearning.
     * @example
     * // Update or create a MaterialContentLearning
     * const materialContentLearning = await prisma.materialContentLearning.upsert({
     *   create: {
     *     // ... data to create a MaterialContentLearning
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaterialContentLearning we want to update
     *   }
     * })
     */
    upsert<T extends MaterialContentLearningUpsertArgs>(args: SelectSubset<T, MaterialContentLearningUpsertArgs<ExtArgs>>): Prisma__MaterialContentLearningClient<$Result.GetResult<Prisma.$MaterialContentLearningPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MaterialContentLearnings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentLearningCountArgs} args - Arguments to filter MaterialContentLearnings to count.
     * @example
     * // Count the number of MaterialContentLearnings
     * const count = await prisma.materialContentLearning.count({
     *   where: {
     *     // ... the filter for the MaterialContentLearnings we want to count
     *   }
     * })
    **/
    count<T extends MaterialContentLearningCountArgs>(
      args?: Subset<T, MaterialContentLearningCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialContentLearningCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaterialContentLearning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentLearningAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialContentLearningAggregateArgs>(args: Subset<T, MaterialContentLearningAggregateArgs>): Prisma.PrismaPromise<GetMaterialContentLearningAggregateType<T>>

    /**
     * Group by MaterialContentLearning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentLearningGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialContentLearningGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialContentLearningGroupByArgs['orderBy'] }
        : { orderBy?: MaterialContentLearningGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialContentLearningGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialContentLearningGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaterialContentLearning model
   */
  readonly fields: MaterialContentLearningFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaterialContentLearning.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterialContentLearningClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    MaterialContent<T extends MaterialContentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaterialContentDefaultArgs<ExtArgs>>): Prisma__MaterialContentClient<$Result.GetResult<Prisma.$MaterialContentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaterialContentLearning model
   */ 
  interface MaterialContentLearningFieldRefs {
    readonly id: FieldRef<"MaterialContentLearning", 'Int'>
    readonly materialContentId: FieldRef<"MaterialContentLearning", 'Int'>
    readonly content: FieldRef<"MaterialContentLearning", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MaterialContentLearning findUnique
   */
  export type MaterialContentLearningFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentLearning
     */
    select?: MaterialContentLearningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentLearningInclude<ExtArgs> | null
    /**
     * Filter, which MaterialContentLearning to fetch.
     */
    where: MaterialContentLearningWhereUniqueInput
  }

  /**
   * MaterialContentLearning findUniqueOrThrow
   */
  export type MaterialContentLearningFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentLearning
     */
    select?: MaterialContentLearningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentLearningInclude<ExtArgs> | null
    /**
     * Filter, which MaterialContentLearning to fetch.
     */
    where: MaterialContentLearningWhereUniqueInput
  }

  /**
   * MaterialContentLearning findFirst
   */
  export type MaterialContentLearningFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentLearning
     */
    select?: MaterialContentLearningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentLearningInclude<ExtArgs> | null
    /**
     * Filter, which MaterialContentLearning to fetch.
     */
    where?: MaterialContentLearningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialContentLearnings to fetch.
     */
    orderBy?: MaterialContentLearningOrderByWithRelationInput | MaterialContentLearningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaterialContentLearnings.
     */
    cursor?: MaterialContentLearningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialContentLearnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialContentLearnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaterialContentLearnings.
     */
    distinct?: MaterialContentLearningScalarFieldEnum | MaterialContentLearningScalarFieldEnum[]
  }

  /**
   * MaterialContentLearning findFirstOrThrow
   */
  export type MaterialContentLearningFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentLearning
     */
    select?: MaterialContentLearningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentLearningInclude<ExtArgs> | null
    /**
     * Filter, which MaterialContentLearning to fetch.
     */
    where?: MaterialContentLearningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialContentLearnings to fetch.
     */
    orderBy?: MaterialContentLearningOrderByWithRelationInput | MaterialContentLearningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaterialContentLearnings.
     */
    cursor?: MaterialContentLearningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialContentLearnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialContentLearnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaterialContentLearnings.
     */
    distinct?: MaterialContentLearningScalarFieldEnum | MaterialContentLearningScalarFieldEnum[]
  }

  /**
   * MaterialContentLearning findMany
   */
  export type MaterialContentLearningFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentLearning
     */
    select?: MaterialContentLearningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentLearningInclude<ExtArgs> | null
    /**
     * Filter, which MaterialContentLearnings to fetch.
     */
    where?: MaterialContentLearningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialContentLearnings to fetch.
     */
    orderBy?: MaterialContentLearningOrderByWithRelationInput | MaterialContentLearningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaterialContentLearnings.
     */
    cursor?: MaterialContentLearningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialContentLearnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialContentLearnings.
     */
    skip?: number
    distinct?: MaterialContentLearningScalarFieldEnum | MaterialContentLearningScalarFieldEnum[]
  }

  /**
   * MaterialContentLearning create
   */
  export type MaterialContentLearningCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentLearning
     */
    select?: MaterialContentLearningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentLearningInclude<ExtArgs> | null
    /**
     * The data needed to create a MaterialContentLearning.
     */
    data: XOR<MaterialContentLearningCreateInput, MaterialContentLearningUncheckedCreateInput>
  }

  /**
   * MaterialContentLearning createMany
   */
  export type MaterialContentLearningCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaterialContentLearnings.
     */
    data: MaterialContentLearningCreateManyInput | MaterialContentLearningCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MaterialContentLearning update
   */
  export type MaterialContentLearningUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentLearning
     */
    select?: MaterialContentLearningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentLearningInclude<ExtArgs> | null
    /**
     * The data needed to update a MaterialContentLearning.
     */
    data: XOR<MaterialContentLearningUpdateInput, MaterialContentLearningUncheckedUpdateInput>
    /**
     * Choose, which MaterialContentLearning to update.
     */
    where: MaterialContentLearningWhereUniqueInput
  }

  /**
   * MaterialContentLearning updateMany
   */
  export type MaterialContentLearningUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaterialContentLearnings.
     */
    data: XOR<MaterialContentLearningUpdateManyMutationInput, MaterialContentLearningUncheckedUpdateManyInput>
    /**
     * Filter which MaterialContentLearnings to update
     */
    where?: MaterialContentLearningWhereInput
  }

  /**
   * MaterialContentLearning upsert
   */
  export type MaterialContentLearningUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentLearning
     */
    select?: MaterialContentLearningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentLearningInclude<ExtArgs> | null
    /**
     * The filter to search for the MaterialContentLearning to update in case it exists.
     */
    where: MaterialContentLearningWhereUniqueInput
    /**
     * In case the MaterialContentLearning found by the `where` argument doesn't exist, create a new MaterialContentLearning with this data.
     */
    create: XOR<MaterialContentLearningCreateInput, MaterialContentLearningUncheckedCreateInput>
    /**
     * In case the MaterialContentLearning was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialContentLearningUpdateInput, MaterialContentLearningUncheckedUpdateInput>
  }

  /**
   * MaterialContentLearning delete
   */
  export type MaterialContentLearningDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentLearning
     */
    select?: MaterialContentLearningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentLearningInclude<ExtArgs> | null
    /**
     * Filter which MaterialContentLearning to delete.
     */
    where: MaterialContentLearningWhereUniqueInput
  }

  /**
   * MaterialContentLearning deleteMany
   */
  export type MaterialContentLearningDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaterialContentLearnings to delete
     */
    where?: MaterialContentLearningWhereInput
  }

  /**
   * MaterialContentLearning without action
   */
  export type MaterialContentLearningDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentLearning
     */
    select?: MaterialContentLearningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentLearningInclude<ExtArgs> | null
  }


  /**
   * Model MaterialContentTest
   */

  export type AggregateMaterialContentTest = {
    _count: MaterialContentTestCountAggregateOutputType | null
    _avg: MaterialContentTestAvgAggregateOutputType | null
    _sum: MaterialContentTestSumAggregateOutputType | null
    _min: MaterialContentTestMinAggregateOutputType | null
    _max: MaterialContentTestMaxAggregateOutputType | null
  }

  export type MaterialContentTestAvgAggregateOutputType = {
    id: number | null
    materialContentId: number | null
  }

  export type MaterialContentTestSumAggregateOutputType = {
    id: number | null
    materialContentId: number | null
  }

  export type MaterialContentTestMinAggregateOutputType = {
    id: number | null
    materialContentId: number | null
  }

  export type MaterialContentTestMaxAggregateOutputType = {
    id: number | null
    materialContentId: number | null
  }

  export type MaterialContentTestCountAggregateOutputType = {
    id: number
    materialContentId: number
    _all: number
  }


  export type MaterialContentTestAvgAggregateInputType = {
    id?: true
    materialContentId?: true
  }

  export type MaterialContentTestSumAggregateInputType = {
    id?: true
    materialContentId?: true
  }

  export type MaterialContentTestMinAggregateInputType = {
    id?: true
    materialContentId?: true
  }

  export type MaterialContentTestMaxAggregateInputType = {
    id?: true
    materialContentId?: true
  }

  export type MaterialContentTestCountAggregateInputType = {
    id?: true
    materialContentId?: true
    _all?: true
  }

  export type MaterialContentTestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaterialContentTest to aggregate.
     */
    where?: MaterialContentTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialContentTests to fetch.
     */
    orderBy?: MaterialContentTestOrderByWithRelationInput | MaterialContentTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialContentTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialContentTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialContentTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaterialContentTests
    **/
    _count?: true | MaterialContentTestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialContentTestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialContentTestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialContentTestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialContentTestMaxAggregateInputType
  }

  export type GetMaterialContentTestAggregateType<T extends MaterialContentTestAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterialContentTest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterialContentTest[P]>
      : GetScalarType<T[P], AggregateMaterialContentTest[P]>
  }




  export type MaterialContentTestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialContentTestWhereInput
    orderBy?: MaterialContentTestOrderByWithAggregationInput | MaterialContentTestOrderByWithAggregationInput[]
    by: MaterialContentTestScalarFieldEnum[] | MaterialContentTestScalarFieldEnum
    having?: MaterialContentTestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialContentTestCountAggregateInputType | true
    _avg?: MaterialContentTestAvgAggregateInputType
    _sum?: MaterialContentTestSumAggregateInputType
    _min?: MaterialContentTestMinAggregateInputType
    _max?: MaterialContentTestMaxAggregateInputType
  }

  export type MaterialContentTestGroupByOutputType = {
    id: number
    materialContentId: number
    _count: MaterialContentTestCountAggregateOutputType | null
    _avg: MaterialContentTestAvgAggregateOutputType | null
    _sum: MaterialContentTestSumAggregateOutputType | null
    _min: MaterialContentTestMinAggregateOutputType | null
    _max: MaterialContentTestMaxAggregateOutputType | null
  }

  type GetMaterialContentTestGroupByPayload<T extends MaterialContentTestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialContentTestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialContentTestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialContentTestGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialContentTestGroupByOutputType[P]>
        }
      >
    >


  export type MaterialContentTestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materialContentId?: boolean
    MaterialContent?: boolean | MaterialContentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materialContentTest"]>


  export type MaterialContentTestSelectScalar = {
    id?: boolean
    materialContentId?: boolean
  }

  export type MaterialContentTestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MaterialContent?: boolean | MaterialContentDefaultArgs<ExtArgs>
  }

  export type $MaterialContentTestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaterialContentTest"
    objects: {
      MaterialContent: Prisma.$MaterialContentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      materialContentId: number
    }, ExtArgs["result"]["materialContentTest"]>
    composites: {}
  }

  type MaterialContentTestGetPayload<S extends boolean | null | undefined | MaterialContentTestDefaultArgs> = $Result.GetResult<Prisma.$MaterialContentTestPayload, S>

  type MaterialContentTestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MaterialContentTestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MaterialContentTestCountAggregateInputType | true
    }

  export interface MaterialContentTestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaterialContentTest'], meta: { name: 'MaterialContentTest' } }
    /**
     * Find zero or one MaterialContentTest that matches the filter.
     * @param {MaterialContentTestFindUniqueArgs} args - Arguments to find a MaterialContentTest
     * @example
     * // Get one MaterialContentTest
     * const materialContentTest = await prisma.materialContentTest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaterialContentTestFindUniqueArgs>(args: SelectSubset<T, MaterialContentTestFindUniqueArgs<ExtArgs>>): Prisma__MaterialContentTestClient<$Result.GetResult<Prisma.$MaterialContentTestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MaterialContentTest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MaterialContentTestFindUniqueOrThrowArgs} args - Arguments to find a MaterialContentTest
     * @example
     * // Get one MaterialContentTest
     * const materialContentTest = await prisma.materialContentTest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaterialContentTestFindUniqueOrThrowArgs>(args: SelectSubset<T, MaterialContentTestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaterialContentTestClient<$Result.GetResult<Prisma.$MaterialContentTestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MaterialContentTest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentTestFindFirstArgs} args - Arguments to find a MaterialContentTest
     * @example
     * // Get one MaterialContentTest
     * const materialContentTest = await prisma.materialContentTest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaterialContentTestFindFirstArgs>(args?: SelectSubset<T, MaterialContentTestFindFirstArgs<ExtArgs>>): Prisma__MaterialContentTestClient<$Result.GetResult<Prisma.$MaterialContentTestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MaterialContentTest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentTestFindFirstOrThrowArgs} args - Arguments to find a MaterialContentTest
     * @example
     * // Get one MaterialContentTest
     * const materialContentTest = await prisma.materialContentTest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaterialContentTestFindFirstOrThrowArgs>(args?: SelectSubset<T, MaterialContentTestFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaterialContentTestClient<$Result.GetResult<Prisma.$MaterialContentTestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MaterialContentTests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentTestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaterialContentTests
     * const materialContentTests = await prisma.materialContentTest.findMany()
     * 
     * // Get first 10 MaterialContentTests
     * const materialContentTests = await prisma.materialContentTest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialContentTestWithIdOnly = await prisma.materialContentTest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaterialContentTestFindManyArgs>(args?: SelectSubset<T, MaterialContentTestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialContentTestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MaterialContentTest.
     * @param {MaterialContentTestCreateArgs} args - Arguments to create a MaterialContentTest.
     * @example
     * // Create one MaterialContentTest
     * const MaterialContentTest = await prisma.materialContentTest.create({
     *   data: {
     *     // ... data to create a MaterialContentTest
     *   }
     * })
     * 
     */
    create<T extends MaterialContentTestCreateArgs>(args: SelectSubset<T, MaterialContentTestCreateArgs<ExtArgs>>): Prisma__MaterialContentTestClient<$Result.GetResult<Prisma.$MaterialContentTestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MaterialContentTests.
     * @param {MaterialContentTestCreateManyArgs} args - Arguments to create many MaterialContentTests.
     * @example
     * // Create many MaterialContentTests
     * const materialContentTest = await prisma.materialContentTest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaterialContentTestCreateManyArgs>(args?: SelectSubset<T, MaterialContentTestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MaterialContentTest.
     * @param {MaterialContentTestDeleteArgs} args - Arguments to delete one MaterialContentTest.
     * @example
     * // Delete one MaterialContentTest
     * const MaterialContentTest = await prisma.materialContentTest.delete({
     *   where: {
     *     // ... filter to delete one MaterialContentTest
     *   }
     * })
     * 
     */
    delete<T extends MaterialContentTestDeleteArgs>(args: SelectSubset<T, MaterialContentTestDeleteArgs<ExtArgs>>): Prisma__MaterialContentTestClient<$Result.GetResult<Prisma.$MaterialContentTestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MaterialContentTest.
     * @param {MaterialContentTestUpdateArgs} args - Arguments to update one MaterialContentTest.
     * @example
     * // Update one MaterialContentTest
     * const materialContentTest = await prisma.materialContentTest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaterialContentTestUpdateArgs>(args: SelectSubset<T, MaterialContentTestUpdateArgs<ExtArgs>>): Prisma__MaterialContentTestClient<$Result.GetResult<Prisma.$MaterialContentTestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MaterialContentTests.
     * @param {MaterialContentTestDeleteManyArgs} args - Arguments to filter MaterialContentTests to delete.
     * @example
     * // Delete a few MaterialContentTests
     * const { count } = await prisma.materialContentTest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaterialContentTestDeleteManyArgs>(args?: SelectSubset<T, MaterialContentTestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaterialContentTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentTestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaterialContentTests
     * const materialContentTest = await prisma.materialContentTest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaterialContentTestUpdateManyArgs>(args: SelectSubset<T, MaterialContentTestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MaterialContentTest.
     * @param {MaterialContentTestUpsertArgs} args - Arguments to update or create a MaterialContentTest.
     * @example
     * // Update or create a MaterialContentTest
     * const materialContentTest = await prisma.materialContentTest.upsert({
     *   create: {
     *     // ... data to create a MaterialContentTest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaterialContentTest we want to update
     *   }
     * })
     */
    upsert<T extends MaterialContentTestUpsertArgs>(args: SelectSubset<T, MaterialContentTestUpsertArgs<ExtArgs>>): Prisma__MaterialContentTestClient<$Result.GetResult<Prisma.$MaterialContentTestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MaterialContentTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentTestCountArgs} args - Arguments to filter MaterialContentTests to count.
     * @example
     * // Count the number of MaterialContentTests
     * const count = await prisma.materialContentTest.count({
     *   where: {
     *     // ... the filter for the MaterialContentTests we want to count
     *   }
     * })
    **/
    count<T extends MaterialContentTestCountArgs>(
      args?: Subset<T, MaterialContentTestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialContentTestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaterialContentTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentTestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialContentTestAggregateArgs>(args: Subset<T, MaterialContentTestAggregateArgs>): Prisma.PrismaPromise<GetMaterialContentTestAggregateType<T>>

    /**
     * Group by MaterialContentTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentTestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialContentTestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialContentTestGroupByArgs['orderBy'] }
        : { orderBy?: MaterialContentTestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialContentTestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialContentTestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaterialContentTest model
   */
  readonly fields: MaterialContentTestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaterialContentTest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterialContentTestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    MaterialContent<T extends MaterialContentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaterialContentDefaultArgs<ExtArgs>>): Prisma__MaterialContentClient<$Result.GetResult<Prisma.$MaterialContentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaterialContentTest model
   */ 
  interface MaterialContentTestFieldRefs {
    readonly id: FieldRef<"MaterialContentTest", 'Int'>
    readonly materialContentId: FieldRef<"MaterialContentTest", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * MaterialContentTest findUnique
   */
  export type MaterialContentTestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentTest
     */
    select?: MaterialContentTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentTestInclude<ExtArgs> | null
    /**
     * Filter, which MaterialContentTest to fetch.
     */
    where: MaterialContentTestWhereUniqueInput
  }

  /**
   * MaterialContentTest findUniqueOrThrow
   */
  export type MaterialContentTestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentTest
     */
    select?: MaterialContentTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentTestInclude<ExtArgs> | null
    /**
     * Filter, which MaterialContentTest to fetch.
     */
    where: MaterialContentTestWhereUniqueInput
  }

  /**
   * MaterialContentTest findFirst
   */
  export type MaterialContentTestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentTest
     */
    select?: MaterialContentTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentTestInclude<ExtArgs> | null
    /**
     * Filter, which MaterialContentTest to fetch.
     */
    where?: MaterialContentTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialContentTests to fetch.
     */
    orderBy?: MaterialContentTestOrderByWithRelationInput | MaterialContentTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaterialContentTests.
     */
    cursor?: MaterialContentTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialContentTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialContentTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaterialContentTests.
     */
    distinct?: MaterialContentTestScalarFieldEnum | MaterialContentTestScalarFieldEnum[]
  }

  /**
   * MaterialContentTest findFirstOrThrow
   */
  export type MaterialContentTestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentTest
     */
    select?: MaterialContentTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentTestInclude<ExtArgs> | null
    /**
     * Filter, which MaterialContentTest to fetch.
     */
    where?: MaterialContentTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialContentTests to fetch.
     */
    orderBy?: MaterialContentTestOrderByWithRelationInput | MaterialContentTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaterialContentTests.
     */
    cursor?: MaterialContentTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialContentTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialContentTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaterialContentTests.
     */
    distinct?: MaterialContentTestScalarFieldEnum | MaterialContentTestScalarFieldEnum[]
  }

  /**
   * MaterialContentTest findMany
   */
  export type MaterialContentTestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentTest
     */
    select?: MaterialContentTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentTestInclude<ExtArgs> | null
    /**
     * Filter, which MaterialContentTests to fetch.
     */
    where?: MaterialContentTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialContentTests to fetch.
     */
    orderBy?: MaterialContentTestOrderByWithRelationInput | MaterialContentTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaterialContentTests.
     */
    cursor?: MaterialContentTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialContentTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialContentTests.
     */
    skip?: number
    distinct?: MaterialContentTestScalarFieldEnum | MaterialContentTestScalarFieldEnum[]
  }

  /**
   * MaterialContentTest create
   */
  export type MaterialContentTestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentTest
     */
    select?: MaterialContentTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentTestInclude<ExtArgs> | null
    /**
     * The data needed to create a MaterialContentTest.
     */
    data: XOR<MaterialContentTestCreateInput, MaterialContentTestUncheckedCreateInput>
  }

  /**
   * MaterialContentTest createMany
   */
  export type MaterialContentTestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaterialContentTests.
     */
    data: MaterialContentTestCreateManyInput | MaterialContentTestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MaterialContentTest update
   */
  export type MaterialContentTestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentTest
     */
    select?: MaterialContentTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentTestInclude<ExtArgs> | null
    /**
     * The data needed to update a MaterialContentTest.
     */
    data: XOR<MaterialContentTestUpdateInput, MaterialContentTestUncheckedUpdateInput>
    /**
     * Choose, which MaterialContentTest to update.
     */
    where: MaterialContentTestWhereUniqueInput
  }

  /**
   * MaterialContentTest updateMany
   */
  export type MaterialContentTestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaterialContentTests.
     */
    data: XOR<MaterialContentTestUpdateManyMutationInput, MaterialContentTestUncheckedUpdateManyInput>
    /**
     * Filter which MaterialContentTests to update
     */
    where?: MaterialContentTestWhereInput
  }

  /**
   * MaterialContentTest upsert
   */
  export type MaterialContentTestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentTest
     */
    select?: MaterialContentTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentTestInclude<ExtArgs> | null
    /**
     * The filter to search for the MaterialContentTest to update in case it exists.
     */
    where: MaterialContentTestWhereUniqueInput
    /**
     * In case the MaterialContentTest found by the `where` argument doesn't exist, create a new MaterialContentTest with this data.
     */
    create: XOR<MaterialContentTestCreateInput, MaterialContentTestUncheckedCreateInput>
    /**
     * In case the MaterialContentTest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialContentTestUpdateInput, MaterialContentTestUncheckedUpdateInput>
  }

  /**
   * MaterialContentTest delete
   */
  export type MaterialContentTestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentTest
     */
    select?: MaterialContentTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentTestInclude<ExtArgs> | null
    /**
     * Filter which MaterialContentTest to delete.
     */
    where: MaterialContentTestWhereUniqueInput
  }

  /**
   * MaterialContentTest deleteMany
   */
  export type MaterialContentTestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaterialContentTests to delete
     */
    where?: MaterialContentTestWhereInput
  }

  /**
   * MaterialContentTest without action
   */
  export type MaterialContentTestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentTest
     */
    select?: MaterialContentTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentTestInclude<ExtArgs> | null
  }


  /**
   * Model MaterialContentFile
   */

  export type AggregateMaterialContentFile = {
    _count: MaterialContentFileCountAggregateOutputType | null
    _avg: MaterialContentFileAvgAggregateOutputType | null
    _sum: MaterialContentFileSumAggregateOutputType | null
    _min: MaterialContentFileMinAggregateOutputType | null
    _max: MaterialContentFileMaxAggregateOutputType | null
  }

  export type MaterialContentFileAvgAggregateOutputType = {
    id: number | null
    materialContentId: number | null
  }

  export type MaterialContentFileSumAggregateOutputType = {
    id: number | null
    materialContentId: number | null
  }

  export type MaterialContentFileMinAggregateOutputType = {
    id: number | null
    materialContentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaterialContentFileMaxAggregateOutputType = {
    id: number | null
    materialContentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaterialContentFileCountAggregateOutputType = {
    id: number
    materialContentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MaterialContentFileAvgAggregateInputType = {
    id?: true
    materialContentId?: true
  }

  export type MaterialContentFileSumAggregateInputType = {
    id?: true
    materialContentId?: true
  }

  export type MaterialContentFileMinAggregateInputType = {
    id?: true
    materialContentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaterialContentFileMaxAggregateInputType = {
    id?: true
    materialContentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaterialContentFileCountAggregateInputType = {
    id?: true
    materialContentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MaterialContentFileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaterialContentFile to aggregate.
     */
    where?: MaterialContentFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialContentFiles to fetch.
     */
    orderBy?: MaterialContentFileOrderByWithRelationInput | MaterialContentFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialContentFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialContentFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialContentFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaterialContentFiles
    **/
    _count?: true | MaterialContentFileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialContentFileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialContentFileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialContentFileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialContentFileMaxAggregateInputType
  }

  export type GetMaterialContentFileAggregateType<T extends MaterialContentFileAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterialContentFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterialContentFile[P]>
      : GetScalarType<T[P], AggregateMaterialContentFile[P]>
  }




  export type MaterialContentFileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialContentFileWhereInput
    orderBy?: MaterialContentFileOrderByWithAggregationInput | MaterialContentFileOrderByWithAggregationInput[]
    by: MaterialContentFileScalarFieldEnum[] | MaterialContentFileScalarFieldEnum
    having?: MaterialContentFileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialContentFileCountAggregateInputType | true
    _avg?: MaterialContentFileAvgAggregateInputType
    _sum?: MaterialContentFileSumAggregateInputType
    _min?: MaterialContentFileMinAggregateInputType
    _max?: MaterialContentFileMaxAggregateInputType
  }

  export type MaterialContentFileGroupByOutputType = {
    id: number
    materialContentId: number
    createdAt: Date
    updatedAt: Date
    _count: MaterialContentFileCountAggregateOutputType | null
    _avg: MaterialContentFileAvgAggregateOutputType | null
    _sum: MaterialContentFileSumAggregateOutputType | null
    _min: MaterialContentFileMinAggregateOutputType | null
    _max: MaterialContentFileMaxAggregateOutputType | null
  }

  type GetMaterialContentFileGroupByPayload<T extends MaterialContentFileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialContentFileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialContentFileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialContentFileGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialContentFileGroupByOutputType[P]>
        }
      >
    >


  export type MaterialContentFileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materialContentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    materialContent?: boolean | MaterialContentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materialContentFile"]>


  export type MaterialContentFileSelectScalar = {
    id?: boolean
    materialContentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MaterialContentFileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materialContent?: boolean | MaterialContentDefaultArgs<ExtArgs>
  }

  export type $MaterialContentFilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaterialContentFile"
    objects: {
      materialContent: Prisma.$MaterialContentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      materialContentId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["materialContentFile"]>
    composites: {}
  }

  type MaterialContentFileGetPayload<S extends boolean | null | undefined | MaterialContentFileDefaultArgs> = $Result.GetResult<Prisma.$MaterialContentFilePayload, S>

  type MaterialContentFileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MaterialContentFileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MaterialContentFileCountAggregateInputType | true
    }

  export interface MaterialContentFileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaterialContentFile'], meta: { name: 'MaterialContentFile' } }
    /**
     * Find zero or one MaterialContentFile that matches the filter.
     * @param {MaterialContentFileFindUniqueArgs} args - Arguments to find a MaterialContentFile
     * @example
     * // Get one MaterialContentFile
     * const materialContentFile = await prisma.materialContentFile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaterialContentFileFindUniqueArgs>(args: SelectSubset<T, MaterialContentFileFindUniqueArgs<ExtArgs>>): Prisma__MaterialContentFileClient<$Result.GetResult<Prisma.$MaterialContentFilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MaterialContentFile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MaterialContentFileFindUniqueOrThrowArgs} args - Arguments to find a MaterialContentFile
     * @example
     * // Get one MaterialContentFile
     * const materialContentFile = await prisma.materialContentFile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaterialContentFileFindUniqueOrThrowArgs>(args: SelectSubset<T, MaterialContentFileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaterialContentFileClient<$Result.GetResult<Prisma.$MaterialContentFilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MaterialContentFile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentFileFindFirstArgs} args - Arguments to find a MaterialContentFile
     * @example
     * // Get one MaterialContentFile
     * const materialContentFile = await prisma.materialContentFile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaterialContentFileFindFirstArgs>(args?: SelectSubset<T, MaterialContentFileFindFirstArgs<ExtArgs>>): Prisma__MaterialContentFileClient<$Result.GetResult<Prisma.$MaterialContentFilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MaterialContentFile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentFileFindFirstOrThrowArgs} args - Arguments to find a MaterialContentFile
     * @example
     * // Get one MaterialContentFile
     * const materialContentFile = await prisma.materialContentFile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaterialContentFileFindFirstOrThrowArgs>(args?: SelectSubset<T, MaterialContentFileFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaterialContentFileClient<$Result.GetResult<Prisma.$MaterialContentFilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MaterialContentFiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentFileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaterialContentFiles
     * const materialContentFiles = await prisma.materialContentFile.findMany()
     * 
     * // Get first 10 MaterialContentFiles
     * const materialContentFiles = await prisma.materialContentFile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialContentFileWithIdOnly = await prisma.materialContentFile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaterialContentFileFindManyArgs>(args?: SelectSubset<T, MaterialContentFileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialContentFilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MaterialContentFile.
     * @param {MaterialContentFileCreateArgs} args - Arguments to create a MaterialContentFile.
     * @example
     * // Create one MaterialContentFile
     * const MaterialContentFile = await prisma.materialContentFile.create({
     *   data: {
     *     // ... data to create a MaterialContentFile
     *   }
     * })
     * 
     */
    create<T extends MaterialContentFileCreateArgs>(args: SelectSubset<T, MaterialContentFileCreateArgs<ExtArgs>>): Prisma__MaterialContentFileClient<$Result.GetResult<Prisma.$MaterialContentFilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MaterialContentFiles.
     * @param {MaterialContentFileCreateManyArgs} args - Arguments to create many MaterialContentFiles.
     * @example
     * // Create many MaterialContentFiles
     * const materialContentFile = await prisma.materialContentFile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaterialContentFileCreateManyArgs>(args?: SelectSubset<T, MaterialContentFileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MaterialContentFile.
     * @param {MaterialContentFileDeleteArgs} args - Arguments to delete one MaterialContentFile.
     * @example
     * // Delete one MaterialContentFile
     * const MaterialContentFile = await prisma.materialContentFile.delete({
     *   where: {
     *     // ... filter to delete one MaterialContentFile
     *   }
     * })
     * 
     */
    delete<T extends MaterialContentFileDeleteArgs>(args: SelectSubset<T, MaterialContentFileDeleteArgs<ExtArgs>>): Prisma__MaterialContentFileClient<$Result.GetResult<Prisma.$MaterialContentFilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MaterialContentFile.
     * @param {MaterialContentFileUpdateArgs} args - Arguments to update one MaterialContentFile.
     * @example
     * // Update one MaterialContentFile
     * const materialContentFile = await prisma.materialContentFile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaterialContentFileUpdateArgs>(args: SelectSubset<T, MaterialContentFileUpdateArgs<ExtArgs>>): Prisma__MaterialContentFileClient<$Result.GetResult<Prisma.$MaterialContentFilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MaterialContentFiles.
     * @param {MaterialContentFileDeleteManyArgs} args - Arguments to filter MaterialContentFiles to delete.
     * @example
     * // Delete a few MaterialContentFiles
     * const { count } = await prisma.materialContentFile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaterialContentFileDeleteManyArgs>(args?: SelectSubset<T, MaterialContentFileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaterialContentFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentFileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaterialContentFiles
     * const materialContentFile = await prisma.materialContentFile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaterialContentFileUpdateManyArgs>(args: SelectSubset<T, MaterialContentFileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MaterialContentFile.
     * @param {MaterialContentFileUpsertArgs} args - Arguments to update or create a MaterialContentFile.
     * @example
     * // Update or create a MaterialContentFile
     * const materialContentFile = await prisma.materialContentFile.upsert({
     *   create: {
     *     // ... data to create a MaterialContentFile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaterialContentFile we want to update
     *   }
     * })
     */
    upsert<T extends MaterialContentFileUpsertArgs>(args: SelectSubset<T, MaterialContentFileUpsertArgs<ExtArgs>>): Prisma__MaterialContentFileClient<$Result.GetResult<Prisma.$MaterialContentFilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MaterialContentFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentFileCountArgs} args - Arguments to filter MaterialContentFiles to count.
     * @example
     * // Count the number of MaterialContentFiles
     * const count = await prisma.materialContentFile.count({
     *   where: {
     *     // ... the filter for the MaterialContentFiles we want to count
     *   }
     * })
    **/
    count<T extends MaterialContentFileCountArgs>(
      args?: Subset<T, MaterialContentFileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialContentFileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaterialContentFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentFileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialContentFileAggregateArgs>(args: Subset<T, MaterialContentFileAggregateArgs>): Prisma.PrismaPromise<GetMaterialContentFileAggregateType<T>>

    /**
     * Group by MaterialContentFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentFileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialContentFileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialContentFileGroupByArgs['orderBy'] }
        : { orderBy?: MaterialContentFileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialContentFileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialContentFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaterialContentFile model
   */
  readonly fields: MaterialContentFileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaterialContentFile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterialContentFileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    materialContent<T extends MaterialContentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaterialContentDefaultArgs<ExtArgs>>): Prisma__MaterialContentClient<$Result.GetResult<Prisma.$MaterialContentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaterialContentFile model
   */ 
  interface MaterialContentFileFieldRefs {
    readonly id: FieldRef<"MaterialContentFile", 'Int'>
    readonly materialContentId: FieldRef<"MaterialContentFile", 'Int'>
    readonly createdAt: FieldRef<"MaterialContentFile", 'DateTime'>
    readonly updatedAt: FieldRef<"MaterialContentFile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MaterialContentFile findUnique
   */
  export type MaterialContentFileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentFile
     */
    select?: MaterialContentFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentFileInclude<ExtArgs> | null
    /**
     * Filter, which MaterialContentFile to fetch.
     */
    where: MaterialContentFileWhereUniqueInput
  }

  /**
   * MaterialContentFile findUniqueOrThrow
   */
  export type MaterialContentFileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentFile
     */
    select?: MaterialContentFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentFileInclude<ExtArgs> | null
    /**
     * Filter, which MaterialContentFile to fetch.
     */
    where: MaterialContentFileWhereUniqueInput
  }

  /**
   * MaterialContentFile findFirst
   */
  export type MaterialContentFileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentFile
     */
    select?: MaterialContentFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentFileInclude<ExtArgs> | null
    /**
     * Filter, which MaterialContentFile to fetch.
     */
    where?: MaterialContentFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialContentFiles to fetch.
     */
    orderBy?: MaterialContentFileOrderByWithRelationInput | MaterialContentFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaterialContentFiles.
     */
    cursor?: MaterialContentFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialContentFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialContentFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaterialContentFiles.
     */
    distinct?: MaterialContentFileScalarFieldEnum | MaterialContentFileScalarFieldEnum[]
  }

  /**
   * MaterialContentFile findFirstOrThrow
   */
  export type MaterialContentFileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentFile
     */
    select?: MaterialContentFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentFileInclude<ExtArgs> | null
    /**
     * Filter, which MaterialContentFile to fetch.
     */
    where?: MaterialContentFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialContentFiles to fetch.
     */
    orderBy?: MaterialContentFileOrderByWithRelationInput | MaterialContentFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaterialContentFiles.
     */
    cursor?: MaterialContentFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialContentFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialContentFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaterialContentFiles.
     */
    distinct?: MaterialContentFileScalarFieldEnum | MaterialContentFileScalarFieldEnum[]
  }

  /**
   * MaterialContentFile findMany
   */
  export type MaterialContentFileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentFile
     */
    select?: MaterialContentFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentFileInclude<ExtArgs> | null
    /**
     * Filter, which MaterialContentFiles to fetch.
     */
    where?: MaterialContentFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialContentFiles to fetch.
     */
    orderBy?: MaterialContentFileOrderByWithRelationInput | MaterialContentFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaterialContentFiles.
     */
    cursor?: MaterialContentFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialContentFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialContentFiles.
     */
    skip?: number
    distinct?: MaterialContentFileScalarFieldEnum | MaterialContentFileScalarFieldEnum[]
  }

  /**
   * MaterialContentFile create
   */
  export type MaterialContentFileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentFile
     */
    select?: MaterialContentFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentFileInclude<ExtArgs> | null
    /**
     * The data needed to create a MaterialContentFile.
     */
    data: XOR<MaterialContentFileCreateInput, MaterialContentFileUncheckedCreateInput>
  }

  /**
   * MaterialContentFile createMany
   */
  export type MaterialContentFileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaterialContentFiles.
     */
    data: MaterialContentFileCreateManyInput | MaterialContentFileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MaterialContentFile update
   */
  export type MaterialContentFileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentFile
     */
    select?: MaterialContentFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentFileInclude<ExtArgs> | null
    /**
     * The data needed to update a MaterialContentFile.
     */
    data: XOR<MaterialContentFileUpdateInput, MaterialContentFileUncheckedUpdateInput>
    /**
     * Choose, which MaterialContentFile to update.
     */
    where: MaterialContentFileWhereUniqueInput
  }

  /**
   * MaterialContentFile updateMany
   */
  export type MaterialContentFileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaterialContentFiles.
     */
    data: XOR<MaterialContentFileUpdateManyMutationInput, MaterialContentFileUncheckedUpdateManyInput>
    /**
     * Filter which MaterialContentFiles to update
     */
    where?: MaterialContentFileWhereInput
  }

  /**
   * MaterialContentFile upsert
   */
  export type MaterialContentFileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentFile
     */
    select?: MaterialContentFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentFileInclude<ExtArgs> | null
    /**
     * The filter to search for the MaterialContentFile to update in case it exists.
     */
    where: MaterialContentFileWhereUniqueInput
    /**
     * In case the MaterialContentFile found by the `where` argument doesn't exist, create a new MaterialContentFile with this data.
     */
    create: XOR<MaterialContentFileCreateInput, MaterialContentFileUncheckedCreateInput>
    /**
     * In case the MaterialContentFile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialContentFileUpdateInput, MaterialContentFileUncheckedUpdateInput>
  }

  /**
   * MaterialContentFile delete
   */
  export type MaterialContentFileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentFile
     */
    select?: MaterialContentFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentFileInclude<ExtArgs> | null
    /**
     * Filter which MaterialContentFile to delete.
     */
    where: MaterialContentFileWhereUniqueInput
  }

  /**
   * MaterialContentFile deleteMany
   */
  export type MaterialContentFileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaterialContentFiles to delete
     */
    where?: MaterialContentFileWhereInput
  }

  /**
   * MaterialContentFile without action
   */
  export type MaterialContentFileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentFile
     */
    select?: MaterialContentFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentFileInclude<ExtArgs> | null
  }


  /**
   * Model MaterialContentAttachment
   */

  export type AggregateMaterialContentAttachment = {
    _count: MaterialContentAttachmentCountAggregateOutputType | null
    _avg: MaterialContentAttachmentAvgAggregateOutputType | null
    _sum: MaterialContentAttachmentSumAggregateOutputType | null
    _min: MaterialContentAttachmentMinAggregateOutputType | null
    _max: MaterialContentAttachmentMaxAggregateOutputType | null
  }

  export type MaterialContentAttachmentAvgAggregateOutputType = {
    id: number | null
    materialContentId: number | null
  }

  export type MaterialContentAttachmentSumAggregateOutputType = {
    id: number | null
    materialContentId: number | null
  }

  export type MaterialContentAttachmentMinAggregateOutputType = {
    id: number | null
    thumbnail: string | null
    path: string | null
    materialContentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaterialContentAttachmentMaxAggregateOutputType = {
    id: number | null
    thumbnail: string | null
    path: string | null
    materialContentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaterialContentAttachmentCountAggregateOutputType = {
    id: number
    thumbnail: number
    path: number
    materialContentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MaterialContentAttachmentAvgAggregateInputType = {
    id?: true
    materialContentId?: true
  }

  export type MaterialContentAttachmentSumAggregateInputType = {
    id?: true
    materialContentId?: true
  }

  export type MaterialContentAttachmentMinAggregateInputType = {
    id?: true
    thumbnail?: true
    path?: true
    materialContentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaterialContentAttachmentMaxAggregateInputType = {
    id?: true
    thumbnail?: true
    path?: true
    materialContentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaterialContentAttachmentCountAggregateInputType = {
    id?: true
    thumbnail?: true
    path?: true
    materialContentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MaterialContentAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaterialContentAttachment to aggregate.
     */
    where?: MaterialContentAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialContentAttachments to fetch.
     */
    orderBy?: MaterialContentAttachmentOrderByWithRelationInput | MaterialContentAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialContentAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialContentAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialContentAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaterialContentAttachments
    **/
    _count?: true | MaterialContentAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialContentAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialContentAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialContentAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialContentAttachmentMaxAggregateInputType
  }

  export type GetMaterialContentAttachmentAggregateType<T extends MaterialContentAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterialContentAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterialContentAttachment[P]>
      : GetScalarType<T[P], AggregateMaterialContentAttachment[P]>
  }




  export type MaterialContentAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialContentAttachmentWhereInput
    orderBy?: MaterialContentAttachmentOrderByWithAggregationInput | MaterialContentAttachmentOrderByWithAggregationInput[]
    by: MaterialContentAttachmentScalarFieldEnum[] | MaterialContentAttachmentScalarFieldEnum
    having?: MaterialContentAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialContentAttachmentCountAggregateInputType | true
    _avg?: MaterialContentAttachmentAvgAggregateInputType
    _sum?: MaterialContentAttachmentSumAggregateInputType
    _min?: MaterialContentAttachmentMinAggregateInputType
    _max?: MaterialContentAttachmentMaxAggregateInputType
  }

  export type MaterialContentAttachmentGroupByOutputType = {
    id: number
    thumbnail: string
    path: string
    materialContentId: number
    createdAt: Date
    updatedAt: Date
    _count: MaterialContentAttachmentCountAggregateOutputType | null
    _avg: MaterialContentAttachmentAvgAggregateOutputType | null
    _sum: MaterialContentAttachmentSumAggregateOutputType | null
    _min: MaterialContentAttachmentMinAggregateOutputType | null
    _max: MaterialContentAttachmentMaxAggregateOutputType | null
  }

  type GetMaterialContentAttachmentGroupByPayload<T extends MaterialContentAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialContentAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialContentAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialContentAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialContentAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type MaterialContentAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    thumbnail?: boolean
    path?: boolean
    materialContentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    MaterialContent?: boolean | MaterialContentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materialContentAttachment"]>


  export type MaterialContentAttachmentSelectScalar = {
    id?: boolean
    thumbnail?: boolean
    path?: boolean
    materialContentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MaterialContentAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MaterialContent?: boolean | MaterialContentDefaultArgs<ExtArgs>
  }

  export type $MaterialContentAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaterialContentAttachment"
    objects: {
      MaterialContent: Prisma.$MaterialContentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      thumbnail: string
      path: string
      materialContentId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["materialContentAttachment"]>
    composites: {}
  }

  type MaterialContentAttachmentGetPayload<S extends boolean | null | undefined | MaterialContentAttachmentDefaultArgs> = $Result.GetResult<Prisma.$MaterialContentAttachmentPayload, S>

  type MaterialContentAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MaterialContentAttachmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MaterialContentAttachmentCountAggregateInputType | true
    }

  export interface MaterialContentAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaterialContentAttachment'], meta: { name: 'MaterialContentAttachment' } }
    /**
     * Find zero or one MaterialContentAttachment that matches the filter.
     * @param {MaterialContentAttachmentFindUniqueArgs} args - Arguments to find a MaterialContentAttachment
     * @example
     * // Get one MaterialContentAttachment
     * const materialContentAttachment = await prisma.materialContentAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaterialContentAttachmentFindUniqueArgs>(args: SelectSubset<T, MaterialContentAttachmentFindUniqueArgs<ExtArgs>>): Prisma__MaterialContentAttachmentClient<$Result.GetResult<Prisma.$MaterialContentAttachmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MaterialContentAttachment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MaterialContentAttachmentFindUniqueOrThrowArgs} args - Arguments to find a MaterialContentAttachment
     * @example
     * // Get one MaterialContentAttachment
     * const materialContentAttachment = await prisma.materialContentAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaterialContentAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, MaterialContentAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaterialContentAttachmentClient<$Result.GetResult<Prisma.$MaterialContentAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MaterialContentAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentAttachmentFindFirstArgs} args - Arguments to find a MaterialContentAttachment
     * @example
     * // Get one MaterialContentAttachment
     * const materialContentAttachment = await prisma.materialContentAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaterialContentAttachmentFindFirstArgs>(args?: SelectSubset<T, MaterialContentAttachmentFindFirstArgs<ExtArgs>>): Prisma__MaterialContentAttachmentClient<$Result.GetResult<Prisma.$MaterialContentAttachmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MaterialContentAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentAttachmentFindFirstOrThrowArgs} args - Arguments to find a MaterialContentAttachment
     * @example
     * // Get one MaterialContentAttachment
     * const materialContentAttachment = await prisma.materialContentAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaterialContentAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, MaterialContentAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaterialContentAttachmentClient<$Result.GetResult<Prisma.$MaterialContentAttachmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MaterialContentAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaterialContentAttachments
     * const materialContentAttachments = await prisma.materialContentAttachment.findMany()
     * 
     * // Get first 10 MaterialContentAttachments
     * const materialContentAttachments = await prisma.materialContentAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialContentAttachmentWithIdOnly = await prisma.materialContentAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaterialContentAttachmentFindManyArgs>(args?: SelectSubset<T, MaterialContentAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialContentAttachmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MaterialContentAttachment.
     * @param {MaterialContentAttachmentCreateArgs} args - Arguments to create a MaterialContentAttachment.
     * @example
     * // Create one MaterialContentAttachment
     * const MaterialContentAttachment = await prisma.materialContentAttachment.create({
     *   data: {
     *     // ... data to create a MaterialContentAttachment
     *   }
     * })
     * 
     */
    create<T extends MaterialContentAttachmentCreateArgs>(args: SelectSubset<T, MaterialContentAttachmentCreateArgs<ExtArgs>>): Prisma__MaterialContentAttachmentClient<$Result.GetResult<Prisma.$MaterialContentAttachmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MaterialContentAttachments.
     * @param {MaterialContentAttachmentCreateManyArgs} args - Arguments to create many MaterialContentAttachments.
     * @example
     * // Create many MaterialContentAttachments
     * const materialContentAttachment = await prisma.materialContentAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaterialContentAttachmentCreateManyArgs>(args?: SelectSubset<T, MaterialContentAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MaterialContentAttachment.
     * @param {MaterialContentAttachmentDeleteArgs} args - Arguments to delete one MaterialContentAttachment.
     * @example
     * // Delete one MaterialContentAttachment
     * const MaterialContentAttachment = await prisma.materialContentAttachment.delete({
     *   where: {
     *     // ... filter to delete one MaterialContentAttachment
     *   }
     * })
     * 
     */
    delete<T extends MaterialContentAttachmentDeleteArgs>(args: SelectSubset<T, MaterialContentAttachmentDeleteArgs<ExtArgs>>): Prisma__MaterialContentAttachmentClient<$Result.GetResult<Prisma.$MaterialContentAttachmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MaterialContentAttachment.
     * @param {MaterialContentAttachmentUpdateArgs} args - Arguments to update one MaterialContentAttachment.
     * @example
     * // Update one MaterialContentAttachment
     * const materialContentAttachment = await prisma.materialContentAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaterialContentAttachmentUpdateArgs>(args: SelectSubset<T, MaterialContentAttachmentUpdateArgs<ExtArgs>>): Prisma__MaterialContentAttachmentClient<$Result.GetResult<Prisma.$MaterialContentAttachmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MaterialContentAttachments.
     * @param {MaterialContentAttachmentDeleteManyArgs} args - Arguments to filter MaterialContentAttachments to delete.
     * @example
     * // Delete a few MaterialContentAttachments
     * const { count } = await prisma.materialContentAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaterialContentAttachmentDeleteManyArgs>(args?: SelectSubset<T, MaterialContentAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaterialContentAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaterialContentAttachments
     * const materialContentAttachment = await prisma.materialContentAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaterialContentAttachmentUpdateManyArgs>(args: SelectSubset<T, MaterialContentAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MaterialContentAttachment.
     * @param {MaterialContentAttachmentUpsertArgs} args - Arguments to update or create a MaterialContentAttachment.
     * @example
     * // Update or create a MaterialContentAttachment
     * const materialContentAttachment = await prisma.materialContentAttachment.upsert({
     *   create: {
     *     // ... data to create a MaterialContentAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaterialContentAttachment we want to update
     *   }
     * })
     */
    upsert<T extends MaterialContentAttachmentUpsertArgs>(args: SelectSubset<T, MaterialContentAttachmentUpsertArgs<ExtArgs>>): Prisma__MaterialContentAttachmentClient<$Result.GetResult<Prisma.$MaterialContentAttachmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MaterialContentAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentAttachmentCountArgs} args - Arguments to filter MaterialContentAttachments to count.
     * @example
     * // Count the number of MaterialContentAttachments
     * const count = await prisma.materialContentAttachment.count({
     *   where: {
     *     // ... the filter for the MaterialContentAttachments we want to count
     *   }
     * })
    **/
    count<T extends MaterialContentAttachmentCountArgs>(
      args?: Subset<T, MaterialContentAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialContentAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaterialContentAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialContentAttachmentAggregateArgs>(args: Subset<T, MaterialContentAttachmentAggregateArgs>): Prisma.PrismaPromise<GetMaterialContentAttachmentAggregateType<T>>

    /**
     * Group by MaterialContentAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialContentAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialContentAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialContentAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: MaterialContentAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialContentAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialContentAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaterialContentAttachment model
   */
  readonly fields: MaterialContentAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaterialContentAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterialContentAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    MaterialContent<T extends MaterialContentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaterialContentDefaultArgs<ExtArgs>>): Prisma__MaterialContentClient<$Result.GetResult<Prisma.$MaterialContentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaterialContentAttachment model
   */ 
  interface MaterialContentAttachmentFieldRefs {
    readonly id: FieldRef<"MaterialContentAttachment", 'Int'>
    readonly thumbnail: FieldRef<"MaterialContentAttachment", 'String'>
    readonly path: FieldRef<"MaterialContentAttachment", 'String'>
    readonly materialContentId: FieldRef<"MaterialContentAttachment", 'Int'>
    readonly createdAt: FieldRef<"MaterialContentAttachment", 'DateTime'>
    readonly updatedAt: FieldRef<"MaterialContentAttachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MaterialContentAttachment findUnique
   */
  export type MaterialContentAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentAttachment
     */
    select?: MaterialContentAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MaterialContentAttachment to fetch.
     */
    where: MaterialContentAttachmentWhereUniqueInput
  }

  /**
   * MaterialContentAttachment findUniqueOrThrow
   */
  export type MaterialContentAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentAttachment
     */
    select?: MaterialContentAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MaterialContentAttachment to fetch.
     */
    where: MaterialContentAttachmentWhereUniqueInput
  }

  /**
   * MaterialContentAttachment findFirst
   */
  export type MaterialContentAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentAttachment
     */
    select?: MaterialContentAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MaterialContentAttachment to fetch.
     */
    where?: MaterialContentAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialContentAttachments to fetch.
     */
    orderBy?: MaterialContentAttachmentOrderByWithRelationInput | MaterialContentAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaterialContentAttachments.
     */
    cursor?: MaterialContentAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialContentAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialContentAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaterialContentAttachments.
     */
    distinct?: MaterialContentAttachmentScalarFieldEnum | MaterialContentAttachmentScalarFieldEnum[]
  }

  /**
   * MaterialContentAttachment findFirstOrThrow
   */
  export type MaterialContentAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentAttachment
     */
    select?: MaterialContentAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MaterialContentAttachment to fetch.
     */
    where?: MaterialContentAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialContentAttachments to fetch.
     */
    orderBy?: MaterialContentAttachmentOrderByWithRelationInput | MaterialContentAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaterialContentAttachments.
     */
    cursor?: MaterialContentAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialContentAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialContentAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaterialContentAttachments.
     */
    distinct?: MaterialContentAttachmentScalarFieldEnum | MaterialContentAttachmentScalarFieldEnum[]
  }

  /**
   * MaterialContentAttachment findMany
   */
  export type MaterialContentAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentAttachment
     */
    select?: MaterialContentAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MaterialContentAttachments to fetch.
     */
    where?: MaterialContentAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialContentAttachments to fetch.
     */
    orderBy?: MaterialContentAttachmentOrderByWithRelationInput | MaterialContentAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaterialContentAttachments.
     */
    cursor?: MaterialContentAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialContentAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialContentAttachments.
     */
    skip?: number
    distinct?: MaterialContentAttachmentScalarFieldEnum | MaterialContentAttachmentScalarFieldEnum[]
  }

  /**
   * MaterialContentAttachment create
   */
  export type MaterialContentAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentAttachment
     */
    select?: MaterialContentAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a MaterialContentAttachment.
     */
    data: XOR<MaterialContentAttachmentCreateInput, MaterialContentAttachmentUncheckedCreateInput>
  }

  /**
   * MaterialContentAttachment createMany
   */
  export type MaterialContentAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaterialContentAttachments.
     */
    data: MaterialContentAttachmentCreateManyInput | MaterialContentAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MaterialContentAttachment update
   */
  export type MaterialContentAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentAttachment
     */
    select?: MaterialContentAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a MaterialContentAttachment.
     */
    data: XOR<MaterialContentAttachmentUpdateInput, MaterialContentAttachmentUncheckedUpdateInput>
    /**
     * Choose, which MaterialContentAttachment to update.
     */
    where: MaterialContentAttachmentWhereUniqueInput
  }

  /**
   * MaterialContentAttachment updateMany
   */
  export type MaterialContentAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaterialContentAttachments.
     */
    data: XOR<MaterialContentAttachmentUpdateManyMutationInput, MaterialContentAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which MaterialContentAttachments to update
     */
    where?: MaterialContentAttachmentWhereInput
  }

  /**
   * MaterialContentAttachment upsert
   */
  export type MaterialContentAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentAttachment
     */
    select?: MaterialContentAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the MaterialContentAttachment to update in case it exists.
     */
    where: MaterialContentAttachmentWhereUniqueInput
    /**
     * In case the MaterialContentAttachment found by the `where` argument doesn't exist, create a new MaterialContentAttachment with this data.
     */
    create: XOR<MaterialContentAttachmentCreateInput, MaterialContentAttachmentUncheckedCreateInput>
    /**
     * In case the MaterialContentAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialContentAttachmentUpdateInput, MaterialContentAttachmentUncheckedUpdateInput>
  }

  /**
   * MaterialContentAttachment delete
   */
  export type MaterialContentAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentAttachment
     */
    select?: MaterialContentAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentAttachmentInclude<ExtArgs> | null
    /**
     * Filter which MaterialContentAttachment to delete.
     */
    where: MaterialContentAttachmentWhereUniqueInput
  }

  /**
   * MaterialContentAttachment deleteMany
   */
  export type MaterialContentAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaterialContentAttachments to delete
     */
    where?: MaterialContentAttachmentWhereInput
  }

  /**
   * MaterialContentAttachment without action
   */
  export type MaterialContentAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialContentAttachment
     */
    select?: MaterialContentAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialContentAttachmentInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsersScalarFieldEnum: {
    gid: 'gid',
    full_name: 'full_name',
    email: 'email',
    phone: 'phone',
    school: 'school',
    user_type: 'user_type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    cover: 'cover',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    price: 'price',
    slug: 'slug'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const CourseCreatorScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    userId: 'userId',
    as: 'as',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CourseCreatorScalarFieldEnum = (typeof CourseCreatorScalarFieldEnum)[keyof typeof CourseCreatorScalarFieldEnum]


  export const CourseLoggingScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    userId: 'userId',
    syllabusContentId: 'syllabusContentId',
    materialContentId: 'materialContentId',
    examId: 'examId',
    isRead: 'isRead',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CourseLoggingScalarFieldEnum = (typeof CourseLoggingScalarFieldEnum)[keyof typeof CourseLoggingScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    title: 'title',
    isActive: 'isActive',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    slug: 'slug'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const SubCategoryScalarFieldEnum: {
    id: 'id',
    title: 'title',
    isActive: 'isActive',
    categoryId: 'categoryId',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    slug: 'slug'
  };

  export type SubCategoryScalarFieldEnum = (typeof SubCategoryScalarFieldEnum)[keyof typeof SubCategoryScalarFieldEnum]


  export const TopicScalarFieldEnum: {
    id: 'id',
    title: 'title',
    isActive: 'isActive',
    subCategoryId: 'subCategoryId',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    slug: 'slug'
  };

  export type TopicScalarFieldEnum = (typeof TopicScalarFieldEnum)[keyof typeof TopicScalarFieldEnum]


  export const CourseTopicScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    topicId: 'topicId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CourseTopicScalarFieldEnum = (typeof CourseTopicScalarFieldEnum)[keyof typeof CourseTopicScalarFieldEnum]


  export const SyllabusScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    courseId: 'courseId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SyllabusScalarFieldEnum = (typeof SyllabusScalarFieldEnum)[keyof typeof SyllabusScalarFieldEnum]


  export const SyllabusContentScalarFieldEnum: {
    id: 'id',
    syllabusId: 'syllabusId',
    title: 'title',
    type: 'type',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    slug: 'slug'
  };

  export type SyllabusContentScalarFieldEnum = (typeof SyllabusContentScalarFieldEnum)[keyof typeof SyllabusContentScalarFieldEnum]


  export const ExamScalarFieldEnum: {
    id: 'id',
    title: 'title',
    syllabusContentId: 'syllabusContentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    description: 'description'
  };

  export type ExamScalarFieldEnum = (typeof ExamScalarFieldEnum)[keyof typeof ExamScalarFieldEnum]


  export const ExamQuestionScalarFieldEnum: {
    id: 'id',
    isActive: 'isActive',
    examId: 'examId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    description: 'description',
    questionText: 'questionText',
    typeQuestion: 'typeQuestion'
  };

  export type ExamQuestionScalarFieldEnum = (typeof ExamQuestionScalarFieldEnum)[keyof typeof ExamQuestionScalarFieldEnum]


  export const ExamOptionQuestionScalarFieldEnum: {
    id: 'id',
    optionText: 'optionText',
    isTrue: 'isTrue',
    reason: 'reason',
    order: 'order',
    attachment: 'attachment',
    examQuestionId: 'examQuestionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExamOptionQuestionScalarFieldEnum = (typeof ExamOptionQuestionScalarFieldEnum)[keyof typeof ExamOptionQuestionScalarFieldEnum]


  export const MaterialContentTypeScalarFieldEnum: {
    id: 'id',
    title: 'title'
  };

  export type MaterialContentTypeScalarFieldEnum = (typeof MaterialContentTypeScalarFieldEnum)[keyof typeof MaterialContentTypeScalarFieldEnum]


  export const MaterialContentScalarFieldEnum: {
    id: 'id',
    title: 'title',
    materialContentTypeId: 'materialContentTypeId',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    slug: 'slug',
    syllabusContentId: 'syllabusContentId',
    estimatedTime: 'estimatedTime'
  };

  export type MaterialContentScalarFieldEnum = (typeof MaterialContentScalarFieldEnum)[keyof typeof MaterialContentScalarFieldEnum]


  export const MaterialContentLearningScalarFieldEnum: {
    id: 'id',
    materialContentId: 'materialContentId',
    content: 'content'
  };

  export type MaterialContentLearningScalarFieldEnum = (typeof MaterialContentLearningScalarFieldEnum)[keyof typeof MaterialContentLearningScalarFieldEnum]


  export const MaterialContentTestScalarFieldEnum: {
    id: 'id',
    materialContentId: 'materialContentId'
  };

  export type MaterialContentTestScalarFieldEnum = (typeof MaterialContentTestScalarFieldEnum)[keyof typeof MaterialContentTestScalarFieldEnum]


  export const MaterialContentFileScalarFieldEnum: {
    id: 'id',
    materialContentId: 'materialContentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MaterialContentFileScalarFieldEnum = (typeof MaterialContentFileScalarFieldEnum)[keyof typeof MaterialContentFileScalarFieldEnum]


  export const MaterialContentAttachmentScalarFieldEnum: {
    id: 'id',
    thumbnail: 'thumbnail',
    path: 'path',
    materialContentId: 'materialContentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MaterialContentAttachmentScalarFieldEnum = (typeof MaterialContentAttachmentScalarFieldEnum)[keyof typeof MaterialContentAttachmentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'CourseAs'
   */
  export type EnumCourseAsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourseAs'>
    


  /**
   * Reference to a field of type 'SyllabusContentType'
   */
  export type EnumSyllabusContentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SyllabusContentType'>
    


  /**
   * Reference to a field of type 'TypeQuestion'
   */
  export type EnumTypeQuestionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeQuestion'>
    


  /**
   * Reference to a field of type 'TypeMaterialContent'
   */
  export type EnumTypeMaterialContentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeMaterialContent'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UsersWhereInput = {
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    gid?: StringFilter<"Users"> | string
    full_name?: StringNullableFilter<"Users"> | string | null
    email?: StringNullableFilter<"Users"> | string | null
    phone?: StringNullableFilter<"Users"> | string | null
    school?: StringNullableFilter<"Users"> | string | null
    user_type?: IntNullableFilter<"Users"> | number | null
    createdAt?: DateTimeFilter<"Users"> | Date | string
    updatedAt?: DateTimeFilter<"Users"> | Date | string
    CourseCreator?: CourseCreatorListRelationFilter
    CourseLogging?: CourseLoggingListRelationFilter
  }

  export type UsersOrderByWithRelationInput = {
    gid?: SortOrder
    full_name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    school?: SortOrderInput | SortOrder
    user_type?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    CourseCreator?: CourseCreatorOrderByRelationAggregateInput
    CourseLogging?: CourseLoggingOrderByRelationAggregateInput
  }

  export type UsersWhereUniqueInput = Prisma.AtLeast<{
    gid?: string
    email?: string
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    full_name?: StringNullableFilter<"Users"> | string | null
    phone?: StringNullableFilter<"Users"> | string | null
    school?: StringNullableFilter<"Users"> | string | null
    user_type?: IntNullableFilter<"Users"> | number | null
    createdAt?: DateTimeFilter<"Users"> | Date | string
    updatedAt?: DateTimeFilter<"Users"> | Date | string
    CourseCreator?: CourseCreatorListRelationFilter
    CourseLogging?: CourseLoggingListRelationFilter
  }, "gid" | "email">

  export type UsersOrderByWithAggregationInput = {
    gid?: SortOrder
    full_name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    school?: SortOrderInput | SortOrder
    user_type?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UsersCountOrderByAggregateInput
    _avg?: UsersAvgOrderByAggregateInput
    _max?: UsersMaxOrderByAggregateInput
    _min?: UsersMinOrderByAggregateInput
    _sum?: UsersSumOrderByAggregateInput
  }

  export type UsersScalarWhereWithAggregatesInput = {
    AND?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    OR?: UsersScalarWhereWithAggregatesInput[]
    NOT?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    gid?: StringWithAggregatesFilter<"Users"> | string
    full_name?: StringNullableWithAggregatesFilter<"Users"> | string | null
    email?: StringNullableWithAggregatesFilter<"Users"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Users"> | string | null
    school?: StringNullableWithAggregatesFilter<"Users"> | string | null
    user_type?: IntNullableWithAggregatesFilter<"Users"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Users"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Users"> | Date | string
  }

  export type CourseWhereInput = {
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    id?: IntFilter<"Course"> | number
    title?: StringFilter<"Course"> | string
    description?: StringFilter<"Course"> | string
    cover?: StringFilter<"Course"> | string
    isActive?: BoolFilter<"Course"> | boolean
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    price?: IntFilter<"Course"> | number
    slug?: StringFilter<"Course"> | string
    CourseLoggings?: CourseLoggingListRelationFilter
    CourseTopics?: CourseTopicListRelationFilter
    Syllabus?: SyllabusListRelationFilter
    CourseCreator?: CourseCreatorListRelationFilter
  }

  export type CourseOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    cover?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    price?: SortOrder
    slug?: SortOrder
    CourseLoggings?: CourseLoggingOrderByRelationAggregateInput
    CourseTopics?: CourseTopicOrderByRelationAggregateInput
    Syllabus?: SyllabusOrderByRelationAggregateInput
    CourseCreator?: CourseCreatorOrderByRelationAggregateInput
  }

  export type CourseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    title?: StringFilter<"Course"> | string
    description?: StringFilter<"Course"> | string
    cover?: StringFilter<"Course"> | string
    isActive?: BoolFilter<"Course"> | boolean
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    price?: IntFilter<"Course"> | number
    CourseLoggings?: CourseLoggingListRelationFilter
    CourseTopics?: CourseTopicListRelationFilter
    Syllabus?: SyllabusListRelationFilter
    CourseCreator?: CourseCreatorListRelationFilter
  }, "id" | "slug">

  export type CourseOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    cover?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    price?: SortOrder
    slug?: SortOrder
    _count?: CourseCountOrderByAggregateInput
    _avg?: CourseAvgOrderByAggregateInput
    _max?: CourseMaxOrderByAggregateInput
    _min?: CourseMinOrderByAggregateInput
    _sum?: CourseSumOrderByAggregateInput
  }

  export type CourseScalarWhereWithAggregatesInput = {
    AND?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    OR?: CourseScalarWhereWithAggregatesInput[]
    NOT?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Course"> | number
    title?: StringWithAggregatesFilter<"Course"> | string
    description?: StringWithAggregatesFilter<"Course"> | string
    cover?: StringWithAggregatesFilter<"Course"> | string
    isActive?: BoolWithAggregatesFilter<"Course"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
    price?: IntWithAggregatesFilter<"Course"> | number
    slug?: StringWithAggregatesFilter<"Course"> | string
  }

  export type CourseCreatorWhereInput = {
    AND?: CourseCreatorWhereInput | CourseCreatorWhereInput[]
    OR?: CourseCreatorWhereInput[]
    NOT?: CourseCreatorWhereInput | CourseCreatorWhereInput[]
    id?: IntFilter<"CourseCreator"> | number
    courseId?: IntFilter<"CourseCreator"> | number
    userId?: StringFilter<"CourseCreator"> | string
    as?: EnumCourseAsFilter<"CourseCreator"> | $Enums.CourseAs
    createdAt?: DateTimeFilter<"CourseCreator"> | Date | string
    updatedAt?: DateTimeFilter<"CourseCreator"> | Date | string
    Course?: XOR<CourseRelationFilter, CourseWhereInput>
    User?: XOR<UsersRelationFilter, UsersWhereInput>
  }

  export type CourseCreatorOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    userId?: SortOrder
    as?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Course?: CourseOrderByWithRelationInput
    User?: UsersOrderByWithRelationInput
  }

  export type CourseCreatorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CourseCreatorWhereInput | CourseCreatorWhereInput[]
    OR?: CourseCreatorWhereInput[]
    NOT?: CourseCreatorWhereInput | CourseCreatorWhereInput[]
    courseId?: IntFilter<"CourseCreator"> | number
    userId?: StringFilter<"CourseCreator"> | string
    as?: EnumCourseAsFilter<"CourseCreator"> | $Enums.CourseAs
    createdAt?: DateTimeFilter<"CourseCreator"> | Date | string
    updatedAt?: DateTimeFilter<"CourseCreator"> | Date | string
    Course?: XOR<CourseRelationFilter, CourseWhereInput>
    User?: XOR<UsersRelationFilter, UsersWhereInput>
  }, "id">

  export type CourseCreatorOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    userId?: SortOrder
    as?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CourseCreatorCountOrderByAggregateInput
    _avg?: CourseCreatorAvgOrderByAggregateInput
    _max?: CourseCreatorMaxOrderByAggregateInput
    _min?: CourseCreatorMinOrderByAggregateInput
    _sum?: CourseCreatorSumOrderByAggregateInput
  }

  export type CourseCreatorScalarWhereWithAggregatesInput = {
    AND?: CourseCreatorScalarWhereWithAggregatesInput | CourseCreatorScalarWhereWithAggregatesInput[]
    OR?: CourseCreatorScalarWhereWithAggregatesInput[]
    NOT?: CourseCreatorScalarWhereWithAggregatesInput | CourseCreatorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CourseCreator"> | number
    courseId?: IntWithAggregatesFilter<"CourseCreator"> | number
    userId?: StringWithAggregatesFilter<"CourseCreator"> | string
    as?: EnumCourseAsWithAggregatesFilter<"CourseCreator"> | $Enums.CourseAs
    createdAt?: DateTimeWithAggregatesFilter<"CourseCreator"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CourseCreator"> | Date | string
  }

  export type CourseLoggingWhereInput = {
    AND?: CourseLoggingWhereInput | CourseLoggingWhereInput[]
    OR?: CourseLoggingWhereInput[]
    NOT?: CourseLoggingWhereInput | CourseLoggingWhereInput[]
    id?: IntFilter<"CourseLogging"> | number
    courseId?: IntFilter<"CourseLogging"> | number
    userId?: StringFilter<"CourseLogging"> | string
    syllabusContentId?: IntFilter<"CourseLogging"> | number
    materialContentId?: IntNullableFilter<"CourseLogging"> | number | null
    examId?: IntNullableFilter<"CourseLogging"> | number | null
    isRead?: BoolFilter<"CourseLogging"> | boolean
    createdAt?: DateTimeFilter<"CourseLogging"> | Date | string
    updatedAt?: DateTimeFilter<"CourseLogging"> | Date | string
    Course?: XOR<CourseRelationFilter, CourseWhereInput>
    User?: XOR<UsersRelationFilter, UsersWhereInput>
    SyllabusContent?: XOR<SyllabusContentRelationFilter, SyllabusContentWhereInput>
    MaterialContent?: XOR<MaterialContentNullableRelationFilter, MaterialContentWhereInput> | null
    Exam?: XOR<ExamNullableRelationFilter, ExamWhereInput> | null
  }

  export type CourseLoggingOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    userId?: SortOrder
    syllabusContentId?: SortOrder
    materialContentId?: SortOrderInput | SortOrder
    examId?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Course?: CourseOrderByWithRelationInput
    User?: UsersOrderByWithRelationInput
    SyllabusContent?: SyllabusContentOrderByWithRelationInput
    MaterialContent?: MaterialContentOrderByWithRelationInput
    Exam?: ExamOrderByWithRelationInput
  }

  export type CourseLoggingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CourseLoggingWhereInput | CourseLoggingWhereInput[]
    OR?: CourseLoggingWhereInput[]
    NOT?: CourseLoggingWhereInput | CourseLoggingWhereInput[]
    courseId?: IntFilter<"CourseLogging"> | number
    userId?: StringFilter<"CourseLogging"> | string
    syllabusContentId?: IntFilter<"CourseLogging"> | number
    materialContentId?: IntNullableFilter<"CourseLogging"> | number | null
    examId?: IntNullableFilter<"CourseLogging"> | number | null
    isRead?: BoolFilter<"CourseLogging"> | boolean
    createdAt?: DateTimeFilter<"CourseLogging"> | Date | string
    updatedAt?: DateTimeFilter<"CourseLogging"> | Date | string
    Course?: XOR<CourseRelationFilter, CourseWhereInput>
    User?: XOR<UsersRelationFilter, UsersWhereInput>
    SyllabusContent?: XOR<SyllabusContentRelationFilter, SyllabusContentWhereInput>
    MaterialContent?: XOR<MaterialContentNullableRelationFilter, MaterialContentWhereInput> | null
    Exam?: XOR<ExamNullableRelationFilter, ExamWhereInput> | null
  }, "id">

  export type CourseLoggingOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    userId?: SortOrder
    syllabusContentId?: SortOrder
    materialContentId?: SortOrderInput | SortOrder
    examId?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CourseLoggingCountOrderByAggregateInput
    _avg?: CourseLoggingAvgOrderByAggregateInput
    _max?: CourseLoggingMaxOrderByAggregateInput
    _min?: CourseLoggingMinOrderByAggregateInput
    _sum?: CourseLoggingSumOrderByAggregateInput
  }

  export type CourseLoggingScalarWhereWithAggregatesInput = {
    AND?: CourseLoggingScalarWhereWithAggregatesInput | CourseLoggingScalarWhereWithAggregatesInput[]
    OR?: CourseLoggingScalarWhereWithAggregatesInput[]
    NOT?: CourseLoggingScalarWhereWithAggregatesInput | CourseLoggingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CourseLogging"> | number
    courseId?: IntWithAggregatesFilter<"CourseLogging"> | number
    userId?: StringWithAggregatesFilter<"CourseLogging"> | string
    syllabusContentId?: IntWithAggregatesFilter<"CourseLogging"> | number
    materialContentId?: IntNullableWithAggregatesFilter<"CourseLogging"> | number | null
    examId?: IntNullableWithAggregatesFilter<"CourseLogging"> | number | null
    isRead?: BoolWithAggregatesFilter<"CourseLogging"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CourseLogging"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CourseLogging"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: IntFilter<"Category"> | number
    title?: StringFilter<"Category"> | string
    isActive?: BoolFilter<"Category"> | boolean
    order?: IntFilter<"Category"> | number
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    slug?: StringFilter<"Category"> | string
    SubCategories?: SubCategoryListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    isActive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    slug?: SortOrder
    SubCategories?: SubCategoryOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    title?: StringFilter<"Category"> | string
    isActive?: BoolFilter<"Category"> | boolean
    order?: IntFilter<"Category"> | number
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    SubCategories?: SubCategoryListRelationFilter
  }, "id" | "slug">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    isActive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    slug?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Category"> | number
    title?: StringWithAggregatesFilter<"Category"> | string
    isActive?: BoolWithAggregatesFilter<"Category"> | boolean
    order?: IntWithAggregatesFilter<"Category"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    slug?: StringWithAggregatesFilter<"Category"> | string
  }

  export type SubCategoryWhereInput = {
    AND?: SubCategoryWhereInput | SubCategoryWhereInput[]
    OR?: SubCategoryWhereInput[]
    NOT?: SubCategoryWhereInput | SubCategoryWhereInput[]
    id?: IntFilter<"SubCategory"> | number
    title?: StringFilter<"SubCategory"> | string
    isActive?: BoolFilter<"SubCategory"> | boolean
    categoryId?: IntFilter<"SubCategory"> | number
    order?: IntFilter<"SubCategory"> | number
    createdAt?: DateTimeFilter<"SubCategory"> | Date | string
    updatedAt?: DateTimeFilter<"SubCategory"> | Date | string
    slug?: StringFilter<"SubCategory"> | string
    Category?: XOR<CategoryRelationFilter, CategoryWhereInput>
    Topics?: TopicListRelationFilter
  }

  export type SubCategoryOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    isActive?: SortOrder
    categoryId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    slug?: SortOrder
    Category?: CategoryOrderByWithRelationInput
    Topics?: TopicOrderByRelationAggregateInput
  }

  export type SubCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: SubCategoryWhereInput | SubCategoryWhereInput[]
    OR?: SubCategoryWhereInput[]
    NOT?: SubCategoryWhereInput | SubCategoryWhereInput[]
    title?: StringFilter<"SubCategory"> | string
    isActive?: BoolFilter<"SubCategory"> | boolean
    categoryId?: IntFilter<"SubCategory"> | number
    order?: IntFilter<"SubCategory"> | number
    createdAt?: DateTimeFilter<"SubCategory"> | Date | string
    updatedAt?: DateTimeFilter<"SubCategory"> | Date | string
    Category?: XOR<CategoryRelationFilter, CategoryWhereInput>
    Topics?: TopicListRelationFilter
  }, "id" | "slug">

  export type SubCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    isActive?: SortOrder
    categoryId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    slug?: SortOrder
    _count?: SubCategoryCountOrderByAggregateInput
    _avg?: SubCategoryAvgOrderByAggregateInput
    _max?: SubCategoryMaxOrderByAggregateInput
    _min?: SubCategoryMinOrderByAggregateInput
    _sum?: SubCategorySumOrderByAggregateInput
  }

  export type SubCategoryScalarWhereWithAggregatesInput = {
    AND?: SubCategoryScalarWhereWithAggregatesInput | SubCategoryScalarWhereWithAggregatesInput[]
    OR?: SubCategoryScalarWhereWithAggregatesInput[]
    NOT?: SubCategoryScalarWhereWithAggregatesInput | SubCategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SubCategory"> | number
    title?: StringWithAggregatesFilter<"SubCategory"> | string
    isActive?: BoolWithAggregatesFilter<"SubCategory"> | boolean
    categoryId?: IntWithAggregatesFilter<"SubCategory"> | number
    order?: IntWithAggregatesFilter<"SubCategory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SubCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubCategory"> | Date | string
    slug?: StringWithAggregatesFilter<"SubCategory"> | string
  }

  export type TopicWhereInput = {
    AND?: TopicWhereInput | TopicWhereInput[]
    OR?: TopicWhereInput[]
    NOT?: TopicWhereInput | TopicWhereInput[]
    id?: IntFilter<"Topic"> | number
    title?: StringFilter<"Topic"> | string
    isActive?: BoolFilter<"Topic"> | boolean
    subCategoryId?: IntFilter<"Topic"> | number
    order?: IntFilter<"Topic"> | number
    createdAt?: DateTimeFilter<"Topic"> | Date | string
    updatedAt?: DateTimeFilter<"Topic"> | Date | string
    slug?: StringFilter<"Topic"> | string
    CourseTopics?: CourseTopicListRelationFilter
    SubCategory?: XOR<SubCategoryRelationFilter, SubCategoryWhereInput>
  }

  export type TopicOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    isActive?: SortOrder
    subCategoryId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    slug?: SortOrder
    CourseTopics?: CourseTopicOrderByRelationAggregateInput
    SubCategory?: SubCategoryOrderByWithRelationInput
  }

  export type TopicWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: TopicWhereInput | TopicWhereInput[]
    OR?: TopicWhereInput[]
    NOT?: TopicWhereInput | TopicWhereInput[]
    title?: StringFilter<"Topic"> | string
    isActive?: BoolFilter<"Topic"> | boolean
    subCategoryId?: IntFilter<"Topic"> | number
    order?: IntFilter<"Topic"> | number
    createdAt?: DateTimeFilter<"Topic"> | Date | string
    updatedAt?: DateTimeFilter<"Topic"> | Date | string
    CourseTopics?: CourseTopicListRelationFilter
    SubCategory?: XOR<SubCategoryRelationFilter, SubCategoryWhereInput>
  }, "id" | "slug">

  export type TopicOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    isActive?: SortOrder
    subCategoryId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    slug?: SortOrder
    _count?: TopicCountOrderByAggregateInput
    _avg?: TopicAvgOrderByAggregateInput
    _max?: TopicMaxOrderByAggregateInput
    _min?: TopicMinOrderByAggregateInput
    _sum?: TopicSumOrderByAggregateInput
  }

  export type TopicScalarWhereWithAggregatesInput = {
    AND?: TopicScalarWhereWithAggregatesInput | TopicScalarWhereWithAggregatesInput[]
    OR?: TopicScalarWhereWithAggregatesInput[]
    NOT?: TopicScalarWhereWithAggregatesInput | TopicScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Topic"> | number
    title?: StringWithAggregatesFilter<"Topic"> | string
    isActive?: BoolWithAggregatesFilter<"Topic"> | boolean
    subCategoryId?: IntWithAggregatesFilter<"Topic"> | number
    order?: IntWithAggregatesFilter<"Topic"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Topic"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Topic"> | Date | string
    slug?: StringWithAggregatesFilter<"Topic"> | string
  }

  export type CourseTopicWhereInput = {
    AND?: CourseTopicWhereInput | CourseTopicWhereInput[]
    OR?: CourseTopicWhereInput[]
    NOT?: CourseTopicWhereInput | CourseTopicWhereInput[]
    id?: IntFilter<"CourseTopic"> | number
    courseId?: IntFilter<"CourseTopic"> | number
    topicId?: IntFilter<"CourseTopic"> | number
    createdAt?: DateTimeFilter<"CourseTopic"> | Date | string
    updatedAt?: DateTimeFilter<"CourseTopic"> | Date | string
    Course?: XOR<CourseRelationFilter, CourseWhereInput>
    Topic?: XOR<TopicRelationFilter, TopicWhereInput>
  }

  export type CourseTopicOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Course?: CourseOrderByWithRelationInput
    Topic?: TopicOrderByWithRelationInput
  }

  export type CourseTopicWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CourseTopicWhereInput | CourseTopicWhereInput[]
    OR?: CourseTopicWhereInput[]
    NOT?: CourseTopicWhereInput | CourseTopicWhereInput[]
    courseId?: IntFilter<"CourseTopic"> | number
    topicId?: IntFilter<"CourseTopic"> | number
    createdAt?: DateTimeFilter<"CourseTopic"> | Date | string
    updatedAt?: DateTimeFilter<"CourseTopic"> | Date | string
    Course?: XOR<CourseRelationFilter, CourseWhereInput>
    Topic?: XOR<TopicRelationFilter, TopicWhereInput>
  }, "id">

  export type CourseTopicOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CourseTopicCountOrderByAggregateInput
    _avg?: CourseTopicAvgOrderByAggregateInput
    _max?: CourseTopicMaxOrderByAggregateInput
    _min?: CourseTopicMinOrderByAggregateInput
    _sum?: CourseTopicSumOrderByAggregateInput
  }

  export type CourseTopicScalarWhereWithAggregatesInput = {
    AND?: CourseTopicScalarWhereWithAggregatesInput | CourseTopicScalarWhereWithAggregatesInput[]
    OR?: CourseTopicScalarWhereWithAggregatesInput[]
    NOT?: CourseTopicScalarWhereWithAggregatesInput | CourseTopicScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CourseTopic"> | number
    courseId?: IntWithAggregatesFilter<"CourseTopic"> | number
    topicId?: IntWithAggregatesFilter<"CourseTopic"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CourseTopic"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CourseTopic"> | Date | string
  }

  export type SyllabusWhereInput = {
    AND?: SyllabusWhereInput | SyllabusWhereInput[]
    OR?: SyllabusWhereInput[]
    NOT?: SyllabusWhereInput | SyllabusWhereInput[]
    id?: IntFilter<"Syllabus"> | number
    title?: StringFilter<"Syllabus"> | string
    description?: StringFilter<"Syllabus"> | string
    courseId?: IntFilter<"Syllabus"> | number
    isActive?: BoolFilter<"Syllabus"> | boolean
    createdAt?: DateTimeFilter<"Syllabus"> | Date | string
    updatedAt?: DateTimeFilter<"Syllabus"> | Date | string
    Course?: XOR<CourseRelationFilter, CourseWhereInput>
    SyllabusContent?: SyllabusContentListRelationFilter
  }

  export type SyllabusOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    courseId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Course?: CourseOrderByWithRelationInput
    SyllabusContent?: SyllabusContentOrderByRelationAggregateInput
  }

  export type SyllabusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SyllabusWhereInput | SyllabusWhereInput[]
    OR?: SyllabusWhereInput[]
    NOT?: SyllabusWhereInput | SyllabusWhereInput[]
    title?: StringFilter<"Syllabus"> | string
    description?: StringFilter<"Syllabus"> | string
    courseId?: IntFilter<"Syllabus"> | number
    isActive?: BoolFilter<"Syllabus"> | boolean
    createdAt?: DateTimeFilter<"Syllabus"> | Date | string
    updatedAt?: DateTimeFilter<"Syllabus"> | Date | string
    Course?: XOR<CourseRelationFilter, CourseWhereInput>
    SyllabusContent?: SyllabusContentListRelationFilter
  }, "id">

  export type SyllabusOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    courseId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SyllabusCountOrderByAggregateInput
    _avg?: SyllabusAvgOrderByAggregateInput
    _max?: SyllabusMaxOrderByAggregateInput
    _min?: SyllabusMinOrderByAggregateInput
    _sum?: SyllabusSumOrderByAggregateInput
  }

  export type SyllabusScalarWhereWithAggregatesInput = {
    AND?: SyllabusScalarWhereWithAggregatesInput | SyllabusScalarWhereWithAggregatesInput[]
    OR?: SyllabusScalarWhereWithAggregatesInput[]
    NOT?: SyllabusScalarWhereWithAggregatesInput | SyllabusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Syllabus"> | number
    title?: StringWithAggregatesFilter<"Syllabus"> | string
    description?: StringWithAggregatesFilter<"Syllabus"> | string
    courseId?: IntWithAggregatesFilter<"Syllabus"> | number
    isActive?: BoolWithAggregatesFilter<"Syllabus"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Syllabus"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Syllabus"> | Date | string
  }

  export type SyllabusContentWhereInput = {
    AND?: SyllabusContentWhereInput | SyllabusContentWhereInput[]
    OR?: SyllabusContentWhereInput[]
    NOT?: SyllabusContentWhereInput | SyllabusContentWhereInput[]
    id?: IntFilter<"SyllabusContent"> | number
    syllabusId?: IntFilter<"SyllabusContent"> | number
    title?: StringFilter<"SyllabusContent"> | string
    type?: EnumSyllabusContentTypeFilter<"SyllabusContent"> | $Enums.SyllabusContentType
    order?: IntFilter<"SyllabusContent"> | number
    createdAt?: DateTimeFilter<"SyllabusContent"> | Date | string
    updatedAt?: DateTimeFilter<"SyllabusContent"> | Date | string
    slug?: StringFilter<"SyllabusContent"> | string
    Exams?: ExamListRelationFilter
    MaterialContents?: MaterialContentListRelationFilter
    Syllabus?: XOR<SyllabusRelationFilter, SyllabusWhereInput>
    CourseLogging?: CourseLoggingListRelationFilter
  }

  export type SyllabusContentOrderByWithRelationInput = {
    id?: SortOrder
    syllabusId?: SortOrder
    title?: SortOrder
    type?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    slug?: SortOrder
    Exams?: ExamOrderByRelationAggregateInput
    MaterialContents?: MaterialContentOrderByRelationAggregateInput
    Syllabus?: SyllabusOrderByWithRelationInput
    CourseLogging?: CourseLoggingOrderByRelationAggregateInput
  }

  export type SyllabusContentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: SyllabusContentWhereInput | SyllabusContentWhereInput[]
    OR?: SyllabusContentWhereInput[]
    NOT?: SyllabusContentWhereInput | SyllabusContentWhereInput[]
    syllabusId?: IntFilter<"SyllabusContent"> | number
    title?: StringFilter<"SyllabusContent"> | string
    type?: EnumSyllabusContentTypeFilter<"SyllabusContent"> | $Enums.SyllabusContentType
    order?: IntFilter<"SyllabusContent"> | number
    createdAt?: DateTimeFilter<"SyllabusContent"> | Date | string
    updatedAt?: DateTimeFilter<"SyllabusContent"> | Date | string
    Exams?: ExamListRelationFilter
    MaterialContents?: MaterialContentListRelationFilter
    Syllabus?: XOR<SyllabusRelationFilter, SyllabusWhereInput>
    CourseLogging?: CourseLoggingListRelationFilter
  }, "id" | "slug">

  export type SyllabusContentOrderByWithAggregationInput = {
    id?: SortOrder
    syllabusId?: SortOrder
    title?: SortOrder
    type?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    slug?: SortOrder
    _count?: SyllabusContentCountOrderByAggregateInput
    _avg?: SyllabusContentAvgOrderByAggregateInput
    _max?: SyllabusContentMaxOrderByAggregateInput
    _min?: SyllabusContentMinOrderByAggregateInput
    _sum?: SyllabusContentSumOrderByAggregateInput
  }

  export type SyllabusContentScalarWhereWithAggregatesInput = {
    AND?: SyllabusContentScalarWhereWithAggregatesInput | SyllabusContentScalarWhereWithAggregatesInput[]
    OR?: SyllabusContentScalarWhereWithAggregatesInput[]
    NOT?: SyllabusContentScalarWhereWithAggregatesInput | SyllabusContentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SyllabusContent"> | number
    syllabusId?: IntWithAggregatesFilter<"SyllabusContent"> | number
    title?: StringWithAggregatesFilter<"SyllabusContent"> | string
    type?: EnumSyllabusContentTypeWithAggregatesFilter<"SyllabusContent"> | $Enums.SyllabusContentType
    order?: IntWithAggregatesFilter<"SyllabusContent"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SyllabusContent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SyllabusContent"> | Date | string
    slug?: StringWithAggregatesFilter<"SyllabusContent"> | string
  }

  export type ExamWhereInput = {
    AND?: ExamWhereInput | ExamWhereInput[]
    OR?: ExamWhereInput[]
    NOT?: ExamWhereInput | ExamWhereInput[]
    id?: IntFilter<"Exam"> | number
    title?: StringFilter<"Exam"> | string
    syllabusContentId?: IntFilter<"Exam"> | number
    createdAt?: DateTimeFilter<"Exam"> | Date | string
    updatedAt?: DateTimeFilter<"Exam"> | Date | string
    description?: StringFilter<"Exam"> | string
    SyllabusContent?: XOR<SyllabusContentRelationFilter, SyllabusContentWhereInput>
    ExamQuestions?: ExamQuestionListRelationFilter
    CourseLogging?: CourseLoggingListRelationFilter
  }

  export type ExamOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    syllabusContentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    SyllabusContent?: SyllabusContentOrderByWithRelationInput
    ExamQuestions?: ExamQuestionOrderByRelationAggregateInput
    CourseLogging?: CourseLoggingOrderByRelationAggregateInput
  }

  export type ExamWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ExamWhereInput | ExamWhereInput[]
    OR?: ExamWhereInput[]
    NOT?: ExamWhereInput | ExamWhereInput[]
    title?: StringFilter<"Exam"> | string
    syllabusContentId?: IntFilter<"Exam"> | number
    createdAt?: DateTimeFilter<"Exam"> | Date | string
    updatedAt?: DateTimeFilter<"Exam"> | Date | string
    description?: StringFilter<"Exam"> | string
    SyllabusContent?: XOR<SyllabusContentRelationFilter, SyllabusContentWhereInput>
    ExamQuestions?: ExamQuestionListRelationFilter
    CourseLogging?: CourseLoggingListRelationFilter
  }, "id">

  export type ExamOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    syllabusContentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    _count?: ExamCountOrderByAggregateInput
    _avg?: ExamAvgOrderByAggregateInput
    _max?: ExamMaxOrderByAggregateInput
    _min?: ExamMinOrderByAggregateInput
    _sum?: ExamSumOrderByAggregateInput
  }

  export type ExamScalarWhereWithAggregatesInput = {
    AND?: ExamScalarWhereWithAggregatesInput | ExamScalarWhereWithAggregatesInput[]
    OR?: ExamScalarWhereWithAggregatesInput[]
    NOT?: ExamScalarWhereWithAggregatesInput | ExamScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Exam"> | number
    title?: StringWithAggregatesFilter<"Exam"> | string
    syllabusContentId?: IntWithAggregatesFilter<"Exam"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Exam"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Exam"> | Date | string
    description?: StringWithAggregatesFilter<"Exam"> | string
  }

  export type ExamQuestionWhereInput = {
    AND?: ExamQuestionWhereInput | ExamQuestionWhereInput[]
    OR?: ExamQuestionWhereInput[]
    NOT?: ExamQuestionWhereInput | ExamQuestionWhereInput[]
    id?: IntFilter<"ExamQuestion"> | number
    isActive?: BoolFilter<"ExamQuestion"> | boolean
    examId?: IntFilter<"ExamQuestion"> | number
    createdAt?: DateTimeFilter<"ExamQuestion"> | Date | string
    updatedAt?: DateTimeFilter<"ExamQuestion"> | Date | string
    description?: StringNullableFilter<"ExamQuestion"> | string | null
    questionText?: StringFilter<"ExamQuestion"> | string
    typeQuestion?: EnumTypeQuestionFilter<"ExamQuestion"> | $Enums.TypeQuestion
    Exam?: XOR<ExamRelationFilter, ExamWhereInput>
    ExamOptions?: ExamOptionQuestionListRelationFilter
  }

  export type ExamQuestionOrderByWithRelationInput = {
    id?: SortOrder
    isActive?: SortOrder
    examId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrderInput | SortOrder
    questionText?: SortOrder
    typeQuestion?: SortOrder
    Exam?: ExamOrderByWithRelationInput
    ExamOptions?: ExamOptionQuestionOrderByRelationAggregateInput
  }

  export type ExamQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ExamQuestionWhereInput | ExamQuestionWhereInput[]
    OR?: ExamQuestionWhereInput[]
    NOT?: ExamQuestionWhereInput | ExamQuestionWhereInput[]
    isActive?: BoolFilter<"ExamQuestion"> | boolean
    examId?: IntFilter<"ExamQuestion"> | number
    createdAt?: DateTimeFilter<"ExamQuestion"> | Date | string
    updatedAt?: DateTimeFilter<"ExamQuestion"> | Date | string
    description?: StringNullableFilter<"ExamQuestion"> | string | null
    questionText?: StringFilter<"ExamQuestion"> | string
    typeQuestion?: EnumTypeQuestionFilter<"ExamQuestion"> | $Enums.TypeQuestion
    Exam?: XOR<ExamRelationFilter, ExamWhereInput>
    ExamOptions?: ExamOptionQuestionListRelationFilter
  }, "id">

  export type ExamQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    isActive?: SortOrder
    examId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrderInput | SortOrder
    questionText?: SortOrder
    typeQuestion?: SortOrder
    _count?: ExamQuestionCountOrderByAggregateInput
    _avg?: ExamQuestionAvgOrderByAggregateInput
    _max?: ExamQuestionMaxOrderByAggregateInput
    _min?: ExamQuestionMinOrderByAggregateInput
    _sum?: ExamQuestionSumOrderByAggregateInput
  }

  export type ExamQuestionScalarWhereWithAggregatesInput = {
    AND?: ExamQuestionScalarWhereWithAggregatesInput | ExamQuestionScalarWhereWithAggregatesInput[]
    OR?: ExamQuestionScalarWhereWithAggregatesInput[]
    NOT?: ExamQuestionScalarWhereWithAggregatesInput | ExamQuestionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ExamQuestion"> | number
    isActive?: BoolWithAggregatesFilter<"ExamQuestion"> | boolean
    examId?: IntWithAggregatesFilter<"ExamQuestion"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ExamQuestion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExamQuestion"> | Date | string
    description?: StringNullableWithAggregatesFilter<"ExamQuestion"> | string | null
    questionText?: StringWithAggregatesFilter<"ExamQuestion"> | string
    typeQuestion?: EnumTypeQuestionWithAggregatesFilter<"ExamQuestion"> | $Enums.TypeQuestion
  }

  export type ExamOptionQuestionWhereInput = {
    AND?: ExamOptionQuestionWhereInput | ExamOptionQuestionWhereInput[]
    OR?: ExamOptionQuestionWhereInput[]
    NOT?: ExamOptionQuestionWhereInput | ExamOptionQuestionWhereInput[]
    id?: IntFilter<"ExamOptionQuestion"> | number
    optionText?: StringFilter<"ExamOptionQuestion"> | string
    isTrue?: BoolNullableFilter<"ExamOptionQuestion"> | boolean | null
    reason?: StringNullableFilter<"ExamOptionQuestion"> | string | null
    order?: IntNullableFilter<"ExamOptionQuestion"> | number | null
    attachment?: StringNullableFilter<"ExamOptionQuestion"> | string | null
    examQuestionId?: IntFilter<"ExamOptionQuestion"> | number
    createdAt?: DateTimeFilter<"ExamOptionQuestion"> | Date | string
    updatedAt?: DateTimeFilter<"ExamOptionQuestion"> | Date | string
    ExamQuestion?: XOR<ExamQuestionRelationFilter, ExamQuestionWhereInput>
  }

  export type ExamOptionQuestionOrderByWithRelationInput = {
    id?: SortOrder
    optionText?: SortOrder
    isTrue?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    order?: SortOrderInput | SortOrder
    attachment?: SortOrderInput | SortOrder
    examQuestionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ExamQuestion?: ExamQuestionOrderByWithRelationInput
  }

  export type ExamOptionQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ExamOptionQuestionWhereInput | ExamOptionQuestionWhereInput[]
    OR?: ExamOptionQuestionWhereInput[]
    NOT?: ExamOptionQuestionWhereInput | ExamOptionQuestionWhereInput[]
    optionText?: StringFilter<"ExamOptionQuestion"> | string
    isTrue?: BoolNullableFilter<"ExamOptionQuestion"> | boolean | null
    reason?: StringNullableFilter<"ExamOptionQuestion"> | string | null
    order?: IntNullableFilter<"ExamOptionQuestion"> | number | null
    attachment?: StringNullableFilter<"ExamOptionQuestion"> | string | null
    examQuestionId?: IntFilter<"ExamOptionQuestion"> | number
    createdAt?: DateTimeFilter<"ExamOptionQuestion"> | Date | string
    updatedAt?: DateTimeFilter<"ExamOptionQuestion"> | Date | string
    ExamQuestion?: XOR<ExamQuestionRelationFilter, ExamQuestionWhereInput>
  }, "id">

  export type ExamOptionQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    optionText?: SortOrder
    isTrue?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    order?: SortOrderInput | SortOrder
    attachment?: SortOrderInput | SortOrder
    examQuestionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExamOptionQuestionCountOrderByAggregateInput
    _avg?: ExamOptionQuestionAvgOrderByAggregateInput
    _max?: ExamOptionQuestionMaxOrderByAggregateInput
    _min?: ExamOptionQuestionMinOrderByAggregateInput
    _sum?: ExamOptionQuestionSumOrderByAggregateInput
  }

  export type ExamOptionQuestionScalarWhereWithAggregatesInput = {
    AND?: ExamOptionQuestionScalarWhereWithAggregatesInput | ExamOptionQuestionScalarWhereWithAggregatesInput[]
    OR?: ExamOptionQuestionScalarWhereWithAggregatesInput[]
    NOT?: ExamOptionQuestionScalarWhereWithAggregatesInput | ExamOptionQuestionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ExamOptionQuestion"> | number
    optionText?: StringWithAggregatesFilter<"ExamOptionQuestion"> | string
    isTrue?: BoolNullableWithAggregatesFilter<"ExamOptionQuestion"> | boolean | null
    reason?: StringNullableWithAggregatesFilter<"ExamOptionQuestion"> | string | null
    order?: IntNullableWithAggregatesFilter<"ExamOptionQuestion"> | number | null
    attachment?: StringNullableWithAggregatesFilter<"ExamOptionQuestion"> | string | null
    examQuestionId?: IntWithAggregatesFilter<"ExamOptionQuestion"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ExamOptionQuestion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExamOptionQuestion"> | Date | string
  }

  export type MaterialContentTypeWhereInput = {
    AND?: MaterialContentTypeWhereInput | MaterialContentTypeWhereInput[]
    OR?: MaterialContentTypeWhereInput[]
    NOT?: MaterialContentTypeWhereInput | MaterialContentTypeWhereInput[]
    id?: IntFilter<"MaterialContentType"> | number
    title?: EnumTypeMaterialContentFilter<"MaterialContentType"> | $Enums.TypeMaterialContent
    MaterialContents?: MaterialContentListRelationFilter
  }

  export type MaterialContentTypeOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    MaterialContents?: MaterialContentOrderByRelationAggregateInput
  }

  export type MaterialContentTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MaterialContentTypeWhereInput | MaterialContentTypeWhereInput[]
    OR?: MaterialContentTypeWhereInput[]
    NOT?: MaterialContentTypeWhereInput | MaterialContentTypeWhereInput[]
    title?: EnumTypeMaterialContentFilter<"MaterialContentType"> | $Enums.TypeMaterialContent
    MaterialContents?: MaterialContentListRelationFilter
  }, "id">

  export type MaterialContentTypeOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    _count?: MaterialContentTypeCountOrderByAggregateInput
    _avg?: MaterialContentTypeAvgOrderByAggregateInput
    _max?: MaterialContentTypeMaxOrderByAggregateInput
    _min?: MaterialContentTypeMinOrderByAggregateInput
    _sum?: MaterialContentTypeSumOrderByAggregateInput
  }

  export type MaterialContentTypeScalarWhereWithAggregatesInput = {
    AND?: MaterialContentTypeScalarWhereWithAggregatesInput | MaterialContentTypeScalarWhereWithAggregatesInput[]
    OR?: MaterialContentTypeScalarWhereWithAggregatesInput[]
    NOT?: MaterialContentTypeScalarWhereWithAggregatesInput | MaterialContentTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MaterialContentType"> | number
    title?: EnumTypeMaterialContentWithAggregatesFilter<"MaterialContentType"> | $Enums.TypeMaterialContent
  }

  export type MaterialContentWhereInput = {
    AND?: MaterialContentWhereInput | MaterialContentWhereInput[]
    OR?: MaterialContentWhereInput[]
    NOT?: MaterialContentWhereInput | MaterialContentWhereInput[]
    id?: IntFilter<"MaterialContent"> | number
    title?: StringFilter<"MaterialContent"> | string
    materialContentTypeId?: IntFilter<"MaterialContent"> | number
    order?: IntFilter<"MaterialContent"> | number
    createdAt?: DateTimeFilter<"MaterialContent"> | Date | string
    updatedAt?: DateTimeFilter<"MaterialContent"> | Date | string
    slug?: StringFilter<"MaterialContent"> | string
    syllabusContentId?: IntFilter<"MaterialContent"> | number
    estimatedTime?: IntFilter<"MaterialContent"> | number
    Type?: XOR<MaterialContentTypeRelationFilter, MaterialContentTypeWhereInput>
    SyllabusContent?: XOR<SyllabusContentRelationFilter, SyllabusContentWhereInput>
    Attachments?: MaterialContentAttachmentListRelationFilter
    File?: XOR<MaterialContentFileNullableRelationFilter, MaterialContentFileWhereInput> | null
    MaterialContentLearning?: XOR<MaterialContentLearningNullableRelationFilter, MaterialContentLearningWhereInput> | null
    MaterialContentTest?: XOR<MaterialContentTestNullableRelationFilter, MaterialContentTestWhereInput> | null
    CourseLogging?: CourseLoggingListRelationFilter
  }

  export type MaterialContentOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    materialContentTypeId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    slug?: SortOrder
    syllabusContentId?: SortOrder
    estimatedTime?: SortOrder
    Type?: MaterialContentTypeOrderByWithRelationInput
    SyllabusContent?: SyllabusContentOrderByWithRelationInput
    Attachments?: MaterialContentAttachmentOrderByRelationAggregateInput
    File?: MaterialContentFileOrderByWithRelationInput
    MaterialContentLearning?: MaterialContentLearningOrderByWithRelationInput
    MaterialContentTest?: MaterialContentTestOrderByWithRelationInput
    CourseLogging?: CourseLoggingOrderByRelationAggregateInput
  }

  export type MaterialContentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: MaterialContentWhereInput | MaterialContentWhereInput[]
    OR?: MaterialContentWhereInput[]
    NOT?: MaterialContentWhereInput | MaterialContentWhereInput[]
    title?: StringFilter<"MaterialContent"> | string
    materialContentTypeId?: IntFilter<"MaterialContent"> | number
    order?: IntFilter<"MaterialContent"> | number
    createdAt?: DateTimeFilter<"MaterialContent"> | Date | string
    updatedAt?: DateTimeFilter<"MaterialContent"> | Date | string
    syllabusContentId?: IntFilter<"MaterialContent"> | number
    estimatedTime?: IntFilter<"MaterialContent"> | number
    Type?: XOR<MaterialContentTypeRelationFilter, MaterialContentTypeWhereInput>
    SyllabusContent?: XOR<SyllabusContentRelationFilter, SyllabusContentWhereInput>
    Attachments?: MaterialContentAttachmentListRelationFilter
    File?: XOR<MaterialContentFileNullableRelationFilter, MaterialContentFileWhereInput> | null
    MaterialContentLearning?: XOR<MaterialContentLearningNullableRelationFilter, MaterialContentLearningWhereInput> | null
    MaterialContentTest?: XOR<MaterialContentTestNullableRelationFilter, MaterialContentTestWhereInput> | null
    CourseLogging?: CourseLoggingListRelationFilter
  }, "id" | "slug">

  export type MaterialContentOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    materialContentTypeId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    slug?: SortOrder
    syllabusContentId?: SortOrder
    estimatedTime?: SortOrder
    _count?: MaterialContentCountOrderByAggregateInput
    _avg?: MaterialContentAvgOrderByAggregateInput
    _max?: MaterialContentMaxOrderByAggregateInput
    _min?: MaterialContentMinOrderByAggregateInput
    _sum?: MaterialContentSumOrderByAggregateInput
  }

  export type MaterialContentScalarWhereWithAggregatesInput = {
    AND?: MaterialContentScalarWhereWithAggregatesInput | MaterialContentScalarWhereWithAggregatesInput[]
    OR?: MaterialContentScalarWhereWithAggregatesInput[]
    NOT?: MaterialContentScalarWhereWithAggregatesInput | MaterialContentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MaterialContent"> | number
    title?: StringWithAggregatesFilter<"MaterialContent"> | string
    materialContentTypeId?: IntWithAggregatesFilter<"MaterialContent"> | number
    order?: IntWithAggregatesFilter<"MaterialContent"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MaterialContent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MaterialContent"> | Date | string
    slug?: StringWithAggregatesFilter<"MaterialContent"> | string
    syllabusContentId?: IntWithAggregatesFilter<"MaterialContent"> | number
    estimatedTime?: IntWithAggregatesFilter<"MaterialContent"> | number
  }

  export type MaterialContentLearningWhereInput = {
    AND?: MaterialContentLearningWhereInput | MaterialContentLearningWhereInput[]
    OR?: MaterialContentLearningWhereInput[]
    NOT?: MaterialContentLearningWhereInput | MaterialContentLearningWhereInput[]
    id?: IntFilter<"MaterialContentLearning"> | number
    materialContentId?: IntFilter<"MaterialContentLearning"> | number
    content?: StringFilter<"MaterialContentLearning"> | string
    MaterialContent?: XOR<MaterialContentRelationFilter, MaterialContentWhereInput>
  }

  export type MaterialContentLearningOrderByWithRelationInput = {
    id?: SortOrder
    materialContentId?: SortOrder
    content?: SortOrder
    MaterialContent?: MaterialContentOrderByWithRelationInput
  }

  export type MaterialContentLearningWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    materialContentId?: number
    AND?: MaterialContentLearningWhereInput | MaterialContentLearningWhereInput[]
    OR?: MaterialContentLearningWhereInput[]
    NOT?: MaterialContentLearningWhereInput | MaterialContentLearningWhereInput[]
    content?: StringFilter<"MaterialContentLearning"> | string
    MaterialContent?: XOR<MaterialContentRelationFilter, MaterialContentWhereInput>
  }, "id" | "materialContentId">

  export type MaterialContentLearningOrderByWithAggregationInput = {
    id?: SortOrder
    materialContentId?: SortOrder
    content?: SortOrder
    _count?: MaterialContentLearningCountOrderByAggregateInput
    _avg?: MaterialContentLearningAvgOrderByAggregateInput
    _max?: MaterialContentLearningMaxOrderByAggregateInput
    _min?: MaterialContentLearningMinOrderByAggregateInput
    _sum?: MaterialContentLearningSumOrderByAggregateInput
  }

  export type MaterialContentLearningScalarWhereWithAggregatesInput = {
    AND?: MaterialContentLearningScalarWhereWithAggregatesInput | MaterialContentLearningScalarWhereWithAggregatesInput[]
    OR?: MaterialContentLearningScalarWhereWithAggregatesInput[]
    NOT?: MaterialContentLearningScalarWhereWithAggregatesInput | MaterialContentLearningScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MaterialContentLearning"> | number
    materialContentId?: IntWithAggregatesFilter<"MaterialContentLearning"> | number
    content?: StringWithAggregatesFilter<"MaterialContentLearning"> | string
  }

  export type MaterialContentTestWhereInput = {
    AND?: MaterialContentTestWhereInput | MaterialContentTestWhereInput[]
    OR?: MaterialContentTestWhereInput[]
    NOT?: MaterialContentTestWhereInput | MaterialContentTestWhereInput[]
    id?: IntFilter<"MaterialContentTest"> | number
    materialContentId?: IntFilter<"MaterialContentTest"> | number
    MaterialContent?: XOR<MaterialContentRelationFilter, MaterialContentWhereInput>
  }

  export type MaterialContentTestOrderByWithRelationInput = {
    id?: SortOrder
    materialContentId?: SortOrder
    MaterialContent?: MaterialContentOrderByWithRelationInput
  }

  export type MaterialContentTestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    materialContentId?: number
    AND?: MaterialContentTestWhereInput | MaterialContentTestWhereInput[]
    OR?: MaterialContentTestWhereInput[]
    NOT?: MaterialContentTestWhereInput | MaterialContentTestWhereInput[]
    MaterialContent?: XOR<MaterialContentRelationFilter, MaterialContentWhereInput>
  }, "id" | "materialContentId">

  export type MaterialContentTestOrderByWithAggregationInput = {
    id?: SortOrder
    materialContentId?: SortOrder
    _count?: MaterialContentTestCountOrderByAggregateInput
    _avg?: MaterialContentTestAvgOrderByAggregateInput
    _max?: MaterialContentTestMaxOrderByAggregateInput
    _min?: MaterialContentTestMinOrderByAggregateInput
    _sum?: MaterialContentTestSumOrderByAggregateInput
  }

  export type MaterialContentTestScalarWhereWithAggregatesInput = {
    AND?: MaterialContentTestScalarWhereWithAggregatesInput | MaterialContentTestScalarWhereWithAggregatesInput[]
    OR?: MaterialContentTestScalarWhereWithAggregatesInput[]
    NOT?: MaterialContentTestScalarWhereWithAggregatesInput | MaterialContentTestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MaterialContentTest"> | number
    materialContentId?: IntWithAggregatesFilter<"MaterialContentTest"> | number
  }

  export type MaterialContentFileWhereInput = {
    AND?: MaterialContentFileWhereInput | MaterialContentFileWhereInput[]
    OR?: MaterialContentFileWhereInput[]
    NOT?: MaterialContentFileWhereInput | MaterialContentFileWhereInput[]
    id?: IntFilter<"MaterialContentFile"> | number
    materialContentId?: IntFilter<"MaterialContentFile"> | number
    createdAt?: DateTimeFilter<"MaterialContentFile"> | Date | string
    updatedAt?: DateTimeFilter<"MaterialContentFile"> | Date | string
    materialContent?: XOR<MaterialContentRelationFilter, MaterialContentWhereInput>
  }

  export type MaterialContentFileOrderByWithRelationInput = {
    id?: SortOrder
    materialContentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    materialContent?: MaterialContentOrderByWithRelationInput
  }

  export type MaterialContentFileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    materialContentId?: number
    AND?: MaterialContentFileWhereInput | MaterialContentFileWhereInput[]
    OR?: MaterialContentFileWhereInput[]
    NOT?: MaterialContentFileWhereInput | MaterialContentFileWhereInput[]
    createdAt?: DateTimeFilter<"MaterialContentFile"> | Date | string
    updatedAt?: DateTimeFilter<"MaterialContentFile"> | Date | string
    materialContent?: XOR<MaterialContentRelationFilter, MaterialContentWhereInput>
  }, "id" | "materialContentId">

  export type MaterialContentFileOrderByWithAggregationInput = {
    id?: SortOrder
    materialContentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MaterialContentFileCountOrderByAggregateInput
    _avg?: MaterialContentFileAvgOrderByAggregateInput
    _max?: MaterialContentFileMaxOrderByAggregateInput
    _min?: MaterialContentFileMinOrderByAggregateInput
    _sum?: MaterialContentFileSumOrderByAggregateInput
  }

  export type MaterialContentFileScalarWhereWithAggregatesInput = {
    AND?: MaterialContentFileScalarWhereWithAggregatesInput | MaterialContentFileScalarWhereWithAggregatesInput[]
    OR?: MaterialContentFileScalarWhereWithAggregatesInput[]
    NOT?: MaterialContentFileScalarWhereWithAggregatesInput | MaterialContentFileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MaterialContentFile"> | number
    materialContentId?: IntWithAggregatesFilter<"MaterialContentFile"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MaterialContentFile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MaterialContentFile"> | Date | string
  }

  export type MaterialContentAttachmentWhereInput = {
    AND?: MaterialContentAttachmentWhereInput | MaterialContentAttachmentWhereInput[]
    OR?: MaterialContentAttachmentWhereInput[]
    NOT?: MaterialContentAttachmentWhereInput | MaterialContentAttachmentWhereInput[]
    id?: IntFilter<"MaterialContentAttachment"> | number
    thumbnail?: StringFilter<"MaterialContentAttachment"> | string
    path?: StringFilter<"MaterialContentAttachment"> | string
    materialContentId?: IntFilter<"MaterialContentAttachment"> | number
    createdAt?: DateTimeFilter<"MaterialContentAttachment"> | Date | string
    updatedAt?: DateTimeFilter<"MaterialContentAttachment"> | Date | string
    MaterialContent?: XOR<MaterialContentRelationFilter, MaterialContentWhereInput>
  }

  export type MaterialContentAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    thumbnail?: SortOrder
    path?: SortOrder
    materialContentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    MaterialContent?: MaterialContentOrderByWithRelationInput
  }

  export type MaterialContentAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MaterialContentAttachmentWhereInput | MaterialContentAttachmentWhereInput[]
    OR?: MaterialContentAttachmentWhereInput[]
    NOT?: MaterialContentAttachmentWhereInput | MaterialContentAttachmentWhereInput[]
    thumbnail?: StringFilter<"MaterialContentAttachment"> | string
    path?: StringFilter<"MaterialContentAttachment"> | string
    materialContentId?: IntFilter<"MaterialContentAttachment"> | number
    createdAt?: DateTimeFilter<"MaterialContentAttachment"> | Date | string
    updatedAt?: DateTimeFilter<"MaterialContentAttachment"> | Date | string
    MaterialContent?: XOR<MaterialContentRelationFilter, MaterialContentWhereInput>
  }, "id">

  export type MaterialContentAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    thumbnail?: SortOrder
    path?: SortOrder
    materialContentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MaterialContentAttachmentCountOrderByAggregateInput
    _avg?: MaterialContentAttachmentAvgOrderByAggregateInput
    _max?: MaterialContentAttachmentMaxOrderByAggregateInput
    _min?: MaterialContentAttachmentMinOrderByAggregateInput
    _sum?: MaterialContentAttachmentSumOrderByAggregateInput
  }

  export type MaterialContentAttachmentScalarWhereWithAggregatesInput = {
    AND?: MaterialContentAttachmentScalarWhereWithAggregatesInput | MaterialContentAttachmentScalarWhereWithAggregatesInput[]
    OR?: MaterialContentAttachmentScalarWhereWithAggregatesInput[]
    NOT?: MaterialContentAttachmentScalarWhereWithAggregatesInput | MaterialContentAttachmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MaterialContentAttachment"> | number
    thumbnail?: StringWithAggregatesFilter<"MaterialContentAttachment"> | string
    path?: StringWithAggregatesFilter<"MaterialContentAttachment"> | string
    materialContentId?: IntWithAggregatesFilter<"MaterialContentAttachment"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MaterialContentAttachment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MaterialContentAttachment"> | Date | string
  }

  export type UsersCreateInput = {
    gid: string
    full_name?: string | null
    email?: string | null
    phone?: string | null
    school?: string | null
    user_type?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    CourseCreator?: CourseCreatorCreateNestedManyWithoutUserInput
    CourseLogging?: CourseLoggingCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateInput = {
    gid: string
    full_name?: string | null
    email?: string | null
    phone?: string | null
    school?: string | null
    user_type?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    CourseCreator?: CourseCreatorUncheckedCreateNestedManyWithoutUserInput
    CourseLogging?: CourseLoggingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersUpdateInput = {
    gid?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    user_type?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CourseCreator?: CourseCreatorUpdateManyWithoutUserNestedInput
    CourseLogging?: CourseLoggingUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateInput = {
    gid?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    user_type?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CourseCreator?: CourseCreatorUncheckedUpdateManyWithoutUserNestedInput
    CourseLogging?: CourseLoggingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UsersCreateManyInput = {
    gid: string
    full_name?: string | null
    email?: string | null
    phone?: string | null
    school?: string | null
    user_type?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsersUpdateManyMutationInput = {
    gid?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    user_type?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsersUncheckedUpdateManyInput = {
    gid?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    user_type?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseCreateInput = {
    title: string
    description: string
    cover: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    price: number
    slug: string
    CourseLoggings?: CourseLoggingCreateNestedManyWithoutCourseInput
    CourseTopics?: CourseTopicCreateNestedManyWithoutCourseInput
    Syllabus?: SyllabusCreateNestedManyWithoutCourseInput
    CourseCreator?: CourseCreatorCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateInput = {
    id?: number
    title: string
    description: string
    cover: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    price: number
    slug: string
    CourseLoggings?: CourseLoggingUncheckedCreateNestedManyWithoutCourseInput
    CourseTopics?: CourseTopicUncheckedCreateNestedManyWithoutCourseInput
    Syllabus?: SyllabusUncheckedCreateNestedManyWithoutCourseInput
    CourseCreator?: CourseCreatorUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    CourseLoggings?: CourseLoggingUpdateManyWithoutCourseNestedInput
    CourseTopics?: CourseTopicUpdateManyWithoutCourseNestedInput
    Syllabus?: SyllabusUpdateManyWithoutCourseNestedInput
    CourseCreator?: CourseCreatorUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    CourseLoggings?: CourseLoggingUncheckedUpdateManyWithoutCourseNestedInput
    CourseTopics?: CourseTopicUncheckedUpdateManyWithoutCourseNestedInput
    Syllabus?: SyllabusUncheckedUpdateManyWithoutCourseNestedInput
    CourseCreator?: CourseCreatorUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateManyInput = {
    id?: number
    title: string
    description: string
    cover: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    price: number
    slug: string
  }

  export type CourseUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type CourseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type CourseCreatorCreateInput = {
    as: $Enums.CourseAs
    createdAt?: Date | string
    updatedAt?: Date | string
    Course: CourseCreateNestedOneWithoutCourseCreatorInput
    User: UsersCreateNestedOneWithoutCourseCreatorInput
  }

  export type CourseCreatorUncheckedCreateInput = {
    id?: number
    courseId: number
    userId: string
    as: $Enums.CourseAs
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseCreatorUpdateInput = {
    as?: EnumCourseAsFieldUpdateOperationsInput | $Enums.CourseAs
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Course?: CourseUpdateOneRequiredWithoutCourseCreatorNestedInput
    User?: UsersUpdateOneRequiredWithoutCourseCreatorNestedInput
  }

  export type CourseCreatorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    as?: EnumCourseAsFieldUpdateOperationsInput | $Enums.CourseAs
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseCreatorCreateManyInput = {
    id?: number
    courseId: number
    userId: string
    as: $Enums.CourseAs
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseCreatorUpdateManyMutationInput = {
    as?: EnumCourseAsFieldUpdateOperationsInput | $Enums.CourseAs
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseCreatorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    as?: EnumCourseAsFieldUpdateOperationsInput | $Enums.CourseAs
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseLoggingCreateInput = {
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Course: CourseCreateNestedOneWithoutCourseLoggingsInput
    User: UsersCreateNestedOneWithoutCourseLoggingInput
    SyllabusContent: SyllabusContentCreateNestedOneWithoutCourseLoggingInput
    MaterialContent?: MaterialContentCreateNestedOneWithoutCourseLoggingInput
    Exam?: ExamCreateNestedOneWithoutCourseLoggingInput
  }

  export type CourseLoggingUncheckedCreateInput = {
    id?: number
    courseId: number
    userId: string
    syllabusContentId: number
    materialContentId?: number | null
    examId?: number | null
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseLoggingUpdateInput = {
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Course?: CourseUpdateOneRequiredWithoutCourseLoggingsNestedInput
    User?: UsersUpdateOneRequiredWithoutCourseLoggingNestedInput
    SyllabusContent?: SyllabusContentUpdateOneRequiredWithoutCourseLoggingNestedInput
    MaterialContent?: MaterialContentUpdateOneWithoutCourseLoggingNestedInput
    Exam?: ExamUpdateOneWithoutCourseLoggingNestedInput
  }

  export type CourseLoggingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    syllabusContentId?: IntFieldUpdateOperationsInput | number
    materialContentId?: NullableIntFieldUpdateOperationsInput | number | null
    examId?: NullableIntFieldUpdateOperationsInput | number | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseLoggingCreateManyInput = {
    id?: number
    courseId: number
    userId: string
    syllabusContentId: number
    materialContentId?: number | null
    examId?: number | null
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseLoggingUpdateManyMutationInput = {
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseLoggingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    syllabusContentId?: IntFieldUpdateOperationsInput | number
    materialContentId?: NullableIntFieldUpdateOperationsInput | number | null
    examId?: NullableIntFieldUpdateOperationsInput | number | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    title: string
    isActive?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    SubCategories?: SubCategoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: number
    title: string
    isActive?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    SubCategories?: SubCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    SubCategories?: SubCategoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    SubCategories?: SubCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: number
    title: string
    isActive?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
  }

  export type CategoryUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type SubCategoryCreateInput = {
    title: string
    isActive?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    Category: CategoryCreateNestedOneWithoutSubCategoriesInput
    Topics?: TopicCreateNestedManyWithoutSubCategoryInput
  }

  export type SubCategoryUncheckedCreateInput = {
    id?: number
    title: string
    isActive?: boolean
    categoryId: number
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    Topics?: TopicUncheckedCreateNestedManyWithoutSubCategoryInput
  }

  export type SubCategoryUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    Category?: CategoryUpdateOneRequiredWithoutSubCategoriesNestedInput
    Topics?: TopicUpdateManyWithoutSubCategoryNestedInput
  }

  export type SubCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    Topics?: TopicUncheckedUpdateManyWithoutSubCategoryNestedInput
  }

  export type SubCategoryCreateManyInput = {
    id?: number
    title: string
    isActive?: boolean
    categoryId: number
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
  }

  export type SubCategoryUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type SubCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type TopicCreateInput = {
    title: string
    isActive?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    CourseTopics?: CourseTopicCreateNestedManyWithoutTopicInput
    SubCategory: SubCategoryCreateNestedOneWithoutTopicsInput
  }

  export type TopicUncheckedCreateInput = {
    id?: number
    title: string
    isActive?: boolean
    subCategoryId: number
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    CourseTopics?: CourseTopicUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    CourseTopics?: CourseTopicUpdateManyWithoutTopicNestedInput
    SubCategory?: SubCategoryUpdateOneRequiredWithoutTopicsNestedInput
  }

  export type TopicUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subCategoryId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    CourseTopics?: CourseTopicUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type TopicCreateManyInput = {
    id?: number
    title: string
    isActive?: boolean
    subCategoryId: number
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
  }

  export type TopicUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type TopicUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subCategoryId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type CourseTopicCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    Course: CourseCreateNestedOneWithoutCourseTopicsInput
    Topic: TopicCreateNestedOneWithoutCourseTopicsInput
  }

  export type CourseTopicUncheckedCreateInput = {
    id?: number
    courseId: number
    topicId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseTopicUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Course?: CourseUpdateOneRequiredWithoutCourseTopicsNestedInput
    Topic?: TopicUpdateOneRequiredWithoutCourseTopicsNestedInput
  }

  export type CourseTopicUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    topicId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseTopicCreateManyInput = {
    id?: number
    courseId: number
    topicId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseTopicUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseTopicUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    topicId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyllabusCreateInput = {
    title: string
    description: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Course: CourseCreateNestedOneWithoutSyllabusInput
    SyllabusContent?: SyllabusContentCreateNestedManyWithoutSyllabusInput
  }

  export type SyllabusUncheckedCreateInput = {
    id?: number
    title: string
    description: string
    courseId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    SyllabusContent?: SyllabusContentUncheckedCreateNestedManyWithoutSyllabusInput
  }

  export type SyllabusUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Course?: CourseUpdateOneRequiredWithoutSyllabusNestedInput
    SyllabusContent?: SyllabusContentUpdateManyWithoutSyllabusNestedInput
  }

  export type SyllabusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    courseId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SyllabusContent?: SyllabusContentUncheckedUpdateManyWithoutSyllabusNestedInput
  }

  export type SyllabusCreateManyInput = {
    id?: number
    title: string
    description: string
    courseId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SyllabusUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyllabusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    courseId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyllabusContentCreateInput = {
    title: string
    type: $Enums.SyllabusContentType
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    Exams?: ExamCreateNestedManyWithoutSyllabusContentInput
    MaterialContents?: MaterialContentCreateNestedManyWithoutSyllabusContentInput
    Syllabus: SyllabusCreateNestedOneWithoutSyllabusContentInput
    CourseLogging?: CourseLoggingCreateNestedManyWithoutSyllabusContentInput
  }

  export type SyllabusContentUncheckedCreateInput = {
    id?: number
    syllabusId: number
    title: string
    type: $Enums.SyllabusContentType
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    Exams?: ExamUncheckedCreateNestedManyWithoutSyllabusContentInput
    MaterialContents?: MaterialContentUncheckedCreateNestedManyWithoutSyllabusContentInput
    CourseLogging?: CourseLoggingUncheckedCreateNestedManyWithoutSyllabusContentInput
  }

  export type SyllabusContentUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumSyllabusContentTypeFieldUpdateOperationsInput | $Enums.SyllabusContentType
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    Exams?: ExamUpdateManyWithoutSyllabusContentNestedInput
    MaterialContents?: MaterialContentUpdateManyWithoutSyllabusContentNestedInput
    Syllabus?: SyllabusUpdateOneRequiredWithoutSyllabusContentNestedInput
    CourseLogging?: CourseLoggingUpdateManyWithoutSyllabusContentNestedInput
  }

  export type SyllabusContentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    syllabusId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumSyllabusContentTypeFieldUpdateOperationsInput | $Enums.SyllabusContentType
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    Exams?: ExamUncheckedUpdateManyWithoutSyllabusContentNestedInput
    MaterialContents?: MaterialContentUncheckedUpdateManyWithoutSyllabusContentNestedInput
    CourseLogging?: CourseLoggingUncheckedUpdateManyWithoutSyllabusContentNestedInput
  }

  export type SyllabusContentCreateManyInput = {
    id?: number
    syllabusId: number
    title: string
    type: $Enums.SyllabusContentType
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
  }

  export type SyllabusContentUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumSyllabusContentTypeFieldUpdateOperationsInput | $Enums.SyllabusContentType
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type SyllabusContentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    syllabusId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumSyllabusContentTypeFieldUpdateOperationsInput | $Enums.SyllabusContentType
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type ExamCreateInput = {
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    SyllabusContent: SyllabusContentCreateNestedOneWithoutExamsInput
    ExamQuestions?: ExamQuestionCreateNestedManyWithoutExamInput
    CourseLogging?: CourseLoggingCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateInput = {
    id?: number
    title: string
    syllabusContentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    ExamQuestions?: ExamQuestionUncheckedCreateNestedManyWithoutExamInput
    CourseLogging?: CourseLoggingUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    SyllabusContent?: SyllabusContentUpdateOneRequiredWithoutExamsNestedInput
    ExamQuestions?: ExamQuestionUpdateManyWithoutExamNestedInput
    CourseLogging?: CourseLoggingUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    syllabusContentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    ExamQuestions?: ExamQuestionUncheckedUpdateManyWithoutExamNestedInput
    CourseLogging?: CourseLoggingUncheckedUpdateManyWithoutExamNestedInput
  }

  export type ExamCreateManyInput = {
    id?: number
    title: string
    syllabusContentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
  }

  export type ExamUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ExamUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    syllabusContentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ExamQuestionCreateInput = {
    isActive: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    questionText: string
    typeQuestion: $Enums.TypeQuestion
    Exam: ExamCreateNestedOneWithoutExamQuestionsInput
    ExamOptions?: ExamOptionQuestionCreateNestedManyWithoutExamQuestionInput
  }

  export type ExamQuestionUncheckedCreateInput = {
    id?: number
    isActive: boolean
    examId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    questionText: string
    typeQuestion: $Enums.TypeQuestion
    ExamOptions?: ExamOptionQuestionUncheckedCreateNestedManyWithoutExamQuestionInput
  }

  export type ExamQuestionUpdateInput = {
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    questionText?: StringFieldUpdateOperationsInput | string
    typeQuestion?: EnumTypeQuestionFieldUpdateOperationsInput | $Enums.TypeQuestion
    Exam?: ExamUpdateOneRequiredWithoutExamQuestionsNestedInput
    ExamOptions?: ExamOptionQuestionUpdateManyWithoutExamQuestionNestedInput
  }

  export type ExamQuestionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    examId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    questionText?: StringFieldUpdateOperationsInput | string
    typeQuestion?: EnumTypeQuestionFieldUpdateOperationsInput | $Enums.TypeQuestion
    ExamOptions?: ExamOptionQuestionUncheckedUpdateManyWithoutExamQuestionNestedInput
  }

  export type ExamQuestionCreateManyInput = {
    id?: number
    isActive: boolean
    examId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    questionText: string
    typeQuestion: $Enums.TypeQuestion
  }

  export type ExamQuestionUpdateManyMutationInput = {
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    questionText?: StringFieldUpdateOperationsInput | string
    typeQuestion?: EnumTypeQuestionFieldUpdateOperationsInput | $Enums.TypeQuestion
  }

  export type ExamQuestionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    examId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    questionText?: StringFieldUpdateOperationsInput | string
    typeQuestion?: EnumTypeQuestionFieldUpdateOperationsInput | $Enums.TypeQuestion
  }

  export type ExamOptionQuestionCreateInput = {
    optionText: string
    isTrue?: boolean | null
    reason?: string | null
    order?: number | null
    attachment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ExamQuestion: ExamQuestionCreateNestedOneWithoutExamOptionsInput
  }

  export type ExamOptionQuestionUncheckedCreateInput = {
    id?: number
    optionText: string
    isTrue?: boolean | null
    reason?: string | null
    order?: number | null
    attachment?: string | null
    examQuestionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamOptionQuestionUpdateInput = {
    optionText?: StringFieldUpdateOperationsInput | string
    isTrue?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ExamQuestion?: ExamQuestionUpdateOneRequiredWithoutExamOptionsNestedInput
  }

  export type ExamOptionQuestionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    optionText?: StringFieldUpdateOperationsInput | string
    isTrue?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    examQuestionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamOptionQuestionCreateManyInput = {
    id?: number
    optionText: string
    isTrue?: boolean | null
    reason?: string | null
    order?: number | null
    attachment?: string | null
    examQuestionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamOptionQuestionUpdateManyMutationInput = {
    optionText?: StringFieldUpdateOperationsInput | string
    isTrue?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamOptionQuestionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    optionText?: StringFieldUpdateOperationsInput | string
    isTrue?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    examQuestionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialContentTypeCreateInput = {
    title: $Enums.TypeMaterialContent
    MaterialContents?: MaterialContentCreateNestedManyWithoutTypeInput
  }

  export type MaterialContentTypeUncheckedCreateInput = {
    id?: number
    title: $Enums.TypeMaterialContent
    MaterialContents?: MaterialContentUncheckedCreateNestedManyWithoutTypeInput
  }

  export type MaterialContentTypeUpdateInput = {
    title?: EnumTypeMaterialContentFieldUpdateOperationsInput | $Enums.TypeMaterialContent
    MaterialContents?: MaterialContentUpdateManyWithoutTypeNestedInput
  }

  export type MaterialContentTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: EnumTypeMaterialContentFieldUpdateOperationsInput | $Enums.TypeMaterialContent
    MaterialContents?: MaterialContentUncheckedUpdateManyWithoutTypeNestedInput
  }

  export type MaterialContentTypeCreateManyInput = {
    id?: number
    title: $Enums.TypeMaterialContent
  }

  export type MaterialContentTypeUpdateManyMutationInput = {
    title?: EnumTypeMaterialContentFieldUpdateOperationsInput | $Enums.TypeMaterialContent
  }

  export type MaterialContentTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: EnumTypeMaterialContentFieldUpdateOperationsInput | $Enums.TypeMaterialContent
  }

  export type MaterialContentCreateInput = {
    title: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    estimatedTime: number
    Type: MaterialContentTypeCreateNestedOneWithoutMaterialContentsInput
    SyllabusContent: SyllabusContentCreateNestedOneWithoutMaterialContentsInput
    Attachments?: MaterialContentAttachmentCreateNestedManyWithoutMaterialContentInput
    File?: MaterialContentFileCreateNestedOneWithoutMaterialContentInput
    MaterialContentLearning?: MaterialContentLearningCreateNestedOneWithoutMaterialContentInput
    MaterialContentTest?: MaterialContentTestCreateNestedOneWithoutMaterialContentInput
    CourseLogging?: CourseLoggingCreateNestedManyWithoutMaterialContentInput
  }

  export type MaterialContentUncheckedCreateInput = {
    id?: number
    title: string
    materialContentTypeId: number
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    syllabusContentId: number
    estimatedTime: number
    Attachments?: MaterialContentAttachmentUncheckedCreateNestedManyWithoutMaterialContentInput
    File?: MaterialContentFileUncheckedCreateNestedOneWithoutMaterialContentInput
    MaterialContentLearning?: MaterialContentLearningUncheckedCreateNestedOneWithoutMaterialContentInput
    MaterialContentTest?: MaterialContentTestUncheckedCreateNestedOneWithoutMaterialContentInput
    CourseLogging?: CourseLoggingUncheckedCreateNestedManyWithoutMaterialContentInput
  }

  export type MaterialContentUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    estimatedTime?: IntFieldUpdateOperationsInput | number
    Type?: MaterialContentTypeUpdateOneRequiredWithoutMaterialContentsNestedInput
    SyllabusContent?: SyllabusContentUpdateOneRequiredWithoutMaterialContentsNestedInput
    Attachments?: MaterialContentAttachmentUpdateManyWithoutMaterialContentNestedInput
    File?: MaterialContentFileUpdateOneWithoutMaterialContentNestedInput
    MaterialContentLearning?: MaterialContentLearningUpdateOneWithoutMaterialContentNestedInput
    MaterialContentTest?: MaterialContentTestUpdateOneWithoutMaterialContentNestedInput
    CourseLogging?: CourseLoggingUpdateManyWithoutMaterialContentNestedInput
  }

  export type MaterialContentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    materialContentTypeId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    syllabusContentId?: IntFieldUpdateOperationsInput | number
    estimatedTime?: IntFieldUpdateOperationsInput | number
    Attachments?: MaterialContentAttachmentUncheckedUpdateManyWithoutMaterialContentNestedInput
    File?: MaterialContentFileUncheckedUpdateOneWithoutMaterialContentNestedInput
    MaterialContentLearning?: MaterialContentLearningUncheckedUpdateOneWithoutMaterialContentNestedInput
    MaterialContentTest?: MaterialContentTestUncheckedUpdateOneWithoutMaterialContentNestedInput
    CourseLogging?: CourseLoggingUncheckedUpdateManyWithoutMaterialContentNestedInput
  }

  export type MaterialContentCreateManyInput = {
    id?: number
    title: string
    materialContentTypeId: number
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    syllabusContentId: number
    estimatedTime: number
  }

  export type MaterialContentUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    estimatedTime?: IntFieldUpdateOperationsInput | number
  }

  export type MaterialContentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    materialContentTypeId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    syllabusContentId?: IntFieldUpdateOperationsInput | number
    estimatedTime?: IntFieldUpdateOperationsInput | number
  }

  export type MaterialContentLearningCreateInput = {
    content: string
    MaterialContent: MaterialContentCreateNestedOneWithoutMaterialContentLearningInput
  }

  export type MaterialContentLearningUncheckedCreateInput = {
    id?: number
    materialContentId: number
    content: string
  }

  export type MaterialContentLearningUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    MaterialContent?: MaterialContentUpdateOneRequiredWithoutMaterialContentLearningNestedInput
  }

  export type MaterialContentLearningUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialContentId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
  }

  export type MaterialContentLearningCreateManyInput = {
    id?: number
    materialContentId: number
    content: string
  }

  export type MaterialContentLearningUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
  }

  export type MaterialContentLearningUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialContentId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
  }

  export type MaterialContentTestCreateInput = {
    MaterialContent: MaterialContentCreateNestedOneWithoutMaterialContentTestInput
  }

  export type MaterialContentTestUncheckedCreateInput = {
    id?: number
    materialContentId: number
  }

  export type MaterialContentTestUpdateInput = {
    MaterialContent?: MaterialContentUpdateOneRequiredWithoutMaterialContentTestNestedInput
  }

  export type MaterialContentTestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialContentId?: IntFieldUpdateOperationsInput | number
  }

  export type MaterialContentTestCreateManyInput = {
    id?: number
    materialContentId: number
  }

  export type MaterialContentTestUpdateManyMutationInput = {

  }

  export type MaterialContentTestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialContentId?: IntFieldUpdateOperationsInput | number
  }

  export type MaterialContentFileCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    materialContent: MaterialContentCreateNestedOneWithoutFileInput
  }

  export type MaterialContentFileUncheckedCreateInput = {
    id?: number
    materialContentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialContentFileUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materialContent?: MaterialContentUpdateOneRequiredWithoutFileNestedInput
  }

  export type MaterialContentFileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialContentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialContentFileCreateManyInput = {
    id?: number
    materialContentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialContentFileUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialContentFileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialContentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialContentAttachmentCreateInput = {
    thumbnail: string
    path: string
    createdAt?: Date | string
    updatedAt?: Date | string
    MaterialContent: MaterialContentCreateNestedOneWithoutAttachmentsInput
  }

  export type MaterialContentAttachmentUncheckedCreateInput = {
    id?: number
    thumbnail: string
    path: string
    materialContentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialContentAttachmentUpdateInput = {
    thumbnail?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MaterialContent?: MaterialContentUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type MaterialContentAttachmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    thumbnail?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    materialContentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialContentAttachmentCreateManyInput = {
    id?: number
    thumbnail: string
    path: string
    materialContentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialContentAttachmentUpdateManyMutationInput = {
    thumbnail?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialContentAttachmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    thumbnail?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    materialContentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CourseCreatorListRelationFilter = {
    every?: CourseCreatorWhereInput
    some?: CourseCreatorWhereInput
    none?: CourseCreatorWhereInput
  }

  export type CourseLoggingListRelationFilter = {
    every?: CourseLoggingWhereInput
    some?: CourseLoggingWhereInput
    none?: CourseLoggingWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CourseCreatorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseLoggingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsersCountOrderByAggregateInput = {
    gid?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    school?: SortOrder
    user_type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsersAvgOrderByAggregateInput = {
    user_type?: SortOrder
  }

  export type UsersMaxOrderByAggregateInput = {
    gid?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    school?: SortOrder
    user_type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsersMinOrderByAggregateInput = {
    gid?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    school?: SortOrder
    user_type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsersSumOrderByAggregateInput = {
    user_type?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CourseTopicListRelationFilter = {
    every?: CourseTopicWhereInput
    some?: CourseTopicWhereInput
    none?: CourseTopicWhereInput
  }

  export type SyllabusListRelationFilter = {
    every?: SyllabusWhereInput
    some?: SyllabusWhereInput
    none?: SyllabusWhereInput
  }

  export type CourseTopicOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SyllabusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    cover?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    price?: SortOrder
    slug?: SortOrder
  }

  export type CourseAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type CourseMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    cover?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    price?: SortOrder
    slug?: SortOrder
  }

  export type CourseMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    cover?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    price?: SortOrder
    slug?: SortOrder
  }

  export type CourseSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumCourseAsFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseAs | EnumCourseAsFieldRefInput<$PrismaModel>
    in?: $Enums.CourseAs[]
    notIn?: $Enums.CourseAs[]
    not?: NestedEnumCourseAsFilter<$PrismaModel> | $Enums.CourseAs
  }

  export type CourseRelationFilter = {
    is?: CourseWhereInput
    isNot?: CourseWhereInput
  }

  export type UsersRelationFilter = {
    is?: UsersWhereInput
    isNot?: UsersWhereInput
  }

  export type CourseCreatorCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    userId?: SortOrder
    as?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseCreatorAvgOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
  }

  export type CourseCreatorMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    userId?: SortOrder
    as?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseCreatorMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    userId?: SortOrder
    as?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseCreatorSumOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
  }

  export type EnumCourseAsWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseAs | EnumCourseAsFieldRefInput<$PrismaModel>
    in?: $Enums.CourseAs[]
    notIn?: $Enums.CourseAs[]
    not?: NestedEnumCourseAsWithAggregatesFilter<$PrismaModel> | $Enums.CourseAs
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourseAsFilter<$PrismaModel>
    _max?: NestedEnumCourseAsFilter<$PrismaModel>
  }

  export type SyllabusContentRelationFilter = {
    is?: SyllabusContentWhereInput
    isNot?: SyllabusContentWhereInput
  }

  export type MaterialContentNullableRelationFilter = {
    is?: MaterialContentWhereInput | null
    isNot?: MaterialContentWhereInput | null
  }

  export type ExamNullableRelationFilter = {
    is?: ExamWhereInput | null
    isNot?: ExamWhereInput | null
  }

  export type CourseLoggingCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    userId?: SortOrder
    syllabusContentId?: SortOrder
    materialContentId?: SortOrder
    examId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseLoggingAvgOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    syllabusContentId?: SortOrder
    materialContentId?: SortOrder
    examId?: SortOrder
  }

  export type CourseLoggingMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    userId?: SortOrder
    syllabusContentId?: SortOrder
    materialContentId?: SortOrder
    examId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseLoggingMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    userId?: SortOrder
    syllabusContentId?: SortOrder
    materialContentId?: SortOrder
    examId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseLoggingSumOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    syllabusContentId?: SortOrder
    materialContentId?: SortOrder
    examId?: SortOrder
  }

  export type SubCategoryListRelationFilter = {
    every?: SubCategoryWhereInput
    some?: SubCategoryWhereInput
    none?: SubCategoryWhereInput
  }

  export type SubCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    isActive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    slug?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    isActive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    slug?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    isActive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    slug?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
  }

  export type CategoryRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type TopicListRelationFilter = {
    every?: TopicWhereInput
    some?: TopicWhereInput
    none?: TopicWhereInput
  }

  export type TopicOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    isActive?: SortOrder
    categoryId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    slug?: SortOrder
  }

  export type SubCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    order?: SortOrder
  }

  export type SubCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    isActive?: SortOrder
    categoryId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    slug?: SortOrder
  }

  export type SubCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    isActive?: SortOrder
    categoryId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    slug?: SortOrder
  }

  export type SubCategorySumOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    order?: SortOrder
  }

  export type SubCategoryRelationFilter = {
    is?: SubCategoryWhereInput
    isNot?: SubCategoryWhereInput
  }

  export type TopicCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    isActive?: SortOrder
    subCategoryId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    slug?: SortOrder
  }

  export type TopicAvgOrderByAggregateInput = {
    id?: SortOrder
    subCategoryId?: SortOrder
    order?: SortOrder
  }

  export type TopicMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    isActive?: SortOrder
    subCategoryId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    slug?: SortOrder
  }

  export type TopicMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    isActive?: SortOrder
    subCategoryId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    slug?: SortOrder
  }

  export type TopicSumOrderByAggregateInput = {
    id?: SortOrder
    subCategoryId?: SortOrder
    order?: SortOrder
  }

  export type TopicRelationFilter = {
    is?: TopicWhereInput
    isNot?: TopicWhereInput
  }

  export type CourseTopicCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseTopicAvgOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    topicId?: SortOrder
  }

  export type CourseTopicMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseTopicMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseTopicSumOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    topicId?: SortOrder
  }

  export type SyllabusContentListRelationFilter = {
    every?: SyllabusContentWhereInput
    some?: SyllabusContentWhereInput
    none?: SyllabusContentWhereInput
  }

  export type SyllabusContentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SyllabusCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    courseId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SyllabusAvgOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
  }

  export type SyllabusMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    courseId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SyllabusMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    courseId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SyllabusSumOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
  }

  export type EnumSyllabusContentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SyllabusContentType | EnumSyllabusContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SyllabusContentType[]
    notIn?: $Enums.SyllabusContentType[]
    not?: NestedEnumSyllabusContentTypeFilter<$PrismaModel> | $Enums.SyllabusContentType
  }

  export type ExamListRelationFilter = {
    every?: ExamWhereInput
    some?: ExamWhereInput
    none?: ExamWhereInput
  }

  export type MaterialContentListRelationFilter = {
    every?: MaterialContentWhereInput
    some?: MaterialContentWhereInput
    none?: MaterialContentWhereInput
  }

  export type SyllabusRelationFilter = {
    is?: SyllabusWhereInput
    isNot?: SyllabusWhereInput
  }

  export type ExamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaterialContentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SyllabusContentCountOrderByAggregateInput = {
    id?: SortOrder
    syllabusId?: SortOrder
    title?: SortOrder
    type?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    slug?: SortOrder
  }

  export type SyllabusContentAvgOrderByAggregateInput = {
    id?: SortOrder
    syllabusId?: SortOrder
    order?: SortOrder
  }

  export type SyllabusContentMaxOrderByAggregateInput = {
    id?: SortOrder
    syllabusId?: SortOrder
    title?: SortOrder
    type?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    slug?: SortOrder
  }

  export type SyllabusContentMinOrderByAggregateInput = {
    id?: SortOrder
    syllabusId?: SortOrder
    title?: SortOrder
    type?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    slug?: SortOrder
  }

  export type SyllabusContentSumOrderByAggregateInput = {
    id?: SortOrder
    syllabusId?: SortOrder
    order?: SortOrder
  }

  export type EnumSyllabusContentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyllabusContentType | EnumSyllabusContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SyllabusContentType[]
    notIn?: $Enums.SyllabusContentType[]
    not?: NestedEnumSyllabusContentTypeWithAggregatesFilter<$PrismaModel> | $Enums.SyllabusContentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyllabusContentTypeFilter<$PrismaModel>
    _max?: NestedEnumSyllabusContentTypeFilter<$PrismaModel>
  }

  export type ExamQuestionListRelationFilter = {
    every?: ExamQuestionWhereInput
    some?: ExamQuestionWhereInput
    none?: ExamQuestionWhereInput
  }

  export type ExamQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExamCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    syllabusContentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
  }

  export type ExamAvgOrderByAggregateInput = {
    id?: SortOrder
    syllabusContentId?: SortOrder
  }

  export type ExamMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    syllabusContentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
  }

  export type ExamMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    syllabusContentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
  }

  export type ExamSumOrderByAggregateInput = {
    id?: SortOrder
    syllabusContentId?: SortOrder
  }

  export type EnumTypeQuestionFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeQuestion | EnumTypeQuestionFieldRefInput<$PrismaModel>
    in?: $Enums.TypeQuestion[]
    notIn?: $Enums.TypeQuestion[]
    not?: NestedEnumTypeQuestionFilter<$PrismaModel> | $Enums.TypeQuestion
  }

  export type ExamRelationFilter = {
    is?: ExamWhereInput
    isNot?: ExamWhereInput
  }

  export type ExamOptionQuestionListRelationFilter = {
    every?: ExamOptionQuestionWhereInput
    some?: ExamOptionQuestionWhereInput
    none?: ExamOptionQuestionWhereInput
  }

  export type ExamOptionQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExamQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    isActive?: SortOrder
    examId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    questionText?: SortOrder
    typeQuestion?: SortOrder
  }

  export type ExamQuestionAvgOrderByAggregateInput = {
    id?: SortOrder
    examId?: SortOrder
  }

  export type ExamQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    isActive?: SortOrder
    examId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    questionText?: SortOrder
    typeQuestion?: SortOrder
  }

  export type ExamQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    isActive?: SortOrder
    examId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    questionText?: SortOrder
    typeQuestion?: SortOrder
  }

  export type ExamQuestionSumOrderByAggregateInput = {
    id?: SortOrder
    examId?: SortOrder
  }

  export type EnumTypeQuestionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeQuestion | EnumTypeQuestionFieldRefInput<$PrismaModel>
    in?: $Enums.TypeQuestion[]
    notIn?: $Enums.TypeQuestion[]
    not?: NestedEnumTypeQuestionWithAggregatesFilter<$PrismaModel> | $Enums.TypeQuestion
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeQuestionFilter<$PrismaModel>
    _max?: NestedEnumTypeQuestionFilter<$PrismaModel>
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type ExamQuestionRelationFilter = {
    is?: ExamQuestionWhereInput
    isNot?: ExamQuestionWhereInput
  }

  export type ExamOptionQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    optionText?: SortOrder
    isTrue?: SortOrder
    reason?: SortOrder
    order?: SortOrder
    attachment?: SortOrder
    examQuestionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamOptionQuestionAvgOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    examQuestionId?: SortOrder
  }

  export type ExamOptionQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    optionText?: SortOrder
    isTrue?: SortOrder
    reason?: SortOrder
    order?: SortOrder
    attachment?: SortOrder
    examQuestionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamOptionQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    optionText?: SortOrder
    isTrue?: SortOrder
    reason?: SortOrder
    order?: SortOrder
    attachment?: SortOrder
    examQuestionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamOptionQuestionSumOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    examQuestionId?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type EnumTypeMaterialContentFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeMaterialContent | EnumTypeMaterialContentFieldRefInput<$PrismaModel>
    in?: $Enums.TypeMaterialContent[]
    notIn?: $Enums.TypeMaterialContent[]
    not?: NestedEnumTypeMaterialContentFilter<$PrismaModel> | $Enums.TypeMaterialContent
  }

  export type MaterialContentTypeCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type MaterialContentTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MaterialContentTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type MaterialContentTypeMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type MaterialContentTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumTypeMaterialContentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeMaterialContent | EnumTypeMaterialContentFieldRefInput<$PrismaModel>
    in?: $Enums.TypeMaterialContent[]
    notIn?: $Enums.TypeMaterialContent[]
    not?: NestedEnumTypeMaterialContentWithAggregatesFilter<$PrismaModel> | $Enums.TypeMaterialContent
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeMaterialContentFilter<$PrismaModel>
    _max?: NestedEnumTypeMaterialContentFilter<$PrismaModel>
  }

  export type MaterialContentTypeRelationFilter = {
    is?: MaterialContentTypeWhereInput
    isNot?: MaterialContentTypeWhereInput
  }

  export type MaterialContentAttachmentListRelationFilter = {
    every?: MaterialContentAttachmentWhereInput
    some?: MaterialContentAttachmentWhereInput
    none?: MaterialContentAttachmentWhereInput
  }

  export type MaterialContentFileNullableRelationFilter = {
    is?: MaterialContentFileWhereInput | null
    isNot?: MaterialContentFileWhereInput | null
  }

  export type MaterialContentLearningNullableRelationFilter = {
    is?: MaterialContentLearningWhereInput | null
    isNot?: MaterialContentLearningWhereInput | null
  }

  export type MaterialContentTestNullableRelationFilter = {
    is?: MaterialContentTestWhereInput | null
    isNot?: MaterialContentTestWhereInput | null
  }

  export type MaterialContentAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaterialContentCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    materialContentTypeId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    slug?: SortOrder
    syllabusContentId?: SortOrder
    estimatedTime?: SortOrder
  }

  export type MaterialContentAvgOrderByAggregateInput = {
    id?: SortOrder
    materialContentTypeId?: SortOrder
    order?: SortOrder
    syllabusContentId?: SortOrder
    estimatedTime?: SortOrder
  }

  export type MaterialContentMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    materialContentTypeId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    slug?: SortOrder
    syllabusContentId?: SortOrder
    estimatedTime?: SortOrder
  }

  export type MaterialContentMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    materialContentTypeId?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    slug?: SortOrder
    syllabusContentId?: SortOrder
    estimatedTime?: SortOrder
  }

  export type MaterialContentSumOrderByAggregateInput = {
    id?: SortOrder
    materialContentTypeId?: SortOrder
    order?: SortOrder
    syllabusContentId?: SortOrder
    estimatedTime?: SortOrder
  }

  export type MaterialContentRelationFilter = {
    is?: MaterialContentWhereInput
    isNot?: MaterialContentWhereInput
  }

  export type MaterialContentLearningCountOrderByAggregateInput = {
    id?: SortOrder
    materialContentId?: SortOrder
    content?: SortOrder
  }

  export type MaterialContentLearningAvgOrderByAggregateInput = {
    id?: SortOrder
    materialContentId?: SortOrder
  }

  export type MaterialContentLearningMaxOrderByAggregateInput = {
    id?: SortOrder
    materialContentId?: SortOrder
    content?: SortOrder
  }

  export type MaterialContentLearningMinOrderByAggregateInput = {
    id?: SortOrder
    materialContentId?: SortOrder
    content?: SortOrder
  }

  export type MaterialContentLearningSumOrderByAggregateInput = {
    id?: SortOrder
    materialContentId?: SortOrder
  }

  export type MaterialContentTestCountOrderByAggregateInput = {
    id?: SortOrder
    materialContentId?: SortOrder
  }

  export type MaterialContentTestAvgOrderByAggregateInput = {
    id?: SortOrder
    materialContentId?: SortOrder
  }

  export type MaterialContentTestMaxOrderByAggregateInput = {
    id?: SortOrder
    materialContentId?: SortOrder
  }

  export type MaterialContentTestMinOrderByAggregateInput = {
    id?: SortOrder
    materialContentId?: SortOrder
  }

  export type MaterialContentTestSumOrderByAggregateInput = {
    id?: SortOrder
    materialContentId?: SortOrder
  }

  export type MaterialContentFileCountOrderByAggregateInput = {
    id?: SortOrder
    materialContentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterialContentFileAvgOrderByAggregateInput = {
    id?: SortOrder
    materialContentId?: SortOrder
  }

  export type MaterialContentFileMaxOrderByAggregateInput = {
    id?: SortOrder
    materialContentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterialContentFileMinOrderByAggregateInput = {
    id?: SortOrder
    materialContentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterialContentFileSumOrderByAggregateInput = {
    id?: SortOrder
    materialContentId?: SortOrder
  }

  export type MaterialContentAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    thumbnail?: SortOrder
    path?: SortOrder
    materialContentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterialContentAttachmentAvgOrderByAggregateInput = {
    id?: SortOrder
    materialContentId?: SortOrder
  }

  export type MaterialContentAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    thumbnail?: SortOrder
    path?: SortOrder
    materialContentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterialContentAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    thumbnail?: SortOrder
    path?: SortOrder
    materialContentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterialContentAttachmentSumOrderByAggregateInput = {
    id?: SortOrder
    materialContentId?: SortOrder
  }

  export type CourseCreatorCreateNestedManyWithoutUserInput = {
    create?: XOR<CourseCreatorCreateWithoutUserInput, CourseCreatorUncheckedCreateWithoutUserInput> | CourseCreatorCreateWithoutUserInput[] | CourseCreatorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseCreatorCreateOrConnectWithoutUserInput | CourseCreatorCreateOrConnectWithoutUserInput[]
    createMany?: CourseCreatorCreateManyUserInputEnvelope
    connect?: CourseCreatorWhereUniqueInput | CourseCreatorWhereUniqueInput[]
  }

  export type CourseLoggingCreateNestedManyWithoutUserInput = {
    create?: XOR<CourseLoggingCreateWithoutUserInput, CourseLoggingUncheckedCreateWithoutUserInput> | CourseLoggingCreateWithoutUserInput[] | CourseLoggingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseLoggingCreateOrConnectWithoutUserInput | CourseLoggingCreateOrConnectWithoutUserInput[]
    createMany?: CourseLoggingCreateManyUserInputEnvelope
    connect?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
  }

  export type CourseCreatorUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CourseCreatorCreateWithoutUserInput, CourseCreatorUncheckedCreateWithoutUserInput> | CourseCreatorCreateWithoutUserInput[] | CourseCreatorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseCreatorCreateOrConnectWithoutUserInput | CourseCreatorCreateOrConnectWithoutUserInput[]
    createMany?: CourseCreatorCreateManyUserInputEnvelope
    connect?: CourseCreatorWhereUniqueInput | CourseCreatorWhereUniqueInput[]
  }

  export type CourseLoggingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CourseLoggingCreateWithoutUserInput, CourseLoggingUncheckedCreateWithoutUserInput> | CourseLoggingCreateWithoutUserInput[] | CourseLoggingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseLoggingCreateOrConnectWithoutUserInput | CourseLoggingCreateOrConnectWithoutUserInput[]
    createMany?: CourseLoggingCreateManyUserInputEnvelope
    connect?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CourseCreatorUpdateManyWithoutUserNestedInput = {
    create?: XOR<CourseCreatorCreateWithoutUserInput, CourseCreatorUncheckedCreateWithoutUserInput> | CourseCreatorCreateWithoutUserInput[] | CourseCreatorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseCreatorCreateOrConnectWithoutUserInput | CourseCreatorCreateOrConnectWithoutUserInput[]
    upsert?: CourseCreatorUpsertWithWhereUniqueWithoutUserInput | CourseCreatorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CourseCreatorCreateManyUserInputEnvelope
    set?: CourseCreatorWhereUniqueInput | CourseCreatorWhereUniqueInput[]
    disconnect?: CourseCreatorWhereUniqueInput | CourseCreatorWhereUniqueInput[]
    delete?: CourseCreatorWhereUniqueInput | CourseCreatorWhereUniqueInput[]
    connect?: CourseCreatorWhereUniqueInput | CourseCreatorWhereUniqueInput[]
    update?: CourseCreatorUpdateWithWhereUniqueWithoutUserInput | CourseCreatorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CourseCreatorUpdateManyWithWhereWithoutUserInput | CourseCreatorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CourseCreatorScalarWhereInput | CourseCreatorScalarWhereInput[]
  }

  export type CourseLoggingUpdateManyWithoutUserNestedInput = {
    create?: XOR<CourseLoggingCreateWithoutUserInput, CourseLoggingUncheckedCreateWithoutUserInput> | CourseLoggingCreateWithoutUserInput[] | CourseLoggingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseLoggingCreateOrConnectWithoutUserInput | CourseLoggingCreateOrConnectWithoutUserInput[]
    upsert?: CourseLoggingUpsertWithWhereUniqueWithoutUserInput | CourseLoggingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CourseLoggingCreateManyUserInputEnvelope
    set?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    disconnect?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    delete?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    connect?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    update?: CourseLoggingUpdateWithWhereUniqueWithoutUserInput | CourseLoggingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CourseLoggingUpdateManyWithWhereWithoutUserInput | CourseLoggingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CourseLoggingScalarWhereInput | CourseLoggingScalarWhereInput[]
  }

  export type CourseCreatorUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CourseCreatorCreateWithoutUserInput, CourseCreatorUncheckedCreateWithoutUserInput> | CourseCreatorCreateWithoutUserInput[] | CourseCreatorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseCreatorCreateOrConnectWithoutUserInput | CourseCreatorCreateOrConnectWithoutUserInput[]
    upsert?: CourseCreatorUpsertWithWhereUniqueWithoutUserInput | CourseCreatorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CourseCreatorCreateManyUserInputEnvelope
    set?: CourseCreatorWhereUniqueInput | CourseCreatorWhereUniqueInput[]
    disconnect?: CourseCreatorWhereUniqueInput | CourseCreatorWhereUniqueInput[]
    delete?: CourseCreatorWhereUniqueInput | CourseCreatorWhereUniqueInput[]
    connect?: CourseCreatorWhereUniqueInput | CourseCreatorWhereUniqueInput[]
    update?: CourseCreatorUpdateWithWhereUniqueWithoutUserInput | CourseCreatorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CourseCreatorUpdateManyWithWhereWithoutUserInput | CourseCreatorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CourseCreatorScalarWhereInput | CourseCreatorScalarWhereInput[]
  }

  export type CourseLoggingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CourseLoggingCreateWithoutUserInput, CourseLoggingUncheckedCreateWithoutUserInput> | CourseLoggingCreateWithoutUserInput[] | CourseLoggingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseLoggingCreateOrConnectWithoutUserInput | CourseLoggingCreateOrConnectWithoutUserInput[]
    upsert?: CourseLoggingUpsertWithWhereUniqueWithoutUserInput | CourseLoggingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CourseLoggingCreateManyUserInputEnvelope
    set?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    disconnect?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    delete?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    connect?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    update?: CourseLoggingUpdateWithWhereUniqueWithoutUserInput | CourseLoggingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CourseLoggingUpdateManyWithWhereWithoutUserInput | CourseLoggingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CourseLoggingScalarWhereInput | CourseLoggingScalarWhereInput[]
  }

  export type CourseLoggingCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseLoggingCreateWithoutCourseInput, CourseLoggingUncheckedCreateWithoutCourseInput> | CourseLoggingCreateWithoutCourseInput[] | CourseLoggingUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseLoggingCreateOrConnectWithoutCourseInput | CourseLoggingCreateOrConnectWithoutCourseInput[]
    createMany?: CourseLoggingCreateManyCourseInputEnvelope
    connect?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
  }

  export type CourseTopicCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseTopicCreateWithoutCourseInput, CourseTopicUncheckedCreateWithoutCourseInput> | CourseTopicCreateWithoutCourseInput[] | CourseTopicUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseTopicCreateOrConnectWithoutCourseInput | CourseTopicCreateOrConnectWithoutCourseInput[]
    createMany?: CourseTopicCreateManyCourseInputEnvelope
    connect?: CourseTopicWhereUniqueInput | CourseTopicWhereUniqueInput[]
  }

  export type SyllabusCreateNestedManyWithoutCourseInput = {
    create?: XOR<SyllabusCreateWithoutCourseInput, SyllabusUncheckedCreateWithoutCourseInput> | SyllabusCreateWithoutCourseInput[] | SyllabusUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: SyllabusCreateOrConnectWithoutCourseInput | SyllabusCreateOrConnectWithoutCourseInput[]
    createMany?: SyllabusCreateManyCourseInputEnvelope
    connect?: SyllabusWhereUniqueInput | SyllabusWhereUniqueInput[]
  }

  export type CourseCreatorCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseCreatorCreateWithoutCourseInput, CourseCreatorUncheckedCreateWithoutCourseInput> | CourseCreatorCreateWithoutCourseInput[] | CourseCreatorUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseCreatorCreateOrConnectWithoutCourseInput | CourseCreatorCreateOrConnectWithoutCourseInput[]
    createMany?: CourseCreatorCreateManyCourseInputEnvelope
    connect?: CourseCreatorWhereUniqueInput | CourseCreatorWhereUniqueInput[]
  }

  export type CourseLoggingUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseLoggingCreateWithoutCourseInput, CourseLoggingUncheckedCreateWithoutCourseInput> | CourseLoggingCreateWithoutCourseInput[] | CourseLoggingUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseLoggingCreateOrConnectWithoutCourseInput | CourseLoggingCreateOrConnectWithoutCourseInput[]
    createMany?: CourseLoggingCreateManyCourseInputEnvelope
    connect?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
  }

  export type CourseTopicUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseTopicCreateWithoutCourseInput, CourseTopicUncheckedCreateWithoutCourseInput> | CourseTopicCreateWithoutCourseInput[] | CourseTopicUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseTopicCreateOrConnectWithoutCourseInput | CourseTopicCreateOrConnectWithoutCourseInput[]
    createMany?: CourseTopicCreateManyCourseInputEnvelope
    connect?: CourseTopicWhereUniqueInput | CourseTopicWhereUniqueInput[]
  }

  export type SyllabusUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<SyllabusCreateWithoutCourseInput, SyllabusUncheckedCreateWithoutCourseInput> | SyllabusCreateWithoutCourseInput[] | SyllabusUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: SyllabusCreateOrConnectWithoutCourseInput | SyllabusCreateOrConnectWithoutCourseInput[]
    createMany?: SyllabusCreateManyCourseInputEnvelope
    connect?: SyllabusWhereUniqueInput | SyllabusWhereUniqueInput[]
  }

  export type CourseCreatorUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseCreatorCreateWithoutCourseInput, CourseCreatorUncheckedCreateWithoutCourseInput> | CourseCreatorCreateWithoutCourseInput[] | CourseCreatorUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseCreatorCreateOrConnectWithoutCourseInput | CourseCreatorCreateOrConnectWithoutCourseInput[]
    createMany?: CourseCreatorCreateManyCourseInputEnvelope
    connect?: CourseCreatorWhereUniqueInput | CourseCreatorWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CourseLoggingUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseLoggingCreateWithoutCourseInput, CourseLoggingUncheckedCreateWithoutCourseInput> | CourseLoggingCreateWithoutCourseInput[] | CourseLoggingUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseLoggingCreateOrConnectWithoutCourseInput | CourseLoggingCreateOrConnectWithoutCourseInput[]
    upsert?: CourseLoggingUpsertWithWhereUniqueWithoutCourseInput | CourseLoggingUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseLoggingCreateManyCourseInputEnvelope
    set?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    disconnect?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    delete?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    connect?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    update?: CourseLoggingUpdateWithWhereUniqueWithoutCourseInput | CourseLoggingUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseLoggingUpdateManyWithWhereWithoutCourseInput | CourseLoggingUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseLoggingScalarWhereInput | CourseLoggingScalarWhereInput[]
  }

  export type CourseTopicUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseTopicCreateWithoutCourseInput, CourseTopicUncheckedCreateWithoutCourseInput> | CourseTopicCreateWithoutCourseInput[] | CourseTopicUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseTopicCreateOrConnectWithoutCourseInput | CourseTopicCreateOrConnectWithoutCourseInput[]
    upsert?: CourseTopicUpsertWithWhereUniqueWithoutCourseInput | CourseTopicUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseTopicCreateManyCourseInputEnvelope
    set?: CourseTopicWhereUniqueInput | CourseTopicWhereUniqueInput[]
    disconnect?: CourseTopicWhereUniqueInput | CourseTopicWhereUniqueInput[]
    delete?: CourseTopicWhereUniqueInput | CourseTopicWhereUniqueInput[]
    connect?: CourseTopicWhereUniqueInput | CourseTopicWhereUniqueInput[]
    update?: CourseTopicUpdateWithWhereUniqueWithoutCourseInput | CourseTopicUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseTopicUpdateManyWithWhereWithoutCourseInput | CourseTopicUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseTopicScalarWhereInput | CourseTopicScalarWhereInput[]
  }

  export type SyllabusUpdateManyWithoutCourseNestedInput = {
    create?: XOR<SyllabusCreateWithoutCourseInput, SyllabusUncheckedCreateWithoutCourseInput> | SyllabusCreateWithoutCourseInput[] | SyllabusUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: SyllabusCreateOrConnectWithoutCourseInput | SyllabusCreateOrConnectWithoutCourseInput[]
    upsert?: SyllabusUpsertWithWhereUniqueWithoutCourseInput | SyllabusUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: SyllabusCreateManyCourseInputEnvelope
    set?: SyllabusWhereUniqueInput | SyllabusWhereUniqueInput[]
    disconnect?: SyllabusWhereUniqueInput | SyllabusWhereUniqueInput[]
    delete?: SyllabusWhereUniqueInput | SyllabusWhereUniqueInput[]
    connect?: SyllabusWhereUniqueInput | SyllabusWhereUniqueInput[]
    update?: SyllabusUpdateWithWhereUniqueWithoutCourseInput | SyllabusUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: SyllabusUpdateManyWithWhereWithoutCourseInput | SyllabusUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: SyllabusScalarWhereInput | SyllabusScalarWhereInput[]
  }

  export type CourseCreatorUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseCreatorCreateWithoutCourseInput, CourseCreatorUncheckedCreateWithoutCourseInput> | CourseCreatorCreateWithoutCourseInput[] | CourseCreatorUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseCreatorCreateOrConnectWithoutCourseInput | CourseCreatorCreateOrConnectWithoutCourseInput[]
    upsert?: CourseCreatorUpsertWithWhereUniqueWithoutCourseInput | CourseCreatorUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseCreatorCreateManyCourseInputEnvelope
    set?: CourseCreatorWhereUniqueInput | CourseCreatorWhereUniqueInput[]
    disconnect?: CourseCreatorWhereUniqueInput | CourseCreatorWhereUniqueInput[]
    delete?: CourseCreatorWhereUniqueInput | CourseCreatorWhereUniqueInput[]
    connect?: CourseCreatorWhereUniqueInput | CourseCreatorWhereUniqueInput[]
    update?: CourseCreatorUpdateWithWhereUniqueWithoutCourseInput | CourseCreatorUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseCreatorUpdateManyWithWhereWithoutCourseInput | CourseCreatorUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseCreatorScalarWhereInput | CourseCreatorScalarWhereInput[]
  }

  export type CourseLoggingUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseLoggingCreateWithoutCourseInput, CourseLoggingUncheckedCreateWithoutCourseInput> | CourseLoggingCreateWithoutCourseInput[] | CourseLoggingUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseLoggingCreateOrConnectWithoutCourseInput | CourseLoggingCreateOrConnectWithoutCourseInput[]
    upsert?: CourseLoggingUpsertWithWhereUniqueWithoutCourseInput | CourseLoggingUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseLoggingCreateManyCourseInputEnvelope
    set?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    disconnect?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    delete?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    connect?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    update?: CourseLoggingUpdateWithWhereUniqueWithoutCourseInput | CourseLoggingUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseLoggingUpdateManyWithWhereWithoutCourseInput | CourseLoggingUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseLoggingScalarWhereInput | CourseLoggingScalarWhereInput[]
  }

  export type CourseTopicUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseTopicCreateWithoutCourseInput, CourseTopicUncheckedCreateWithoutCourseInput> | CourseTopicCreateWithoutCourseInput[] | CourseTopicUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseTopicCreateOrConnectWithoutCourseInput | CourseTopicCreateOrConnectWithoutCourseInput[]
    upsert?: CourseTopicUpsertWithWhereUniqueWithoutCourseInput | CourseTopicUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseTopicCreateManyCourseInputEnvelope
    set?: CourseTopicWhereUniqueInput | CourseTopicWhereUniqueInput[]
    disconnect?: CourseTopicWhereUniqueInput | CourseTopicWhereUniqueInput[]
    delete?: CourseTopicWhereUniqueInput | CourseTopicWhereUniqueInput[]
    connect?: CourseTopicWhereUniqueInput | CourseTopicWhereUniqueInput[]
    update?: CourseTopicUpdateWithWhereUniqueWithoutCourseInput | CourseTopicUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseTopicUpdateManyWithWhereWithoutCourseInput | CourseTopicUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseTopicScalarWhereInput | CourseTopicScalarWhereInput[]
  }

  export type SyllabusUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<SyllabusCreateWithoutCourseInput, SyllabusUncheckedCreateWithoutCourseInput> | SyllabusCreateWithoutCourseInput[] | SyllabusUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: SyllabusCreateOrConnectWithoutCourseInput | SyllabusCreateOrConnectWithoutCourseInput[]
    upsert?: SyllabusUpsertWithWhereUniqueWithoutCourseInput | SyllabusUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: SyllabusCreateManyCourseInputEnvelope
    set?: SyllabusWhereUniqueInput | SyllabusWhereUniqueInput[]
    disconnect?: SyllabusWhereUniqueInput | SyllabusWhereUniqueInput[]
    delete?: SyllabusWhereUniqueInput | SyllabusWhereUniqueInput[]
    connect?: SyllabusWhereUniqueInput | SyllabusWhereUniqueInput[]
    update?: SyllabusUpdateWithWhereUniqueWithoutCourseInput | SyllabusUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: SyllabusUpdateManyWithWhereWithoutCourseInput | SyllabusUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: SyllabusScalarWhereInput | SyllabusScalarWhereInput[]
  }

  export type CourseCreatorUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseCreatorCreateWithoutCourseInput, CourseCreatorUncheckedCreateWithoutCourseInput> | CourseCreatorCreateWithoutCourseInput[] | CourseCreatorUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseCreatorCreateOrConnectWithoutCourseInput | CourseCreatorCreateOrConnectWithoutCourseInput[]
    upsert?: CourseCreatorUpsertWithWhereUniqueWithoutCourseInput | CourseCreatorUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseCreatorCreateManyCourseInputEnvelope
    set?: CourseCreatorWhereUniqueInput | CourseCreatorWhereUniqueInput[]
    disconnect?: CourseCreatorWhereUniqueInput | CourseCreatorWhereUniqueInput[]
    delete?: CourseCreatorWhereUniqueInput | CourseCreatorWhereUniqueInput[]
    connect?: CourseCreatorWhereUniqueInput | CourseCreatorWhereUniqueInput[]
    update?: CourseCreatorUpdateWithWhereUniqueWithoutCourseInput | CourseCreatorUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseCreatorUpdateManyWithWhereWithoutCourseInput | CourseCreatorUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseCreatorScalarWhereInput | CourseCreatorScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutCourseCreatorInput = {
    create?: XOR<CourseCreateWithoutCourseCreatorInput, CourseUncheckedCreateWithoutCourseCreatorInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCourseCreatorInput
    connect?: CourseWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutCourseCreatorInput = {
    create?: XOR<UsersCreateWithoutCourseCreatorInput, UsersUncheckedCreateWithoutCourseCreatorInput>
    connectOrCreate?: UsersCreateOrConnectWithoutCourseCreatorInput
    connect?: UsersWhereUniqueInput
  }

  export type EnumCourseAsFieldUpdateOperationsInput = {
    set?: $Enums.CourseAs
  }

  export type CourseUpdateOneRequiredWithoutCourseCreatorNestedInput = {
    create?: XOR<CourseCreateWithoutCourseCreatorInput, CourseUncheckedCreateWithoutCourseCreatorInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCourseCreatorInput
    upsert?: CourseUpsertWithoutCourseCreatorInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutCourseCreatorInput, CourseUpdateWithoutCourseCreatorInput>, CourseUncheckedUpdateWithoutCourseCreatorInput>
  }

  export type UsersUpdateOneRequiredWithoutCourseCreatorNestedInput = {
    create?: XOR<UsersCreateWithoutCourseCreatorInput, UsersUncheckedCreateWithoutCourseCreatorInput>
    connectOrCreate?: UsersCreateOrConnectWithoutCourseCreatorInput
    upsert?: UsersUpsertWithoutCourseCreatorInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutCourseCreatorInput, UsersUpdateWithoutCourseCreatorInput>, UsersUncheckedUpdateWithoutCourseCreatorInput>
  }

  export type CourseCreateNestedOneWithoutCourseLoggingsInput = {
    create?: XOR<CourseCreateWithoutCourseLoggingsInput, CourseUncheckedCreateWithoutCourseLoggingsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCourseLoggingsInput
    connect?: CourseWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutCourseLoggingInput = {
    create?: XOR<UsersCreateWithoutCourseLoggingInput, UsersUncheckedCreateWithoutCourseLoggingInput>
    connectOrCreate?: UsersCreateOrConnectWithoutCourseLoggingInput
    connect?: UsersWhereUniqueInput
  }

  export type SyllabusContentCreateNestedOneWithoutCourseLoggingInput = {
    create?: XOR<SyllabusContentCreateWithoutCourseLoggingInput, SyllabusContentUncheckedCreateWithoutCourseLoggingInput>
    connectOrCreate?: SyllabusContentCreateOrConnectWithoutCourseLoggingInput
    connect?: SyllabusContentWhereUniqueInput
  }

  export type MaterialContentCreateNestedOneWithoutCourseLoggingInput = {
    create?: XOR<MaterialContentCreateWithoutCourseLoggingInput, MaterialContentUncheckedCreateWithoutCourseLoggingInput>
    connectOrCreate?: MaterialContentCreateOrConnectWithoutCourseLoggingInput
    connect?: MaterialContentWhereUniqueInput
  }

  export type ExamCreateNestedOneWithoutCourseLoggingInput = {
    create?: XOR<ExamCreateWithoutCourseLoggingInput, ExamUncheckedCreateWithoutCourseLoggingInput>
    connectOrCreate?: ExamCreateOrConnectWithoutCourseLoggingInput
    connect?: ExamWhereUniqueInput
  }

  export type CourseUpdateOneRequiredWithoutCourseLoggingsNestedInput = {
    create?: XOR<CourseCreateWithoutCourseLoggingsInput, CourseUncheckedCreateWithoutCourseLoggingsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCourseLoggingsInput
    upsert?: CourseUpsertWithoutCourseLoggingsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutCourseLoggingsInput, CourseUpdateWithoutCourseLoggingsInput>, CourseUncheckedUpdateWithoutCourseLoggingsInput>
  }

  export type UsersUpdateOneRequiredWithoutCourseLoggingNestedInput = {
    create?: XOR<UsersCreateWithoutCourseLoggingInput, UsersUncheckedCreateWithoutCourseLoggingInput>
    connectOrCreate?: UsersCreateOrConnectWithoutCourseLoggingInput
    upsert?: UsersUpsertWithoutCourseLoggingInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutCourseLoggingInput, UsersUpdateWithoutCourseLoggingInput>, UsersUncheckedUpdateWithoutCourseLoggingInput>
  }

  export type SyllabusContentUpdateOneRequiredWithoutCourseLoggingNestedInput = {
    create?: XOR<SyllabusContentCreateWithoutCourseLoggingInput, SyllabusContentUncheckedCreateWithoutCourseLoggingInput>
    connectOrCreate?: SyllabusContentCreateOrConnectWithoutCourseLoggingInput
    upsert?: SyllabusContentUpsertWithoutCourseLoggingInput
    connect?: SyllabusContentWhereUniqueInput
    update?: XOR<XOR<SyllabusContentUpdateToOneWithWhereWithoutCourseLoggingInput, SyllabusContentUpdateWithoutCourseLoggingInput>, SyllabusContentUncheckedUpdateWithoutCourseLoggingInput>
  }

  export type MaterialContentUpdateOneWithoutCourseLoggingNestedInput = {
    create?: XOR<MaterialContentCreateWithoutCourseLoggingInput, MaterialContentUncheckedCreateWithoutCourseLoggingInput>
    connectOrCreate?: MaterialContentCreateOrConnectWithoutCourseLoggingInput
    upsert?: MaterialContentUpsertWithoutCourseLoggingInput
    disconnect?: MaterialContentWhereInput | boolean
    delete?: MaterialContentWhereInput | boolean
    connect?: MaterialContentWhereUniqueInput
    update?: XOR<XOR<MaterialContentUpdateToOneWithWhereWithoutCourseLoggingInput, MaterialContentUpdateWithoutCourseLoggingInput>, MaterialContentUncheckedUpdateWithoutCourseLoggingInput>
  }

  export type ExamUpdateOneWithoutCourseLoggingNestedInput = {
    create?: XOR<ExamCreateWithoutCourseLoggingInput, ExamUncheckedCreateWithoutCourseLoggingInput>
    connectOrCreate?: ExamCreateOrConnectWithoutCourseLoggingInput
    upsert?: ExamUpsertWithoutCourseLoggingInput
    disconnect?: ExamWhereInput | boolean
    delete?: ExamWhereInput | boolean
    connect?: ExamWhereUniqueInput
    update?: XOR<XOR<ExamUpdateToOneWithWhereWithoutCourseLoggingInput, ExamUpdateWithoutCourseLoggingInput>, ExamUncheckedUpdateWithoutCourseLoggingInput>
  }

  export type SubCategoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<SubCategoryCreateWithoutCategoryInput, SubCategoryUncheckedCreateWithoutCategoryInput> | SubCategoryCreateWithoutCategoryInput[] | SubCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SubCategoryCreateOrConnectWithoutCategoryInput | SubCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: SubCategoryCreateManyCategoryInputEnvelope
    connect?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
  }

  export type SubCategoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<SubCategoryCreateWithoutCategoryInput, SubCategoryUncheckedCreateWithoutCategoryInput> | SubCategoryCreateWithoutCategoryInput[] | SubCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SubCategoryCreateOrConnectWithoutCategoryInput | SubCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: SubCategoryCreateManyCategoryInputEnvelope
    connect?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
  }

  export type SubCategoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<SubCategoryCreateWithoutCategoryInput, SubCategoryUncheckedCreateWithoutCategoryInput> | SubCategoryCreateWithoutCategoryInput[] | SubCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SubCategoryCreateOrConnectWithoutCategoryInput | SubCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: SubCategoryUpsertWithWhereUniqueWithoutCategoryInput | SubCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: SubCategoryCreateManyCategoryInputEnvelope
    set?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    disconnect?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    delete?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    connect?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    update?: SubCategoryUpdateWithWhereUniqueWithoutCategoryInput | SubCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: SubCategoryUpdateManyWithWhereWithoutCategoryInput | SubCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: SubCategoryScalarWhereInput | SubCategoryScalarWhereInput[]
  }

  export type SubCategoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<SubCategoryCreateWithoutCategoryInput, SubCategoryUncheckedCreateWithoutCategoryInput> | SubCategoryCreateWithoutCategoryInput[] | SubCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SubCategoryCreateOrConnectWithoutCategoryInput | SubCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: SubCategoryUpsertWithWhereUniqueWithoutCategoryInput | SubCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: SubCategoryCreateManyCategoryInputEnvelope
    set?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    disconnect?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    delete?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    connect?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    update?: SubCategoryUpdateWithWhereUniqueWithoutCategoryInput | SubCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: SubCategoryUpdateManyWithWhereWithoutCategoryInput | SubCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: SubCategoryScalarWhereInput | SubCategoryScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutSubCategoriesInput = {
    create?: XOR<CategoryCreateWithoutSubCategoriesInput, CategoryUncheckedCreateWithoutSubCategoriesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutSubCategoriesInput
    connect?: CategoryWhereUniqueInput
  }

  export type TopicCreateNestedManyWithoutSubCategoryInput = {
    create?: XOR<TopicCreateWithoutSubCategoryInput, TopicUncheckedCreateWithoutSubCategoryInput> | TopicCreateWithoutSubCategoryInput[] | TopicUncheckedCreateWithoutSubCategoryInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutSubCategoryInput | TopicCreateOrConnectWithoutSubCategoryInput[]
    createMany?: TopicCreateManySubCategoryInputEnvelope
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type TopicUncheckedCreateNestedManyWithoutSubCategoryInput = {
    create?: XOR<TopicCreateWithoutSubCategoryInput, TopicUncheckedCreateWithoutSubCategoryInput> | TopicCreateWithoutSubCategoryInput[] | TopicUncheckedCreateWithoutSubCategoryInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutSubCategoryInput | TopicCreateOrConnectWithoutSubCategoryInput[]
    createMany?: TopicCreateManySubCategoryInputEnvelope
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type CategoryUpdateOneRequiredWithoutSubCategoriesNestedInput = {
    create?: XOR<CategoryCreateWithoutSubCategoriesInput, CategoryUncheckedCreateWithoutSubCategoriesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutSubCategoriesInput
    upsert?: CategoryUpsertWithoutSubCategoriesInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutSubCategoriesInput, CategoryUpdateWithoutSubCategoriesInput>, CategoryUncheckedUpdateWithoutSubCategoriesInput>
  }

  export type TopicUpdateManyWithoutSubCategoryNestedInput = {
    create?: XOR<TopicCreateWithoutSubCategoryInput, TopicUncheckedCreateWithoutSubCategoryInput> | TopicCreateWithoutSubCategoryInput[] | TopicUncheckedCreateWithoutSubCategoryInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutSubCategoryInput | TopicCreateOrConnectWithoutSubCategoryInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutSubCategoryInput | TopicUpsertWithWhereUniqueWithoutSubCategoryInput[]
    createMany?: TopicCreateManySubCategoryInputEnvelope
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutSubCategoryInput | TopicUpdateWithWhereUniqueWithoutSubCategoryInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutSubCategoryInput | TopicUpdateManyWithWhereWithoutSubCategoryInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type TopicUncheckedUpdateManyWithoutSubCategoryNestedInput = {
    create?: XOR<TopicCreateWithoutSubCategoryInput, TopicUncheckedCreateWithoutSubCategoryInput> | TopicCreateWithoutSubCategoryInput[] | TopicUncheckedCreateWithoutSubCategoryInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutSubCategoryInput | TopicCreateOrConnectWithoutSubCategoryInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutSubCategoryInput | TopicUpsertWithWhereUniqueWithoutSubCategoryInput[]
    createMany?: TopicCreateManySubCategoryInputEnvelope
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutSubCategoryInput | TopicUpdateWithWhereUniqueWithoutSubCategoryInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutSubCategoryInput | TopicUpdateManyWithWhereWithoutSubCategoryInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type CourseTopicCreateNestedManyWithoutTopicInput = {
    create?: XOR<CourseTopicCreateWithoutTopicInput, CourseTopicUncheckedCreateWithoutTopicInput> | CourseTopicCreateWithoutTopicInput[] | CourseTopicUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: CourseTopicCreateOrConnectWithoutTopicInput | CourseTopicCreateOrConnectWithoutTopicInput[]
    createMany?: CourseTopicCreateManyTopicInputEnvelope
    connect?: CourseTopicWhereUniqueInput | CourseTopicWhereUniqueInput[]
  }

  export type SubCategoryCreateNestedOneWithoutTopicsInput = {
    create?: XOR<SubCategoryCreateWithoutTopicsInput, SubCategoryUncheckedCreateWithoutTopicsInput>
    connectOrCreate?: SubCategoryCreateOrConnectWithoutTopicsInput
    connect?: SubCategoryWhereUniqueInput
  }

  export type CourseTopicUncheckedCreateNestedManyWithoutTopicInput = {
    create?: XOR<CourseTopicCreateWithoutTopicInput, CourseTopicUncheckedCreateWithoutTopicInput> | CourseTopicCreateWithoutTopicInput[] | CourseTopicUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: CourseTopicCreateOrConnectWithoutTopicInput | CourseTopicCreateOrConnectWithoutTopicInput[]
    createMany?: CourseTopicCreateManyTopicInputEnvelope
    connect?: CourseTopicWhereUniqueInput | CourseTopicWhereUniqueInput[]
  }

  export type CourseTopicUpdateManyWithoutTopicNestedInput = {
    create?: XOR<CourseTopicCreateWithoutTopicInput, CourseTopicUncheckedCreateWithoutTopicInput> | CourseTopicCreateWithoutTopicInput[] | CourseTopicUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: CourseTopicCreateOrConnectWithoutTopicInput | CourseTopicCreateOrConnectWithoutTopicInput[]
    upsert?: CourseTopicUpsertWithWhereUniqueWithoutTopicInput | CourseTopicUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: CourseTopicCreateManyTopicInputEnvelope
    set?: CourseTopicWhereUniqueInput | CourseTopicWhereUniqueInput[]
    disconnect?: CourseTopicWhereUniqueInput | CourseTopicWhereUniqueInput[]
    delete?: CourseTopicWhereUniqueInput | CourseTopicWhereUniqueInput[]
    connect?: CourseTopicWhereUniqueInput | CourseTopicWhereUniqueInput[]
    update?: CourseTopicUpdateWithWhereUniqueWithoutTopicInput | CourseTopicUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: CourseTopicUpdateManyWithWhereWithoutTopicInput | CourseTopicUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: CourseTopicScalarWhereInput | CourseTopicScalarWhereInput[]
  }

  export type SubCategoryUpdateOneRequiredWithoutTopicsNestedInput = {
    create?: XOR<SubCategoryCreateWithoutTopicsInput, SubCategoryUncheckedCreateWithoutTopicsInput>
    connectOrCreate?: SubCategoryCreateOrConnectWithoutTopicsInput
    upsert?: SubCategoryUpsertWithoutTopicsInput
    connect?: SubCategoryWhereUniqueInput
    update?: XOR<XOR<SubCategoryUpdateToOneWithWhereWithoutTopicsInput, SubCategoryUpdateWithoutTopicsInput>, SubCategoryUncheckedUpdateWithoutTopicsInput>
  }

  export type CourseTopicUncheckedUpdateManyWithoutTopicNestedInput = {
    create?: XOR<CourseTopicCreateWithoutTopicInput, CourseTopicUncheckedCreateWithoutTopicInput> | CourseTopicCreateWithoutTopicInput[] | CourseTopicUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: CourseTopicCreateOrConnectWithoutTopicInput | CourseTopicCreateOrConnectWithoutTopicInput[]
    upsert?: CourseTopicUpsertWithWhereUniqueWithoutTopicInput | CourseTopicUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: CourseTopicCreateManyTopicInputEnvelope
    set?: CourseTopicWhereUniqueInput | CourseTopicWhereUniqueInput[]
    disconnect?: CourseTopicWhereUniqueInput | CourseTopicWhereUniqueInput[]
    delete?: CourseTopicWhereUniqueInput | CourseTopicWhereUniqueInput[]
    connect?: CourseTopicWhereUniqueInput | CourseTopicWhereUniqueInput[]
    update?: CourseTopicUpdateWithWhereUniqueWithoutTopicInput | CourseTopicUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: CourseTopicUpdateManyWithWhereWithoutTopicInput | CourseTopicUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: CourseTopicScalarWhereInput | CourseTopicScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutCourseTopicsInput = {
    create?: XOR<CourseCreateWithoutCourseTopicsInput, CourseUncheckedCreateWithoutCourseTopicsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCourseTopicsInput
    connect?: CourseWhereUniqueInput
  }

  export type TopicCreateNestedOneWithoutCourseTopicsInput = {
    create?: XOR<TopicCreateWithoutCourseTopicsInput, TopicUncheckedCreateWithoutCourseTopicsInput>
    connectOrCreate?: TopicCreateOrConnectWithoutCourseTopicsInput
    connect?: TopicWhereUniqueInput
  }

  export type CourseUpdateOneRequiredWithoutCourseTopicsNestedInput = {
    create?: XOR<CourseCreateWithoutCourseTopicsInput, CourseUncheckedCreateWithoutCourseTopicsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCourseTopicsInput
    upsert?: CourseUpsertWithoutCourseTopicsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutCourseTopicsInput, CourseUpdateWithoutCourseTopicsInput>, CourseUncheckedUpdateWithoutCourseTopicsInput>
  }

  export type TopicUpdateOneRequiredWithoutCourseTopicsNestedInput = {
    create?: XOR<TopicCreateWithoutCourseTopicsInput, TopicUncheckedCreateWithoutCourseTopicsInput>
    connectOrCreate?: TopicCreateOrConnectWithoutCourseTopicsInput
    upsert?: TopicUpsertWithoutCourseTopicsInput
    connect?: TopicWhereUniqueInput
    update?: XOR<XOR<TopicUpdateToOneWithWhereWithoutCourseTopicsInput, TopicUpdateWithoutCourseTopicsInput>, TopicUncheckedUpdateWithoutCourseTopicsInput>
  }

  export type CourseCreateNestedOneWithoutSyllabusInput = {
    create?: XOR<CourseCreateWithoutSyllabusInput, CourseUncheckedCreateWithoutSyllabusInput>
    connectOrCreate?: CourseCreateOrConnectWithoutSyllabusInput
    connect?: CourseWhereUniqueInput
  }

  export type SyllabusContentCreateNestedManyWithoutSyllabusInput = {
    create?: XOR<SyllabusContentCreateWithoutSyllabusInput, SyllabusContentUncheckedCreateWithoutSyllabusInput> | SyllabusContentCreateWithoutSyllabusInput[] | SyllabusContentUncheckedCreateWithoutSyllabusInput[]
    connectOrCreate?: SyllabusContentCreateOrConnectWithoutSyllabusInput | SyllabusContentCreateOrConnectWithoutSyllabusInput[]
    createMany?: SyllabusContentCreateManySyllabusInputEnvelope
    connect?: SyllabusContentWhereUniqueInput | SyllabusContentWhereUniqueInput[]
  }

  export type SyllabusContentUncheckedCreateNestedManyWithoutSyllabusInput = {
    create?: XOR<SyllabusContentCreateWithoutSyllabusInput, SyllabusContentUncheckedCreateWithoutSyllabusInput> | SyllabusContentCreateWithoutSyllabusInput[] | SyllabusContentUncheckedCreateWithoutSyllabusInput[]
    connectOrCreate?: SyllabusContentCreateOrConnectWithoutSyllabusInput | SyllabusContentCreateOrConnectWithoutSyllabusInput[]
    createMany?: SyllabusContentCreateManySyllabusInputEnvelope
    connect?: SyllabusContentWhereUniqueInput | SyllabusContentWhereUniqueInput[]
  }

  export type CourseUpdateOneRequiredWithoutSyllabusNestedInput = {
    create?: XOR<CourseCreateWithoutSyllabusInput, CourseUncheckedCreateWithoutSyllabusInput>
    connectOrCreate?: CourseCreateOrConnectWithoutSyllabusInput
    upsert?: CourseUpsertWithoutSyllabusInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutSyllabusInput, CourseUpdateWithoutSyllabusInput>, CourseUncheckedUpdateWithoutSyllabusInput>
  }

  export type SyllabusContentUpdateManyWithoutSyllabusNestedInput = {
    create?: XOR<SyllabusContentCreateWithoutSyllabusInput, SyllabusContentUncheckedCreateWithoutSyllabusInput> | SyllabusContentCreateWithoutSyllabusInput[] | SyllabusContentUncheckedCreateWithoutSyllabusInput[]
    connectOrCreate?: SyllabusContentCreateOrConnectWithoutSyllabusInput | SyllabusContentCreateOrConnectWithoutSyllabusInput[]
    upsert?: SyllabusContentUpsertWithWhereUniqueWithoutSyllabusInput | SyllabusContentUpsertWithWhereUniqueWithoutSyllabusInput[]
    createMany?: SyllabusContentCreateManySyllabusInputEnvelope
    set?: SyllabusContentWhereUniqueInput | SyllabusContentWhereUniqueInput[]
    disconnect?: SyllabusContentWhereUniqueInput | SyllabusContentWhereUniqueInput[]
    delete?: SyllabusContentWhereUniqueInput | SyllabusContentWhereUniqueInput[]
    connect?: SyllabusContentWhereUniqueInput | SyllabusContentWhereUniqueInput[]
    update?: SyllabusContentUpdateWithWhereUniqueWithoutSyllabusInput | SyllabusContentUpdateWithWhereUniqueWithoutSyllabusInput[]
    updateMany?: SyllabusContentUpdateManyWithWhereWithoutSyllabusInput | SyllabusContentUpdateManyWithWhereWithoutSyllabusInput[]
    deleteMany?: SyllabusContentScalarWhereInput | SyllabusContentScalarWhereInput[]
  }

  export type SyllabusContentUncheckedUpdateManyWithoutSyllabusNestedInput = {
    create?: XOR<SyllabusContentCreateWithoutSyllabusInput, SyllabusContentUncheckedCreateWithoutSyllabusInput> | SyllabusContentCreateWithoutSyllabusInput[] | SyllabusContentUncheckedCreateWithoutSyllabusInput[]
    connectOrCreate?: SyllabusContentCreateOrConnectWithoutSyllabusInput | SyllabusContentCreateOrConnectWithoutSyllabusInput[]
    upsert?: SyllabusContentUpsertWithWhereUniqueWithoutSyllabusInput | SyllabusContentUpsertWithWhereUniqueWithoutSyllabusInput[]
    createMany?: SyllabusContentCreateManySyllabusInputEnvelope
    set?: SyllabusContentWhereUniqueInput | SyllabusContentWhereUniqueInput[]
    disconnect?: SyllabusContentWhereUniqueInput | SyllabusContentWhereUniqueInput[]
    delete?: SyllabusContentWhereUniqueInput | SyllabusContentWhereUniqueInput[]
    connect?: SyllabusContentWhereUniqueInput | SyllabusContentWhereUniqueInput[]
    update?: SyllabusContentUpdateWithWhereUniqueWithoutSyllabusInput | SyllabusContentUpdateWithWhereUniqueWithoutSyllabusInput[]
    updateMany?: SyllabusContentUpdateManyWithWhereWithoutSyllabusInput | SyllabusContentUpdateManyWithWhereWithoutSyllabusInput[]
    deleteMany?: SyllabusContentScalarWhereInput | SyllabusContentScalarWhereInput[]
  }

  export type ExamCreateNestedManyWithoutSyllabusContentInput = {
    create?: XOR<ExamCreateWithoutSyllabusContentInput, ExamUncheckedCreateWithoutSyllabusContentInput> | ExamCreateWithoutSyllabusContentInput[] | ExamUncheckedCreateWithoutSyllabusContentInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutSyllabusContentInput | ExamCreateOrConnectWithoutSyllabusContentInput[]
    createMany?: ExamCreateManySyllabusContentInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type MaterialContentCreateNestedManyWithoutSyllabusContentInput = {
    create?: XOR<MaterialContentCreateWithoutSyllabusContentInput, MaterialContentUncheckedCreateWithoutSyllabusContentInput> | MaterialContentCreateWithoutSyllabusContentInput[] | MaterialContentUncheckedCreateWithoutSyllabusContentInput[]
    connectOrCreate?: MaterialContentCreateOrConnectWithoutSyllabusContentInput | MaterialContentCreateOrConnectWithoutSyllabusContentInput[]
    createMany?: MaterialContentCreateManySyllabusContentInputEnvelope
    connect?: MaterialContentWhereUniqueInput | MaterialContentWhereUniqueInput[]
  }

  export type SyllabusCreateNestedOneWithoutSyllabusContentInput = {
    create?: XOR<SyllabusCreateWithoutSyllabusContentInput, SyllabusUncheckedCreateWithoutSyllabusContentInput>
    connectOrCreate?: SyllabusCreateOrConnectWithoutSyllabusContentInput
    connect?: SyllabusWhereUniqueInput
  }

  export type CourseLoggingCreateNestedManyWithoutSyllabusContentInput = {
    create?: XOR<CourseLoggingCreateWithoutSyllabusContentInput, CourseLoggingUncheckedCreateWithoutSyllabusContentInput> | CourseLoggingCreateWithoutSyllabusContentInput[] | CourseLoggingUncheckedCreateWithoutSyllabusContentInput[]
    connectOrCreate?: CourseLoggingCreateOrConnectWithoutSyllabusContentInput | CourseLoggingCreateOrConnectWithoutSyllabusContentInput[]
    createMany?: CourseLoggingCreateManySyllabusContentInputEnvelope
    connect?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
  }

  export type ExamUncheckedCreateNestedManyWithoutSyllabusContentInput = {
    create?: XOR<ExamCreateWithoutSyllabusContentInput, ExamUncheckedCreateWithoutSyllabusContentInput> | ExamCreateWithoutSyllabusContentInput[] | ExamUncheckedCreateWithoutSyllabusContentInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutSyllabusContentInput | ExamCreateOrConnectWithoutSyllabusContentInput[]
    createMany?: ExamCreateManySyllabusContentInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type MaterialContentUncheckedCreateNestedManyWithoutSyllabusContentInput = {
    create?: XOR<MaterialContentCreateWithoutSyllabusContentInput, MaterialContentUncheckedCreateWithoutSyllabusContentInput> | MaterialContentCreateWithoutSyllabusContentInput[] | MaterialContentUncheckedCreateWithoutSyllabusContentInput[]
    connectOrCreate?: MaterialContentCreateOrConnectWithoutSyllabusContentInput | MaterialContentCreateOrConnectWithoutSyllabusContentInput[]
    createMany?: MaterialContentCreateManySyllabusContentInputEnvelope
    connect?: MaterialContentWhereUniqueInput | MaterialContentWhereUniqueInput[]
  }

  export type CourseLoggingUncheckedCreateNestedManyWithoutSyllabusContentInput = {
    create?: XOR<CourseLoggingCreateWithoutSyllabusContentInput, CourseLoggingUncheckedCreateWithoutSyllabusContentInput> | CourseLoggingCreateWithoutSyllabusContentInput[] | CourseLoggingUncheckedCreateWithoutSyllabusContentInput[]
    connectOrCreate?: CourseLoggingCreateOrConnectWithoutSyllabusContentInput | CourseLoggingCreateOrConnectWithoutSyllabusContentInput[]
    createMany?: CourseLoggingCreateManySyllabusContentInputEnvelope
    connect?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
  }

  export type EnumSyllabusContentTypeFieldUpdateOperationsInput = {
    set?: $Enums.SyllabusContentType
  }

  export type ExamUpdateManyWithoutSyllabusContentNestedInput = {
    create?: XOR<ExamCreateWithoutSyllabusContentInput, ExamUncheckedCreateWithoutSyllabusContentInput> | ExamCreateWithoutSyllabusContentInput[] | ExamUncheckedCreateWithoutSyllabusContentInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutSyllabusContentInput | ExamCreateOrConnectWithoutSyllabusContentInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutSyllabusContentInput | ExamUpsertWithWhereUniqueWithoutSyllabusContentInput[]
    createMany?: ExamCreateManySyllabusContentInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutSyllabusContentInput | ExamUpdateWithWhereUniqueWithoutSyllabusContentInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutSyllabusContentInput | ExamUpdateManyWithWhereWithoutSyllabusContentInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type MaterialContentUpdateManyWithoutSyllabusContentNestedInput = {
    create?: XOR<MaterialContentCreateWithoutSyllabusContentInput, MaterialContentUncheckedCreateWithoutSyllabusContentInput> | MaterialContentCreateWithoutSyllabusContentInput[] | MaterialContentUncheckedCreateWithoutSyllabusContentInput[]
    connectOrCreate?: MaterialContentCreateOrConnectWithoutSyllabusContentInput | MaterialContentCreateOrConnectWithoutSyllabusContentInput[]
    upsert?: MaterialContentUpsertWithWhereUniqueWithoutSyllabusContentInput | MaterialContentUpsertWithWhereUniqueWithoutSyllabusContentInput[]
    createMany?: MaterialContentCreateManySyllabusContentInputEnvelope
    set?: MaterialContentWhereUniqueInput | MaterialContentWhereUniqueInput[]
    disconnect?: MaterialContentWhereUniqueInput | MaterialContentWhereUniqueInput[]
    delete?: MaterialContentWhereUniqueInput | MaterialContentWhereUniqueInput[]
    connect?: MaterialContentWhereUniqueInput | MaterialContentWhereUniqueInput[]
    update?: MaterialContentUpdateWithWhereUniqueWithoutSyllabusContentInput | MaterialContentUpdateWithWhereUniqueWithoutSyllabusContentInput[]
    updateMany?: MaterialContentUpdateManyWithWhereWithoutSyllabusContentInput | MaterialContentUpdateManyWithWhereWithoutSyllabusContentInput[]
    deleteMany?: MaterialContentScalarWhereInput | MaterialContentScalarWhereInput[]
  }

  export type SyllabusUpdateOneRequiredWithoutSyllabusContentNestedInput = {
    create?: XOR<SyllabusCreateWithoutSyllabusContentInput, SyllabusUncheckedCreateWithoutSyllabusContentInput>
    connectOrCreate?: SyllabusCreateOrConnectWithoutSyllabusContentInput
    upsert?: SyllabusUpsertWithoutSyllabusContentInput
    connect?: SyllabusWhereUniqueInput
    update?: XOR<XOR<SyllabusUpdateToOneWithWhereWithoutSyllabusContentInput, SyllabusUpdateWithoutSyllabusContentInput>, SyllabusUncheckedUpdateWithoutSyllabusContentInput>
  }

  export type CourseLoggingUpdateManyWithoutSyllabusContentNestedInput = {
    create?: XOR<CourseLoggingCreateWithoutSyllabusContentInput, CourseLoggingUncheckedCreateWithoutSyllabusContentInput> | CourseLoggingCreateWithoutSyllabusContentInput[] | CourseLoggingUncheckedCreateWithoutSyllabusContentInput[]
    connectOrCreate?: CourseLoggingCreateOrConnectWithoutSyllabusContentInput | CourseLoggingCreateOrConnectWithoutSyllabusContentInput[]
    upsert?: CourseLoggingUpsertWithWhereUniqueWithoutSyllabusContentInput | CourseLoggingUpsertWithWhereUniqueWithoutSyllabusContentInput[]
    createMany?: CourseLoggingCreateManySyllabusContentInputEnvelope
    set?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    disconnect?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    delete?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    connect?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    update?: CourseLoggingUpdateWithWhereUniqueWithoutSyllabusContentInput | CourseLoggingUpdateWithWhereUniqueWithoutSyllabusContentInput[]
    updateMany?: CourseLoggingUpdateManyWithWhereWithoutSyllabusContentInput | CourseLoggingUpdateManyWithWhereWithoutSyllabusContentInput[]
    deleteMany?: CourseLoggingScalarWhereInput | CourseLoggingScalarWhereInput[]
  }

  export type ExamUncheckedUpdateManyWithoutSyllabusContentNestedInput = {
    create?: XOR<ExamCreateWithoutSyllabusContentInput, ExamUncheckedCreateWithoutSyllabusContentInput> | ExamCreateWithoutSyllabusContentInput[] | ExamUncheckedCreateWithoutSyllabusContentInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutSyllabusContentInput | ExamCreateOrConnectWithoutSyllabusContentInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutSyllabusContentInput | ExamUpsertWithWhereUniqueWithoutSyllabusContentInput[]
    createMany?: ExamCreateManySyllabusContentInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutSyllabusContentInput | ExamUpdateWithWhereUniqueWithoutSyllabusContentInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutSyllabusContentInput | ExamUpdateManyWithWhereWithoutSyllabusContentInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type MaterialContentUncheckedUpdateManyWithoutSyllabusContentNestedInput = {
    create?: XOR<MaterialContentCreateWithoutSyllabusContentInput, MaterialContentUncheckedCreateWithoutSyllabusContentInput> | MaterialContentCreateWithoutSyllabusContentInput[] | MaterialContentUncheckedCreateWithoutSyllabusContentInput[]
    connectOrCreate?: MaterialContentCreateOrConnectWithoutSyllabusContentInput | MaterialContentCreateOrConnectWithoutSyllabusContentInput[]
    upsert?: MaterialContentUpsertWithWhereUniqueWithoutSyllabusContentInput | MaterialContentUpsertWithWhereUniqueWithoutSyllabusContentInput[]
    createMany?: MaterialContentCreateManySyllabusContentInputEnvelope
    set?: MaterialContentWhereUniqueInput | MaterialContentWhereUniqueInput[]
    disconnect?: MaterialContentWhereUniqueInput | MaterialContentWhereUniqueInput[]
    delete?: MaterialContentWhereUniqueInput | MaterialContentWhereUniqueInput[]
    connect?: MaterialContentWhereUniqueInput | MaterialContentWhereUniqueInput[]
    update?: MaterialContentUpdateWithWhereUniqueWithoutSyllabusContentInput | MaterialContentUpdateWithWhereUniqueWithoutSyllabusContentInput[]
    updateMany?: MaterialContentUpdateManyWithWhereWithoutSyllabusContentInput | MaterialContentUpdateManyWithWhereWithoutSyllabusContentInput[]
    deleteMany?: MaterialContentScalarWhereInput | MaterialContentScalarWhereInput[]
  }

  export type CourseLoggingUncheckedUpdateManyWithoutSyllabusContentNestedInput = {
    create?: XOR<CourseLoggingCreateWithoutSyllabusContentInput, CourseLoggingUncheckedCreateWithoutSyllabusContentInput> | CourseLoggingCreateWithoutSyllabusContentInput[] | CourseLoggingUncheckedCreateWithoutSyllabusContentInput[]
    connectOrCreate?: CourseLoggingCreateOrConnectWithoutSyllabusContentInput | CourseLoggingCreateOrConnectWithoutSyllabusContentInput[]
    upsert?: CourseLoggingUpsertWithWhereUniqueWithoutSyllabusContentInput | CourseLoggingUpsertWithWhereUniqueWithoutSyllabusContentInput[]
    createMany?: CourseLoggingCreateManySyllabusContentInputEnvelope
    set?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    disconnect?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    delete?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    connect?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    update?: CourseLoggingUpdateWithWhereUniqueWithoutSyllabusContentInput | CourseLoggingUpdateWithWhereUniqueWithoutSyllabusContentInput[]
    updateMany?: CourseLoggingUpdateManyWithWhereWithoutSyllabusContentInput | CourseLoggingUpdateManyWithWhereWithoutSyllabusContentInput[]
    deleteMany?: CourseLoggingScalarWhereInput | CourseLoggingScalarWhereInput[]
  }

  export type SyllabusContentCreateNestedOneWithoutExamsInput = {
    create?: XOR<SyllabusContentCreateWithoutExamsInput, SyllabusContentUncheckedCreateWithoutExamsInput>
    connectOrCreate?: SyllabusContentCreateOrConnectWithoutExamsInput
    connect?: SyllabusContentWhereUniqueInput
  }

  export type ExamQuestionCreateNestedManyWithoutExamInput = {
    create?: XOR<ExamQuestionCreateWithoutExamInput, ExamQuestionUncheckedCreateWithoutExamInput> | ExamQuestionCreateWithoutExamInput[] | ExamQuestionUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamQuestionCreateOrConnectWithoutExamInput | ExamQuestionCreateOrConnectWithoutExamInput[]
    createMany?: ExamQuestionCreateManyExamInputEnvelope
    connect?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
  }

  export type CourseLoggingCreateNestedManyWithoutExamInput = {
    create?: XOR<CourseLoggingCreateWithoutExamInput, CourseLoggingUncheckedCreateWithoutExamInput> | CourseLoggingCreateWithoutExamInput[] | CourseLoggingUncheckedCreateWithoutExamInput[]
    connectOrCreate?: CourseLoggingCreateOrConnectWithoutExamInput | CourseLoggingCreateOrConnectWithoutExamInput[]
    createMany?: CourseLoggingCreateManyExamInputEnvelope
    connect?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
  }

  export type ExamQuestionUncheckedCreateNestedManyWithoutExamInput = {
    create?: XOR<ExamQuestionCreateWithoutExamInput, ExamQuestionUncheckedCreateWithoutExamInput> | ExamQuestionCreateWithoutExamInput[] | ExamQuestionUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamQuestionCreateOrConnectWithoutExamInput | ExamQuestionCreateOrConnectWithoutExamInput[]
    createMany?: ExamQuestionCreateManyExamInputEnvelope
    connect?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
  }

  export type CourseLoggingUncheckedCreateNestedManyWithoutExamInput = {
    create?: XOR<CourseLoggingCreateWithoutExamInput, CourseLoggingUncheckedCreateWithoutExamInput> | CourseLoggingCreateWithoutExamInput[] | CourseLoggingUncheckedCreateWithoutExamInput[]
    connectOrCreate?: CourseLoggingCreateOrConnectWithoutExamInput | CourseLoggingCreateOrConnectWithoutExamInput[]
    createMany?: CourseLoggingCreateManyExamInputEnvelope
    connect?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
  }

  export type SyllabusContentUpdateOneRequiredWithoutExamsNestedInput = {
    create?: XOR<SyllabusContentCreateWithoutExamsInput, SyllabusContentUncheckedCreateWithoutExamsInput>
    connectOrCreate?: SyllabusContentCreateOrConnectWithoutExamsInput
    upsert?: SyllabusContentUpsertWithoutExamsInput
    connect?: SyllabusContentWhereUniqueInput
    update?: XOR<XOR<SyllabusContentUpdateToOneWithWhereWithoutExamsInput, SyllabusContentUpdateWithoutExamsInput>, SyllabusContentUncheckedUpdateWithoutExamsInput>
  }

  export type ExamQuestionUpdateManyWithoutExamNestedInput = {
    create?: XOR<ExamQuestionCreateWithoutExamInput, ExamQuestionUncheckedCreateWithoutExamInput> | ExamQuestionCreateWithoutExamInput[] | ExamQuestionUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamQuestionCreateOrConnectWithoutExamInput | ExamQuestionCreateOrConnectWithoutExamInput[]
    upsert?: ExamQuestionUpsertWithWhereUniqueWithoutExamInput | ExamQuestionUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: ExamQuestionCreateManyExamInputEnvelope
    set?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
    disconnect?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
    delete?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
    connect?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
    update?: ExamQuestionUpdateWithWhereUniqueWithoutExamInput | ExamQuestionUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: ExamQuestionUpdateManyWithWhereWithoutExamInput | ExamQuestionUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: ExamQuestionScalarWhereInput | ExamQuestionScalarWhereInput[]
  }

  export type CourseLoggingUpdateManyWithoutExamNestedInput = {
    create?: XOR<CourseLoggingCreateWithoutExamInput, CourseLoggingUncheckedCreateWithoutExamInput> | CourseLoggingCreateWithoutExamInput[] | CourseLoggingUncheckedCreateWithoutExamInput[]
    connectOrCreate?: CourseLoggingCreateOrConnectWithoutExamInput | CourseLoggingCreateOrConnectWithoutExamInput[]
    upsert?: CourseLoggingUpsertWithWhereUniqueWithoutExamInput | CourseLoggingUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: CourseLoggingCreateManyExamInputEnvelope
    set?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    disconnect?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    delete?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    connect?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    update?: CourseLoggingUpdateWithWhereUniqueWithoutExamInput | CourseLoggingUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: CourseLoggingUpdateManyWithWhereWithoutExamInput | CourseLoggingUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: CourseLoggingScalarWhereInput | CourseLoggingScalarWhereInput[]
  }

  export type ExamQuestionUncheckedUpdateManyWithoutExamNestedInput = {
    create?: XOR<ExamQuestionCreateWithoutExamInput, ExamQuestionUncheckedCreateWithoutExamInput> | ExamQuestionCreateWithoutExamInput[] | ExamQuestionUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamQuestionCreateOrConnectWithoutExamInput | ExamQuestionCreateOrConnectWithoutExamInput[]
    upsert?: ExamQuestionUpsertWithWhereUniqueWithoutExamInput | ExamQuestionUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: ExamQuestionCreateManyExamInputEnvelope
    set?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
    disconnect?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
    delete?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
    connect?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
    update?: ExamQuestionUpdateWithWhereUniqueWithoutExamInput | ExamQuestionUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: ExamQuestionUpdateManyWithWhereWithoutExamInput | ExamQuestionUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: ExamQuestionScalarWhereInput | ExamQuestionScalarWhereInput[]
  }

  export type CourseLoggingUncheckedUpdateManyWithoutExamNestedInput = {
    create?: XOR<CourseLoggingCreateWithoutExamInput, CourseLoggingUncheckedCreateWithoutExamInput> | CourseLoggingCreateWithoutExamInput[] | CourseLoggingUncheckedCreateWithoutExamInput[]
    connectOrCreate?: CourseLoggingCreateOrConnectWithoutExamInput | CourseLoggingCreateOrConnectWithoutExamInput[]
    upsert?: CourseLoggingUpsertWithWhereUniqueWithoutExamInput | CourseLoggingUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: CourseLoggingCreateManyExamInputEnvelope
    set?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    disconnect?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    delete?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    connect?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    update?: CourseLoggingUpdateWithWhereUniqueWithoutExamInput | CourseLoggingUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: CourseLoggingUpdateManyWithWhereWithoutExamInput | CourseLoggingUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: CourseLoggingScalarWhereInput | CourseLoggingScalarWhereInput[]
  }

  export type ExamCreateNestedOneWithoutExamQuestionsInput = {
    create?: XOR<ExamCreateWithoutExamQuestionsInput, ExamUncheckedCreateWithoutExamQuestionsInput>
    connectOrCreate?: ExamCreateOrConnectWithoutExamQuestionsInput
    connect?: ExamWhereUniqueInput
  }

  export type ExamOptionQuestionCreateNestedManyWithoutExamQuestionInput = {
    create?: XOR<ExamOptionQuestionCreateWithoutExamQuestionInput, ExamOptionQuestionUncheckedCreateWithoutExamQuestionInput> | ExamOptionQuestionCreateWithoutExamQuestionInput[] | ExamOptionQuestionUncheckedCreateWithoutExamQuestionInput[]
    connectOrCreate?: ExamOptionQuestionCreateOrConnectWithoutExamQuestionInput | ExamOptionQuestionCreateOrConnectWithoutExamQuestionInput[]
    createMany?: ExamOptionQuestionCreateManyExamQuestionInputEnvelope
    connect?: ExamOptionQuestionWhereUniqueInput | ExamOptionQuestionWhereUniqueInput[]
  }

  export type ExamOptionQuestionUncheckedCreateNestedManyWithoutExamQuestionInput = {
    create?: XOR<ExamOptionQuestionCreateWithoutExamQuestionInput, ExamOptionQuestionUncheckedCreateWithoutExamQuestionInput> | ExamOptionQuestionCreateWithoutExamQuestionInput[] | ExamOptionQuestionUncheckedCreateWithoutExamQuestionInput[]
    connectOrCreate?: ExamOptionQuestionCreateOrConnectWithoutExamQuestionInput | ExamOptionQuestionCreateOrConnectWithoutExamQuestionInput[]
    createMany?: ExamOptionQuestionCreateManyExamQuestionInputEnvelope
    connect?: ExamOptionQuestionWhereUniqueInput | ExamOptionQuestionWhereUniqueInput[]
  }

  export type EnumTypeQuestionFieldUpdateOperationsInput = {
    set?: $Enums.TypeQuestion
  }

  export type ExamUpdateOneRequiredWithoutExamQuestionsNestedInput = {
    create?: XOR<ExamCreateWithoutExamQuestionsInput, ExamUncheckedCreateWithoutExamQuestionsInput>
    connectOrCreate?: ExamCreateOrConnectWithoutExamQuestionsInput
    upsert?: ExamUpsertWithoutExamQuestionsInput
    connect?: ExamWhereUniqueInput
    update?: XOR<XOR<ExamUpdateToOneWithWhereWithoutExamQuestionsInput, ExamUpdateWithoutExamQuestionsInput>, ExamUncheckedUpdateWithoutExamQuestionsInput>
  }

  export type ExamOptionQuestionUpdateManyWithoutExamQuestionNestedInput = {
    create?: XOR<ExamOptionQuestionCreateWithoutExamQuestionInput, ExamOptionQuestionUncheckedCreateWithoutExamQuestionInput> | ExamOptionQuestionCreateWithoutExamQuestionInput[] | ExamOptionQuestionUncheckedCreateWithoutExamQuestionInput[]
    connectOrCreate?: ExamOptionQuestionCreateOrConnectWithoutExamQuestionInput | ExamOptionQuestionCreateOrConnectWithoutExamQuestionInput[]
    upsert?: ExamOptionQuestionUpsertWithWhereUniqueWithoutExamQuestionInput | ExamOptionQuestionUpsertWithWhereUniqueWithoutExamQuestionInput[]
    createMany?: ExamOptionQuestionCreateManyExamQuestionInputEnvelope
    set?: ExamOptionQuestionWhereUniqueInput | ExamOptionQuestionWhereUniqueInput[]
    disconnect?: ExamOptionQuestionWhereUniqueInput | ExamOptionQuestionWhereUniqueInput[]
    delete?: ExamOptionQuestionWhereUniqueInput | ExamOptionQuestionWhereUniqueInput[]
    connect?: ExamOptionQuestionWhereUniqueInput | ExamOptionQuestionWhereUniqueInput[]
    update?: ExamOptionQuestionUpdateWithWhereUniqueWithoutExamQuestionInput | ExamOptionQuestionUpdateWithWhereUniqueWithoutExamQuestionInput[]
    updateMany?: ExamOptionQuestionUpdateManyWithWhereWithoutExamQuestionInput | ExamOptionQuestionUpdateManyWithWhereWithoutExamQuestionInput[]
    deleteMany?: ExamOptionQuestionScalarWhereInput | ExamOptionQuestionScalarWhereInput[]
  }

  export type ExamOptionQuestionUncheckedUpdateManyWithoutExamQuestionNestedInput = {
    create?: XOR<ExamOptionQuestionCreateWithoutExamQuestionInput, ExamOptionQuestionUncheckedCreateWithoutExamQuestionInput> | ExamOptionQuestionCreateWithoutExamQuestionInput[] | ExamOptionQuestionUncheckedCreateWithoutExamQuestionInput[]
    connectOrCreate?: ExamOptionQuestionCreateOrConnectWithoutExamQuestionInput | ExamOptionQuestionCreateOrConnectWithoutExamQuestionInput[]
    upsert?: ExamOptionQuestionUpsertWithWhereUniqueWithoutExamQuestionInput | ExamOptionQuestionUpsertWithWhereUniqueWithoutExamQuestionInput[]
    createMany?: ExamOptionQuestionCreateManyExamQuestionInputEnvelope
    set?: ExamOptionQuestionWhereUniqueInput | ExamOptionQuestionWhereUniqueInput[]
    disconnect?: ExamOptionQuestionWhereUniqueInput | ExamOptionQuestionWhereUniqueInput[]
    delete?: ExamOptionQuestionWhereUniqueInput | ExamOptionQuestionWhereUniqueInput[]
    connect?: ExamOptionQuestionWhereUniqueInput | ExamOptionQuestionWhereUniqueInput[]
    update?: ExamOptionQuestionUpdateWithWhereUniqueWithoutExamQuestionInput | ExamOptionQuestionUpdateWithWhereUniqueWithoutExamQuestionInput[]
    updateMany?: ExamOptionQuestionUpdateManyWithWhereWithoutExamQuestionInput | ExamOptionQuestionUpdateManyWithWhereWithoutExamQuestionInput[]
    deleteMany?: ExamOptionQuestionScalarWhereInput | ExamOptionQuestionScalarWhereInput[]
  }

  export type ExamQuestionCreateNestedOneWithoutExamOptionsInput = {
    create?: XOR<ExamQuestionCreateWithoutExamOptionsInput, ExamQuestionUncheckedCreateWithoutExamOptionsInput>
    connectOrCreate?: ExamQuestionCreateOrConnectWithoutExamOptionsInput
    connect?: ExamQuestionWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type ExamQuestionUpdateOneRequiredWithoutExamOptionsNestedInput = {
    create?: XOR<ExamQuestionCreateWithoutExamOptionsInput, ExamQuestionUncheckedCreateWithoutExamOptionsInput>
    connectOrCreate?: ExamQuestionCreateOrConnectWithoutExamOptionsInput
    upsert?: ExamQuestionUpsertWithoutExamOptionsInput
    connect?: ExamQuestionWhereUniqueInput
    update?: XOR<XOR<ExamQuestionUpdateToOneWithWhereWithoutExamOptionsInput, ExamQuestionUpdateWithoutExamOptionsInput>, ExamQuestionUncheckedUpdateWithoutExamOptionsInput>
  }

  export type MaterialContentCreateNestedManyWithoutTypeInput = {
    create?: XOR<MaterialContentCreateWithoutTypeInput, MaterialContentUncheckedCreateWithoutTypeInput> | MaterialContentCreateWithoutTypeInput[] | MaterialContentUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: MaterialContentCreateOrConnectWithoutTypeInput | MaterialContentCreateOrConnectWithoutTypeInput[]
    createMany?: MaterialContentCreateManyTypeInputEnvelope
    connect?: MaterialContentWhereUniqueInput | MaterialContentWhereUniqueInput[]
  }

  export type MaterialContentUncheckedCreateNestedManyWithoutTypeInput = {
    create?: XOR<MaterialContentCreateWithoutTypeInput, MaterialContentUncheckedCreateWithoutTypeInput> | MaterialContentCreateWithoutTypeInput[] | MaterialContentUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: MaterialContentCreateOrConnectWithoutTypeInput | MaterialContentCreateOrConnectWithoutTypeInput[]
    createMany?: MaterialContentCreateManyTypeInputEnvelope
    connect?: MaterialContentWhereUniqueInput | MaterialContentWhereUniqueInput[]
  }

  export type EnumTypeMaterialContentFieldUpdateOperationsInput = {
    set?: $Enums.TypeMaterialContent
  }

  export type MaterialContentUpdateManyWithoutTypeNestedInput = {
    create?: XOR<MaterialContentCreateWithoutTypeInput, MaterialContentUncheckedCreateWithoutTypeInput> | MaterialContentCreateWithoutTypeInput[] | MaterialContentUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: MaterialContentCreateOrConnectWithoutTypeInput | MaterialContentCreateOrConnectWithoutTypeInput[]
    upsert?: MaterialContentUpsertWithWhereUniqueWithoutTypeInput | MaterialContentUpsertWithWhereUniqueWithoutTypeInput[]
    createMany?: MaterialContentCreateManyTypeInputEnvelope
    set?: MaterialContentWhereUniqueInput | MaterialContentWhereUniqueInput[]
    disconnect?: MaterialContentWhereUniqueInput | MaterialContentWhereUniqueInput[]
    delete?: MaterialContentWhereUniqueInput | MaterialContentWhereUniqueInput[]
    connect?: MaterialContentWhereUniqueInput | MaterialContentWhereUniqueInput[]
    update?: MaterialContentUpdateWithWhereUniqueWithoutTypeInput | MaterialContentUpdateWithWhereUniqueWithoutTypeInput[]
    updateMany?: MaterialContentUpdateManyWithWhereWithoutTypeInput | MaterialContentUpdateManyWithWhereWithoutTypeInput[]
    deleteMany?: MaterialContentScalarWhereInput | MaterialContentScalarWhereInput[]
  }

  export type MaterialContentUncheckedUpdateManyWithoutTypeNestedInput = {
    create?: XOR<MaterialContentCreateWithoutTypeInput, MaterialContentUncheckedCreateWithoutTypeInput> | MaterialContentCreateWithoutTypeInput[] | MaterialContentUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: MaterialContentCreateOrConnectWithoutTypeInput | MaterialContentCreateOrConnectWithoutTypeInput[]
    upsert?: MaterialContentUpsertWithWhereUniqueWithoutTypeInput | MaterialContentUpsertWithWhereUniqueWithoutTypeInput[]
    createMany?: MaterialContentCreateManyTypeInputEnvelope
    set?: MaterialContentWhereUniqueInput | MaterialContentWhereUniqueInput[]
    disconnect?: MaterialContentWhereUniqueInput | MaterialContentWhereUniqueInput[]
    delete?: MaterialContentWhereUniqueInput | MaterialContentWhereUniqueInput[]
    connect?: MaterialContentWhereUniqueInput | MaterialContentWhereUniqueInput[]
    update?: MaterialContentUpdateWithWhereUniqueWithoutTypeInput | MaterialContentUpdateWithWhereUniqueWithoutTypeInput[]
    updateMany?: MaterialContentUpdateManyWithWhereWithoutTypeInput | MaterialContentUpdateManyWithWhereWithoutTypeInput[]
    deleteMany?: MaterialContentScalarWhereInput | MaterialContentScalarWhereInput[]
  }

  export type MaterialContentTypeCreateNestedOneWithoutMaterialContentsInput = {
    create?: XOR<MaterialContentTypeCreateWithoutMaterialContentsInput, MaterialContentTypeUncheckedCreateWithoutMaterialContentsInput>
    connectOrCreate?: MaterialContentTypeCreateOrConnectWithoutMaterialContentsInput
    connect?: MaterialContentTypeWhereUniqueInput
  }

  export type SyllabusContentCreateNestedOneWithoutMaterialContentsInput = {
    create?: XOR<SyllabusContentCreateWithoutMaterialContentsInput, SyllabusContentUncheckedCreateWithoutMaterialContentsInput>
    connectOrCreate?: SyllabusContentCreateOrConnectWithoutMaterialContentsInput
    connect?: SyllabusContentWhereUniqueInput
  }

  export type MaterialContentAttachmentCreateNestedManyWithoutMaterialContentInput = {
    create?: XOR<MaterialContentAttachmentCreateWithoutMaterialContentInput, MaterialContentAttachmentUncheckedCreateWithoutMaterialContentInput> | MaterialContentAttachmentCreateWithoutMaterialContentInput[] | MaterialContentAttachmentUncheckedCreateWithoutMaterialContentInput[]
    connectOrCreate?: MaterialContentAttachmentCreateOrConnectWithoutMaterialContentInput | MaterialContentAttachmentCreateOrConnectWithoutMaterialContentInput[]
    createMany?: MaterialContentAttachmentCreateManyMaterialContentInputEnvelope
    connect?: MaterialContentAttachmentWhereUniqueInput | MaterialContentAttachmentWhereUniqueInput[]
  }

  export type MaterialContentFileCreateNestedOneWithoutMaterialContentInput = {
    create?: XOR<MaterialContentFileCreateWithoutMaterialContentInput, MaterialContentFileUncheckedCreateWithoutMaterialContentInput>
    connectOrCreate?: MaterialContentFileCreateOrConnectWithoutMaterialContentInput
    connect?: MaterialContentFileWhereUniqueInput
  }

  export type MaterialContentLearningCreateNestedOneWithoutMaterialContentInput = {
    create?: XOR<MaterialContentLearningCreateWithoutMaterialContentInput, MaterialContentLearningUncheckedCreateWithoutMaterialContentInput>
    connectOrCreate?: MaterialContentLearningCreateOrConnectWithoutMaterialContentInput
    connect?: MaterialContentLearningWhereUniqueInput
  }

  export type MaterialContentTestCreateNestedOneWithoutMaterialContentInput = {
    create?: XOR<MaterialContentTestCreateWithoutMaterialContentInput, MaterialContentTestUncheckedCreateWithoutMaterialContentInput>
    connectOrCreate?: MaterialContentTestCreateOrConnectWithoutMaterialContentInput
    connect?: MaterialContentTestWhereUniqueInput
  }

  export type CourseLoggingCreateNestedManyWithoutMaterialContentInput = {
    create?: XOR<CourseLoggingCreateWithoutMaterialContentInput, CourseLoggingUncheckedCreateWithoutMaterialContentInput> | CourseLoggingCreateWithoutMaterialContentInput[] | CourseLoggingUncheckedCreateWithoutMaterialContentInput[]
    connectOrCreate?: CourseLoggingCreateOrConnectWithoutMaterialContentInput | CourseLoggingCreateOrConnectWithoutMaterialContentInput[]
    createMany?: CourseLoggingCreateManyMaterialContentInputEnvelope
    connect?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
  }

  export type MaterialContentAttachmentUncheckedCreateNestedManyWithoutMaterialContentInput = {
    create?: XOR<MaterialContentAttachmentCreateWithoutMaterialContentInput, MaterialContentAttachmentUncheckedCreateWithoutMaterialContentInput> | MaterialContentAttachmentCreateWithoutMaterialContentInput[] | MaterialContentAttachmentUncheckedCreateWithoutMaterialContentInput[]
    connectOrCreate?: MaterialContentAttachmentCreateOrConnectWithoutMaterialContentInput | MaterialContentAttachmentCreateOrConnectWithoutMaterialContentInput[]
    createMany?: MaterialContentAttachmentCreateManyMaterialContentInputEnvelope
    connect?: MaterialContentAttachmentWhereUniqueInput | MaterialContentAttachmentWhereUniqueInput[]
  }

  export type MaterialContentFileUncheckedCreateNestedOneWithoutMaterialContentInput = {
    create?: XOR<MaterialContentFileCreateWithoutMaterialContentInput, MaterialContentFileUncheckedCreateWithoutMaterialContentInput>
    connectOrCreate?: MaterialContentFileCreateOrConnectWithoutMaterialContentInput
    connect?: MaterialContentFileWhereUniqueInput
  }

  export type MaterialContentLearningUncheckedCreateNestedOneWithoutMaterialContentInput = {
    create?: XOR<MaterialContentLearningCreateWithoutMaterialContentInput, MaterialContentLearningUncheckedCreateWithoutMaterialContentInput>
    connectOrCreate?: MaterialContentLearningCreateOrConnectWithoutMaterialContentInput
    connect?: MaterialContentLearningWhereUniqueInput
  }

  export type MaterialContentTestUncheckedCreateNestedOneWithoutMaterialContentInput = {
    create?: XOR<MaterialContentTestCreateWithoutMaterialContentInput, MaterialContentTestUncheckedCreateWithoutMaterialContentInput>
    connectOrCreate?: MaterialContentTestCreateOrConnectWithoutMaterialContentInput
    connect?: MaterialContentTestWhereUniqueInput
  }

  export type CourseLoggingUncheckedCreateNestedManyWithoutMaterialContentInput = {
    create?: XOR<CourseLoggingCreateWithoutMaterialContentInput, CourseLoggingUncheckedCreateWithoutMaterialContentInput> | CourseLoggingCreateWithoutMaterialContentInput[] | CourseLoggingUncheckedCreateWithoutMaterialContentInput[]
    connectOrCreate?: CourseLoggingCreateOrConnectWithoutMaterialContentInput | CourseLoggingCreateOrConnectWithoutMaterialContentInput[]
    createMany?: CourseLoggingCreateManyMaterialContentInputEnvelope
    connect?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
  }

  export type MaterialContentTypeUpdateOneRequiredWithoutMaterialContentsNestedInput = {
    create?: XOR<MaterialContentTypeCreateWithoutMaterialContentsInput, MaterialContentTypeUncheckedCreateWithoutMaterialContentsInput>
    connectOrCreate?: MaterialContentTypeCreateOrConnectWithoutMaterialContentsInput
    upsert?: MaterialContentTypeUpsertWithoutMaterialContentsInput
    connect?: MaterialContentTypeWhereUniqueInput
    update?: XOR<XOR<MaterialContentTypeUpdateToOneWithWhereWithoutMaterialContentsInput, MaterialContentTypeUpdateWithoutMaterialContentsInput>, MaterialContentTypeUncheckedUpdateWithoutMaterialContentsInput>
  }

  export type SyllabusContentUpdateOneRequiredWithoutMaterialContentsNestedInput = {
    create?: XOR<SyllabusContentCreateWithoutMaterialContentsInput, SyllabusContentUncheckedCreateWithoutMaterialContentsInput>
    connectOrCreate?: SyllabusContentCreateOrConnectWithoutMaterialContentsInput
    upsert?: SyllabusContentUpsertWithoutMaterialContentsInput
    connect?: SyllabusContentWhereUniqueInput
    update?: XOR<XOR<SyllabusContentUpdateToOneWithWhereWithoutMaterialContentsInput, SyllabusContentUpdateWithoutMaterialContentsInput>, SyllabusContentUncheckedUpdateWithoutMaterialContentsInput>
  }

  export type MaterialContentAttachmentUpdateManyWithoutMaterialContentNestedInput = {
    create?: XOR<MaterialContentAttachmentCreateWithoutMaterialContentInput, MaterialContentAttachmentUncheckedCreateWithoutMaterialContentInput> | MaterialContentAttachmentCreateWithoutMaterialContentInput[] | MaterialContentAttachmentUncheckedCreateWithoutMaterialContentInput[]
    connectOrCreate?: MaterialContentAttachmentCreateOrConnectWithoutMaterialContentInput | MaterialContentAttachmentCreateOrConnectWithoutMaterialContentInput[]
    upsert?: MaterialContentAttachmentUpsertWithWhereUniqueWithoutMaterialContentInput | MaterialContentAttachmentUpsertWithWhereUniqueWithoutMaterialContentInput[]
    createMany?: MaterialContentAttachmentCreateManyMaterialContentInputEnvelope
    set?: MaterialContentAttachmentWhereUniqueInput | MaterialContentAttachmentWhereUniqueInput[]
    disconnect?: MaterialContentAttachmentWhereUniqueInput | MaterialContentAttachmentWhereUniqueInput[]
    delete?: MaterialContentAttachmentWhereUniqueInput | MaterialContentAttachmentWhereUniqueInput[]
    connect?: MaterialContentAttachmentWhereUniqueInput | MaterialContentAttachmentWhereUniqueInput[]
    update?: MaterialContentAttachmentUpdateWithWhereUniqueWithoutMaterialContentInput | MaterialContentAttachmentUpdateWithWhereUniqueWithoutMaterialContentInput[]
    updateMany?: MaterialContentAttachmentUpdateManyWithWhereWithoutMaterialContentInput | MaterialContentAttachmentUpdateManyWithWhereWithoutMaterialContentInput[]
    deleteMany?: MaterialContentAttachmentScalarWhereInput | MaterialContentAttachmentScalarWhereInput[]
  }

  export type MaterialContentFileUpdateOneWithoutMaterialContentNestedInput = {
    create?: XOR<MaterialContentFileCreateWithoutMaterialContentInput, MaterialContentFileUncheckedCreateWithoutMaterialContentInput>
    connectOrCreate?: MaterialContentFileCreateOrConnectWithoutMaterialContentInput
    upsert?: MaterialContentFileUpsertWithoutMaterialContentInput
    disconnect?: MaterialContentFileWhereInput | boolean
    delete?: MaterialContentFileWhereInput | boolean
    connect?: MaterialContentFileWhereUniqueInput
    update?: XOR<XOR<MaterialContentFileUpdateToOneWithWhereWithoutMaterialContentInput, MaterialContentFileUpdateWithoutMaterialContentInput>, MaterialContentFileUncheckedUpdateWithoutMaterialContentInput>
  }

  export type MaterialContentLearningUpdateOneWithoutMaterialContentNestedInput = {
    create?: XOR<MaterialContentLearningCreateWithoutMaterialContentInput, MaterialContentLearningUncheckedCreateWithoutMaterialContentInput>
    connectOrCreate?: MaterialContentLearningCreateOrConnectWithoutMaterialContentInput
    upsert?: MaterialContentLearningUpsertWithoutMaterialContentInput
    disconnect?: MaterialContentLearningWhereInput | boolean
    delete?: MaterialContentLearningWhereInput | boolean
    connect?: MaterialContentLearningWhereUniqueInput
    update?: XOR<XOR<MaterialContentLearningUpdateToOneWithWhereWithoutMaterialContentInput, MaterialContentLearningUpdateWithoutMaterialContentInput>, MaterialContentLearningUncheckedUpdateWithoutMaterialContentInput>
  }

  export type MaterialContentTestUpdateOneWithoutMaterialContentNestedInput = {
    create?: XOR<MaterialContentTestCreateWithoutMaterialContentInput, MaterialContentTestUncheckedCreateWithoutMaterialContentInput>
    connectOrCreate?: MaterialContentTestCreateOrConnectWithoutMaterialContentInput
    upsert?: MaterialContentTestUpsertWithoutMaterialContentInput
    disconnect?: MaterialContentTestWhereInput | boolean
    delete?: MaterialContentTestWhereInput | boolean
    connect?: MaterialContentTestWhereUniqueInput
    update?: XOR<XOR<MaterialContentTestUpdateToOneWithWhereWithoutMaterialContentInput, MaterialContentTestUpdateWithoutMaterialContentInput>, MaterialContentTestUncheckedUpdateWithoutMaterialContentInput>
  }

  export type CourseLoggingUpdateManyWithoutMaterialContentNestedInput = {
    create?: XOR<CourseLoggingCreateWithoutMaterialContentInput, CourseLoggingUncheckedCreateWithoutMaterialContentInput> | CourseLoggingCreateWithoutMaterialContentInput[] | CourseLoggingUncheckedCreateWithoutMaterialContentInput[]
    connectOrCreate?: CourseLoggingCreateOrConnectWithoutMaterialContentInput | CourseLoggingCreateOrConnectWithoutMaterialContentInput[]
    upsert?: CourseLoggingUpsertWithWhereUniqueWithoutMaterialContentInput | CourseLoggingUpsertWithWhereUniqueWithoutMaterialContentInput[]
    createMany?: CourseLoggingCreateManyMaterialContentInputEnvelope
    set?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    disconnect?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    delete?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    connect?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    update?: CourseLoggingUpdateWithWhereUniqueWithoutMaterialContentInput | CourseLoggingUpdateWithWhereUniqueWithoutMaterialContentInput[]
    updateMany?: CourseLoggingUpdateManyWithWhereWithoutMaterialContentInput | CourseLoggingUpdateManyWithWhereWithoutMaterialContentInput[]
    deleteMany?: CourseLoggingScalarWhereInput | CourseLoggingScalarWhereInput[]
  }

  export type MaterialContentAttachmentUncheckedUpdateManyWithoutMaterialContentNestedInput = {
    create?: XOR<MaterialContentAttachmentCreateWithoutMaterialContentInput, MaterialContentAttachmentUncheckedCreateWithoutMaterialContentInput> | MaterialContentAttachmentCreateWithoutMaterialContentInput[] | MaterialContentAttachmentUncheckedCreateWithoutMaterialContentInput[]
    connectOrCreate?: MaterialContentAttachmentCreateOrConnectWithoutMaterialContentInput | MaterialContentAttachmentCreateOrConnectWithoutMaterialContentInput[]
    upsert?: MaterialContentAttachmentUpsertWithWhereUniqueWithoutMaterialContentInput | MaterialContentAttachmentUpsertWithWhereUniqueWithoutMaterialContentInput[]
    createMany?: MaterialContentAttachmentCreateManyMaterialContentInputEnvelope
    set?: MaterialContentAttachmentWhereUniqueInput | MaterialContentAttachmentWhereUniqueInput[]
    disconnect?: MaterialContentAttachmentWhereUniqueInput | MaterialContentAttachmentWhereUniqueInput[]
    delete?: MaterialContentAttachmentWhereUniqueInput | MaterialContentAttachmentWhereUniqueInput[]
    connect?: MaterialContentAttachmentWhereUniqueInput | MaterialContentAttachmentWhereUniqueInput[]
    update?: MaterialContentAttachmentUpdateWithWhereUniqueWithoutMaterialContentInput | MaterialContentAttachmentUpdateWithWhereUniqueWithoutMaterialContentInput[]
    updateMany?: MaterialContentAttachmentUpdateManyWithWhereWithoutMaterialContentInput | MaterialContentAttachmentUpdateManyWithWhereWithoutMaterialContentInput[]
    deleteMany?: MaterialContentAttachmentScalarWhereInput | MaterialContentAttachmentScalarWhereInput[]
  }

  export type MaterialContentFileUncheckedUpdateOneWithoutMaterialContentNestedInput = {
    create?: XOR<MaterialContentFileCreateWithoutMaterialContentInput, MaterialContentFileUncheckedCreateWithoutMaterialContentInput>
    connectOrCreate?: MaterialContentFileCreateOrConnectWithoutMaterialContentInput
    upsert?: MaterialContentFileUpsertWithoutMaterialContentInput
    disconnect?: MaterialContentFileWhereInput | boolean
    delete?: MaterialContentFileWhereInput | boolean
    connect?: MaterialContentFileWhereUniqueInput
    update?: XOR<XOR<MaterialContentFileUpdateToOneWithWhereWithoutMaterialContentInput, MaterialContentFileUpdateWithoutMaterialContentInput>, MaterialContentFileUncheckedUpdateWithoutMaterialContentInput>
  }

  export type MaterialContentLearningUncheckedUpdateOneWithoutMaterialContentNestedInput = {
    create?: XOR<MaterialContentLearningCreateWithoutMaterialContentInput, MaterialContentLearningUncheckedCreateWithoutMaterialContentInput>
    connectOrCreate?: MaterialContentLearningCreateOrConnectWithoutMaterialContentInput
    upsert?: MaterialContentLearningUpsertWithoutMaterialContentInput
    disconnect?: MaterialContentLearningWhereInput | boolean
    delete?: MaterialContentLearningWhereInput | boolean
    connect?: MaterialContentLearningWhereUniqueInput
    update?: XOR<XOR<MaterialContentLearningUpdateToOneWithWhereWithoutMaterialContentInput, MaterialContentLearningUpdateWithoutMaterialContentInput>, MaterialContentLearningUncheckedUpdateWithoutMaterialContentInput>
  }

  export type MaterialContentTestUncheckedUpdateOneWithoutMaterialContentNestedInput = {
    create?: XOR<MaterialContentTestCreateWithoutMaterialContentInput, MaterialContentTestUncheckedCreateWithoutMaterialContentInput>
    connectOrCreate?: MaterialContentTestCreateOrConnectWithoutMaterialContentInput
    upsert?: MaterialContentTestUpsertWithoutMaterialContentInput
    disconnect?: MaterialContentTestWhereInput | boolean
    delete?: MaterialContentTestWhereInput | boolean
    connect?: MaterialContentTestWhereUniqueInput
    update?: XOR<XOR<MaterialContentTestUpdateToOneWithWhereWithoutMaterialContentInput, MaterialContentTestUpdateWithoutMaterialContentInput>, MaterialContentTestUncheckedUpdateWithoutMaterialContentInput>
  }

  export type CourseLoggingUncheckedUpdateManyWithoutMaterialContentNestedInput = {
    create?: XOR<CourseLoggingCreateWithoutMaterialContentInput, CourseLoggingUncheckedCreateWithoutMaterialContentInput> | CourseLoggingCreateWithoutMaterialContentInput[] | CourseLoggingUncheckedCreateWithoutMaterialContentInput[]
    connectOrCreate?: CourseLoggingCreateOrConnectWithoutMaterialContentInput | CourseLoggingCreateOrConnectWithoutMaterialContentInput[]
    upsert?: CourseLoggingUpsertWithWhereUniqueWithoutMaterialContentInput | CourseLoggingUpsertWithWhereUniqueWithoutMaterialContentInput[]
    createMany?: CourseLoggingCreateManyMaterialContentInputEnvelope
    set?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    disconnect?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    delete?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    connect?: CourseLoggingWhereUniqueInput | CourseLoggingWhereUniqueInput[]
    update?: CourseLoggingUpdateWithWhereUniqueWithoutMaterialContentInput | CourseLoggingUpdateWithWhereUniqueWithoutMaterialContentInput[]
    updateMany?: CourseLoggingUpdateManyWithWhereWithoutMaterialContentInput | CourseLoggingUpdateManyWithWhereWithoutMaterialContentInput[]
    deleteMany?: CourseLoggingScalarWhereInput | CourseLoggingScalarWhereInput[]
  }

  export type MaterialContentCreateNestedOneWithoutMaterialContentLearningInput = {
    create?: XOR<MaterialContentCreateWithoutMaterialContentLearningInput, MaterialContentUncheckedCreateWithoutMaterialContentLearningInput>
    connectOrCreate?: MaterialContentCreateOrConnectWithoutMaterialContentLearningInput
    connect?: MaterialContentWhereUniqueInput
  }

  export type MaterialContentUpdateOneRequiredWithoutMaterialContentLearningNestedInput = {
    create?: XOR<MaterialContentCreateWithoutMaterialContentLearningInput, MaterialContentUncheckedCreateWithoutMaterialContentLearningInput>
    connectOrCreate?: MaterialContentCreateOrConnectWithoutMaterialContentLearningInput
    upsert?: MaterialContentUpsertWithoutMaterialContentLearningInput
    connect?: MaterialContentWhereUniqueInput
    update?: XOR<XOR<MaterialContentUpdateToOneWithWhereWithoutMaterialContentLearningInput, MaterialContentUpdateWithoutMaterialContentLearningInput>, MaterialContentUncheckedUpdateWithoutMaterialContentLearningInput>
  }

  export type MaterialContentCreateNestedOneWithoutMaterialContentTestInput = {
    create?: XOR<MaterialContentCreateWithoutMaterialContentTestInput, MaterialContentUncheckedCreateWithoutMaterialContentTestInput>
    connectOrCreate?: MaterialContentCreateOrConnectWithoutMaterialContentTestInput
    connect?: MaterialContentWhereUniqueInput
  }

  export type MaterialContentUpdateOneRequiredWithoutMaterialContentTestNestedInput = {
    create?: XOR<MaterialContentCreateWithoutMaterialContentTestInput, MaterialContentUncheckedCreateWithoutMaterialContentTestInput>
    connectOrCreate?: MaterialContentCreateOrConnectWithoutMaterialContentTestInput
    upsert?: MaterialContentUpsertWithoutMaterialContentTestInput
    connect?: MaterialContentWhereUniqueInput
    update?: XOR<XOR<MaterialContentUpdateToOneWithWhereWithoutMaterialContentTestInput, MaterialContentUpdateWithoutMaterialContentTestInput>, MaterialContentUncheckedUpdateWithoutMaterialContentTestInput>
  }

  export type MaterialContentCreateNestedOneWithoutFileInput = {
    create?: XOR<MaterialContentCreateWithoutFileInput, MaterialContentUncheckedCreateWithoutFileInput>
    connectOrCreate?: MaterialContentCreateOrConnectWithoutFileInput
    connect?: MaterialContentWhereUniqueInput
  }

  export type MaterialContentUpdateOneRequiredWithoutFileNestedInput = {
    create?: XOR<MaterialContentCreateWithoutFileInput, MaterialContentUncheckedCreateWithoutFileInput>
    connectOrCreate?: MaterialContentCreateOrConnectWithoutFileInput
    upsert?: MaterialContentUpsertWithoutFileInput
    connect?: MaterialContentWhereUniqueInput
    update?: XOR<XOR<MaterialContentUpdateToOneWithWhereWithoutFileInput, MaterialContentUpdateWithoutFileInput>, MaterialContentUncheckedUpdateWithoutFileInput>
  }

  export type MaterialContentCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<MaterialContentCreateWithoutAttachmentsInput, MaterialContentUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: MaterialContentCreateOrConnectWithoutAttachmentsInput
    connect?: MaterialContentWhereUniqueInput
  }

  export type MaterialContentUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<MaterialContentCreateWithoutAttachmentsInput, MaterialContentUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: MaterialContentCreateOrConnectWithoutAttachmentsInput
    upsert?: MaterialContentUpsertWithoutAttachmentsInput
    connect?: MaterialContentWhereUniqueInput
    update?: XOR<XOR<MaterialContentUpdateToOneWithWhereWithoutAttachmentsInput, MaterialContentUpdateWithoutAttachmentsInput>, MaterialContentUncheckedUpdateWithoutAttachmentsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumCourseAsFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseAs | EnumCourseAsFieldRefInput<$PrismaModel>
    in?: $Enums.CourseAs[]
    notIn?: $Enums.CourseAs[]
    not?: NestedEnumCourseAsFilter<$PrismaModel> | $Enums.CourseAs
  }

  export type NestedEnumCourseAsWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseAs | EnumCourseAsFieldRefInput<$PrismaModel>
    in?: $Enums.CourseAs[]
    notIn?: $Enums.CourseAs[]
    not?: NestedEnumCourseAsWithAggregatesFilter<$PrismaModel> | $Enums.CourseAs
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourseAsFilter<$PrismaModel>
    _max?: NestedEnumCourseAsFilter<$PrismaModel>
  }

  export type NestedEnumSyllabusContentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SyllabusContentType | EnumSyllabusContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SyllabusContentType[]
    notIn?: $Enums.SyllabusContentType[]
    not?: NestedEnumSyllabusContentTypeFilter<$PrismaModel> | $Enums.SyllabusContentType
  }

  export type NestedEnumSyllabusContentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyllabusContentType | EnumSyllabusContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SyllabusContentType[]
    notIn?: $Enums.SyllabusContentType[]
    not?: NestedEnumSyllabusContentTypeWithAggregatesFilter<$PrismaModel> | $Enums.SyllabusContentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyllabusContentTypeFilter<$PrismaModel>
    _max?: NestedEnumSyllabusContentTypeFilter<$PrismaModel>
  }

  export type NestedEnumTypeQuestionFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeQuestion | EnumTypeQuestionFieldRefInput<$PrismaModel>
    in?: $Enums.TypeQuestion[]
    notIn?: $Enums.TypeQuestion[]
    not?: NestedEnumTypeQuestionFilter<$PrismaModel> | $Enums.TypeQuestion
  }

  export type NestedEnumTypeQuestionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeQuestion | EnumTypeQuestionFieldRefInput<$PrismaModel>
    in?: $Enums.TypeQuestion[]
    notIn?: $Enums.TypeQuestion[]
    not?: NestedEnumTypeQuestionWithAggregatesFilter<$PrismaModel> | $Enums.TypeQuestion
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeQuestionFilter<$PrismaModel>
    _max?: NestedEnumTypeQuestionFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumTypeMaterialContentFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeMaterialContent | EnumTypeMaterialContentFieldRefInput<$PrismaModel>
    in?: $Enums.TypeMaterialContent[]
    notIn?: $Enums.TypeMaterialContent[]
    not?: NestedEnumTypeMaterialContentFilter<$PrismaModel> | $Enums.TypeMaterialContent
  }

  export type NestedEnumTypeMaterialContentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeMaterialContent | EnumTypeMaterialContentFieldRefInput<$PrismaModel>
    in?: $Enums.TypeMaterialContent[]
    notIn?: $Enums.TypeMaterialContent[]
    not?: NestedEnumTypeMaterialContentWithAggregatesFilter<$PrismaModel> | $Enums.TypeMaterialContent
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeMaterialContentFilter<$PrismaModel>
    _max?: NestedEnumTypeMaterialContentFilter<$PrismaModel>
  }

  export type CourseCreatorCreateWithoutUserInput = {
    as: $Enums.CourseAs
    createdAt?: Date | string
    updatedAt?: Date | string
    Course: CourseCreateNestedOneWithoutCourseCreatorInput
  }

  export type CourseCreatorUncheckedCreateWithoutUserInput = {
    id?: number
    courseId: number
    as: $Enums.CourseAs
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseCreatorCreateOrConnectWithoutUserInput = {
    where: CourseCreatorWhereUniqueInput
    create: XOR<CourseCreatorCreateWithoutUserInput, CourseCreatorUncheckedCreateWithoutUserInput>
  }

  export type CourseCreatorCreateManyUserInputEnvelope = {
    data: CourseCreatorCreateManyUserInput | CourseCreatorCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CourseLoggingCreateWithoutUserInput = {
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Course: CourseCreateNestedOneWithoutCourseLoggingsInput
    SyllabusContent: SyllabusContentCreateNestedOneWithoutCourseLoggingInput
    MaterialContent?: MaterialContentCreateNestedOneWithoutCourseLoggingInput
    Exam?: ExamCreateNestedOneWithoutCourseLoggingInput
  }

  export type CourseLoggingUncheckedCreateWithoutUserInput = {
    id?: number
    courseId: number
    syllabusContentId: number
    materialContentId?: number | null
    examId?: number | null
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseLoggingCreateOrConnectWithoutUserInput = {
    where: CourseLoggingWhereUniqueInput
    create: XOR<CourseLoggingCreateWithoutUserInput, CourseLoggingUncheckedCreateWithoutUserInput>
  }

  export type CourseLoggingCreateManyUserInputEnvelope = {
    data: CourseLoggingCreateManyUserInput | CourseLoggingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CourseCreatorUpsertWithWhereUniqueWithoutUserInput = {
    where: CourseCreatorWhereUniqueInput
    update: XOR<CourseCreatorUpdateWithoutUserInput, CourseCreatorUncheckedUpdateWithoutUserInput>
    create: XOR<CourseCreatorCreateWithoutUserInput, CourseCreatorUncheckedCreateWithoutUserInput>
  }

  export type CourseCreatorUpdateWithWhereUniqueWithoutUserInput = {
    where: CourseCreatorWhereUniqueInput
    data: XOR<CourseCreatorUpdateWithoutUserInput, CourseCreatorUncheckedUpdateWithoutUserInput>
  }

  export type CourseCreatorUpdateManyWithWhereWithoutUserInput = {
    where: CourseCreatorScalarWhereInput
    data: XOR<CourseCreatorUpdateManyMutationInput, CourseCreatorUncheckedUpdateManyWithoutUserInput>
  }

  export type CourseCreatorScalarWhereInput = {
    AND?: CourseCreatorScalarWhereInput | CourseCreatorScalarWhereInput[]
    OR?: CourseCreatorScalarWhereInput[]
    NOT?: CourseCreatorScalarWhereInput | CourseCreatorScalarWhereInput[]
    id?: IntFilter<"CourseCreator"> | number
    courseId?: IntFilter<"CourseCreator"> | number
    userId?: StringFilter<"CourseCreator"> | string
    as?: EnumCourseAsFilter<"CourseCreator"> | $Enums.CourseAs
    createdAt?: DateTimeFilter<"CourseCreator"> | Date | string
    updatedAt?: DateTimeFilter<"CourseCreator"> | Date | string
  }

  export type CourseLoggingUpsertWithWhereUniqueWithoutUserInput = {
    where: CourseLoggingWhereUniqueInput
    update: XOR<CourseLoggingUpdateWithoutUserInput, CourseLoggingUncheckedUpdateWithoutUserInput>
    create: XOR<CourseLoggingCreateWithoutUserInput, CourseLoggingUncheckedCreateWithoutUserInput>
  }

  export type CourseLoggingUpdateWithWhereUniqueWithoutUserInput = {
    where: CourseLoggingWhereUniqueInput
    data: XOR<CourseLoggingUpdateWithoutUserInput, CourseLoggingUncheckedUpdateWithoutUserInput>
  }

  export type CourseLoggingUpdateManyWithWhereWithoutUserInput = {
    where: CourseLoggingScalarWhereInput
    data: XOR<CourseLoggingUpdateManyMutationInput, CourseLoggingUncheckedUpdateManyWithoutUserInput>
  }

  export type CourseLoggingScalarWhereInput = {
    AND?: CourseLoggingScalarWhereInput | CourseLoggingScalarWhereInput[]
    OR?: CourseLoggingScalarWhereInput[]
    NOT?: CourseLoggingScalarWhereInput | CourseLoggingScalarWhereInput[]
    id?: IntFilter<"CourseLogging"> | number
    courseId?: IntFilter<"CourseLogging"> | number
    userId?: StringFilter<"CourseLogging"> | string
    syllabusContentId?: IntFilter<"CourseLogging"> | number
    materialContentId?: IntNullableFilter<"CourseLogging"> | number | null
    examId?: IntNullableFilter<"CourseLogging"> | number | null
    isRead?: BoolFilter<"CourseLogging"> | boolean
    createdAt?: DateTimeFilter<"CourseLogging"> | Date | string
    updatedAt?: DateTimeFilter<"CourseLogging"> | Date | string
  }

  export type CourseLoggingCreateWithoutCourseInput = {
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UsersCreateNestedOneWithoutCourseLoggingInput
    SyllabusContent: SyllabusContentCreateNestedOneWithoutCourseLoggingInput
    MaterialContent?: MaterialContentCreateNestedOneWithoutCourseLoggingInput
    Exam?: ExamCreateNestedOneWithoutCourseLoggingInput
  }

  export type CourseLoggingUncheckedCreateWithoutCourseInput = {
    id?: number
    userId: string
    syllabusContentId: number
    materialContentId?: number | null
    examId?: number | null
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseLoggingCreateOrConnectWithoutCourseInput = {
    where: CourseLoggingWhereUniqueInput
    create: XOR<CourseLoggingCreateWithoutCourseInput, CourseLoggingUncheckedCreateWithoutCourseInput>
  }

  export type CourseLoggingCreateManyCourseInputEnvelope = {
    data: CourseLoggingCreateManyCourseInput | CourseLoggingCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CourseTopicCreateWithoutCourseInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    Topic: TopicCreateNestedOneWithoutCourseTopicsInput
  }

  export type CourseTopicUncheckedCreateWithoutCourseInput = {
    id?: number
    topicId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseTopicCreateOrConnectWithoutCourseInput = {
    where: CourseTopicWhereUniqueInput
    create: XOR<CourseTopicCreateWithoutCourseInput, CourseTopicUncheckedCreateWithoutCourseInput>
  }

  export type CourseTopicCreateManyCourseInputEnvelope = {
    data: CourseTopicCreateManyCourseInput | CourseTopicCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type SyllabusCreateWithoutCourseInput = {
    title: string
    description: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    SyllabusContent?: SyllabusContentCreateNestedManyWithoutSyllabusInput
  }

  export type SyllabusUncheckedCreateWithoutCourseInput = {
    id?: number
    title: string
    description: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    SyllabusContent?: SyllabusContentUncheckedCreateNestedManyWithoutSyllabusInput
  }

  export type SyllabusCreateOrConnectWithoutCourseInput = {
    where: SyllabusWhereUniqueInput
    create: XOR<SyllabusCreateWithoutCourseInput, SyllabusUncheckedCreateWithoutCourseInput>
  }

  export type SyllabusCreateManyCourseInputEnvelope = {
    data: SyllabusCreateManyCourseInput | SyllabusCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CourseCreatorCreateWithoutCourseInput = {
    as: $Enums.CourseAs
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UsersCreateNestedOneWithoutCourseCreatorInput
  }

  export type CourseCreatorUncheckedCreateWithoutCourseInput = {
    id?: number
    userId: string
    as: $Enums.CourseAs
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseCreatorCreateOrConnectWithoutCourseInput = {
    where: CourseCreatorWhereUniqueInput
    create: XOR<CourseCreatorCreateWithoutCourseInput, CourseCreatorUncheckedCreateWithoutCourseInput>
  }

  export type CourseCreatorCreateManyCourseInputEnvelope = {
    data: CourseCreatorCreateManyCourseInput | CourseCreatorCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CourseLoggingUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseLoggingWhereUniqueInput
    update: XOR<CourseLoggingUpdateWithoutCourseInput, CourseLoggingUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseLoggingCreateWithoutCourseInput, CourseLoggingUncheckedCreateWithoutCourseInput>
  }

  export type CourseLoggingUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseLoggingWhereUniqueInput
    data: XOR<CourseLoggingUpdateWithoutCourseInput, CourseLoggingUncheckedUpdateWithoutCourseInput>
  }

  export type CourseLoggingUpdateManyWithWhereWithoutCourseInput = {
    where: CourseLoggingScalarWhereInput
    data: XOR<CourseLoggingUpdateManyMutationInput, CourseLoggingUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseTopicUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseTopicWhereUniqueInput
    update: XOR<CourseTopicUpdateWithoutCourseInput, CourseTopicUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseTopicCreateWithoutCourseInput, CourseTopicUncheckedCreateWithoutCourseInput>
  }

  export type CourseTopicUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseTopicWhereUniqueInput
    data: XOR<CourseTopicUpdateWithoutCourseInput, CourseTopicUncheckedUpdateWithoutCourseInput>
  }

  export type CourseTopicUpdateManyWithWhereWithoutCourseInput = {
    where: CourseTopicScalarWhereInput
    data: XOR<CourseTopicUpdateManyMutationInput, CourseTopicUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseTopicScalarWhereInput = {
    AND?: CourseTopicScalarWhereInput | CourseTopicScalarWhereInput[]
    OR?: CourseTopicScalarWhereInput[]
    NOT?: CourseTopicScalarWhereInput | CourseTopicScalarWhereInput[]
    id?: IntFilter<"CourseTopic"> | number
    courseId?: IntFilter<"CourseTopic"> | number
    topicId?: IntFilter<"CourseTopic"> | number
    createdAt?: DateTimeFilter<"CourseTopic"> | Date | string
    updatedAt?: DateTimeFilter<"CourseTopic"> | Date | string
  }

  export type SyllabusUpsertWithWhereUniqueWithoutCourseInput = {
    where: SyllabusWhereUniqueInput
    update: XOR<SyllabusUpdateWithoutCourseInput, SyllabusUncheckedUpdateWithoutCourseInput>
    create: XOR<SyllabusCreateWithoutCourseInput, SyllabusUncheckedCreateWithoutCourseInput>
  }

  export type SyllabusUpdateWithWhereUniqueWithoutCourseInput = {
    where: SyllabusWhereUniqueInput
    data: XOR<SyllabusUpdateWithoutCourseInput, SyllabusUncheckedUpdateWithoutCourseInput>
  }

  export type SyllabusUpdateManyWithWhereWithoutCourseInput = {
    where: SyllabusScalarWhereInput
    data: XOR<SyllabusUpdateManyMutationInput, SyllabusUncheckedUpdateManyWithoutCourseInput>
  }

  export type SyllabusScalarWhereInput = {
    AND?: SyllabusScalarWhereInput | SyllabusScalarWhereInput[]
    OR?: SyllabusScalarWhereInput[]
    NOT?: SyllabusScalarWhereInput | SyllabusScalarWhereInput[]
    id?: IntFilter<"Syllabus"> | number
    title?: StringFilter<"Syllabus"> | string
    description?: StringFilter<"Syllabus"> | string
    courseId?: IntFilter<"Syllabus"> | number
    isActive?: BoolFilter<"Syllabus"> | boolean
    createdAt?: DateTimeFilter<"Syllabus"> | Date | string
    updatedAt?: DateTimeFilter<"Syllabus"> | Date | string
  }

  export type CourseCreatorUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseCreatorWhereUniqueInput
    update: XOR<CourseCreatorUpdateWithoutCourseInput, CourseCreatorUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseCreatorCreateWithoutCourseInput, CourseCreatorUncheckedCreateWithoutCourseInput>
  }

  export type CourseCreatorUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseCreatorWhereUniqueInput
    data: XOR<CourseCreatorUpdateWithoutCourseInput, CourseCreatorUncheckedUpdateWithoutCourseInput>
  }

  export type CourseCreatorUpdateManyWithWhereWithoutCourseInput = {
    where: CourseCreatorScalarWhereInput
    data: XOR<CourseCreatorUpdateManyMutationInput, CourseCreatorUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseCreateWithoutCourseCreatorInput = {
    title: string
    description: string
    cover: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    price: number
    slug: string
    CourseLoggings?: CourseLoggingCreateNestedManyWithoutCourseInput
    CourseTopics?: CourseTopicCreateNestedManyWithoutCourseInput
    Syllabus?: SyllabusCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutCourseCreatorInput = {
    id?: number
    title: string
    description: string
    cover: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    price: number
    slug: string
    CourseLoggings?: CourseLoggingUncheckedCreateNestedManyWithoutCourseInput
    CourseTopics?: CourseTopicUncheckedCreateNestedManyWithoutCourseInput
    Syllabus?: SyllabusUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCourseCreatorInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCourseCreatorInput, CourseUncheckedCreateWithoutCourseCreatorInput>
  }

  export type UsersCreateWithoutCourseCreatorInput = {
    gid: string
    full_name?: string | null
    email?: string | null
    phone?: string | null
    school?: string | null
    user_type?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    CourseLogging?: CourseLoggingCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutCourseCreatorInput = {
    gid: string
    full_name?: string | null
    email?: string | null
    phone?: string | null
    school?: string | null
    user_type?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    CourseLogging?: CourseLoggingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutCourseCreatorInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutCourseCreatorInput, UsersUncheckedCreateWithoutCourseCreatorInput>
  }

  export type CourseUpsertWithoutCourseCreatorInput = {
    update: XOR<CourseUpdateWithoutCourseCreatorInput, CourseUncheckedUpdateWithoutCourseCreatorInput>
    create: XOR<CourseCreateWithoutCourseCreatorInput, CourseUncheckedCreateWithoutCourseCreatorInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutCourseCreatorInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutCourseCreatorInput, CourseUncheckedUpdateWithoutCourseCreatorInput>
  }

  export type CourseUpdateWithoutCourseCreatorInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    CourseLoggings?: CourseLoggingUpdateManyWithoutCourseNestedInput
    CourseTopics?: CourseTopicUpdateManyWithoutCourseNestedInput
    Syllabus?: SyllabusUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutCourseCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    CourseLoggings?: CourseLoggingUncheckedUpdateManyWithoutCourseNestedInput
    CourseTopics?: CourseTopicUncheckedUpdateManyWithoutCourseNestedInput
    Syllabus?: SyllabusUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type UsersUpsertWithoutCourseCreatorInput = {
    update: XOR<UsersUpdateWithoutCourseCreatorInput, UsersUncheckedUpdateWithoutCourseCreatorInput>
    create: XOR<UsersCreateWithoutCourseCreatorInput, UsersUncheckedCreateWithoutCourseCreatorInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutCourseCreatorInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutCourseCreatorInput, UsersUncheckedUpdateWithoutCourseCreatorInput>
  }

  export type UsersUpdateWithoutCourseCreatorInput = {
    gid?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    user_type?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CourseLogging?: CourseLoggingUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutCourseCreatorInput = {
    gid?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    user_type?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CourseLogging?: CourseLoggingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseCreateWithoutCourseLoggingsInput = {
    title: string
    description: string
    cover: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    price: number
    slug: string
    CourseTopics?: CourseTopicCreateNestedManyWithoutCourseInput
    Syllabus?: SyllabusCreateNestedManyWithoutCourseInput
    CourseCreator?: CourseCreatorCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutCourseLoggingsInput = {
    id?: number
    title: string
    description: string
    cover: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    price: number
    slug: string
    CourseTopics?: CourseTopicUncheckedCreateNestedManyWithoutCourseInput
    Syllabus?: SyllabusUncheckedCreateNestedManyWithoutCourseInput
    CourseCreator?: CourseCreatorUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCourseLoggingsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCourseLoggingsInput, CourseUncheckedCreateWithoutCourseLoggingsInput>
  }

  export type UsersCreateWithoutCourseLoggingInput = {
    gid: string
    full_name?: string | null
    email?: string | null
    phone?: string | null
    school?: string | null
    user_type?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    CourseCreator?: CourseCreatorCreateNestedManyWithoutUserInput
  }

  export type UsersUncheckedCreateWithoutCourseLoggingInput = {
    gid: string
    full_name?: string | null
    email?: string | null
    phone?: string | null
    school?: string | null
    user_type?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    CourseCreator?: CourseCreatorUncheckedCreateNestedManyWithoutUserInput
  }

  export type UsersCreateOrConnectWithoutCourseLoggingInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutCourseLoggingInput, UsersUncheckedCreateWithoutCourseLoggingInput>
  }

  export type SyllabusContentCreateWithoutCourseLoggingInput = {
    title: string
    type: $Enums.SyllabusContentType
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    Exams?: ExamCreateNestedManyWithoutSyllabusContentInput
    MaterialContents?: MaterialContentCreateNestedManyWithoutSyllabusContentInput
    Syllabus: SyllabusCreateNestedOneWithoutSyllabusContentInput
  }

  export type SyllabusContentUncheckedCreateWithoutCourseLoggingInput = {
    id?: number
    syllabusId: number
    title: string
    type: $Enums.SyllabusContentType
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    Exams?: ExamUncheckedCreateNestedManyWithoutSyllabusContentInput
    MaterialContents?: MaterialContentUncheckedCreateNestedManyWithoutSyllabusContentInput
  }

  export type SyllabusContentCreateOrConnectWithoutCourseLoggingInput = {
    where: SyllabusContentWhereUniqueInput
    create: XOR<SyllabusContentCreateWithoutCourseLoggingInput, SyllabusContentUncheckedCreateWithoutCourseLoggingInput>
  }

  export type MaterialContentCreateWithoutCourseLoggingInput = {
    title: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    estimatedTime: number
    Type: MaterialContentTypeCreateNestedOneWithoutMaterialContentsInput
    SyllabusContent: SyllabusContentCreateNestedOneWithoutMaterialContentsInput
    Attachments?: MaterialContentAttachmentCreateNestedManyWithoutMaterialContentInput
    File?: MaterialContentFileCreateNestedOneWithoutMaterialContentInput
    MaterialContentLearning?: MaterialContentLearningCreateNestedOneWithoutMaterialContentInput
    MaterialContentTest?: MaterialContentTestCreateNestedOneWithoutMaterialContentInput
  }

  export type MaterialContentUncheckedCreateWithoutCourseLoggingInput = {
    id?: number
    title: string
    materialContentTypeId: number
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    syllabusContentId: number
    estimatedTime: number
    Attachments?: MaterialContentAttachmentUncheckedCreateNestedManyWithoutMaterialContentInput
    File?: MaterialContentFileUncheckedCreateNestedOneWithoutMaterialContentInput
    MaterialContentLearning?: MaterialContentLearningUncheckedCreateNestedOneWithoutMaterialContentInput
    MaterialContentTest?: MaterialContentTestUncheckedCreateNestedOneWithoutMaterialContentInput
  }

  export type MaterialContentCreateOrConnectWithoutCourseLoggingInput = {
    where: MaterialContentWhereUniqueInput
    create: XOR<MaterialContentCreateWithoutCourseLoggingInput, MaterialContentUncheckedCreateWithoutCourseLoggingInput>
  }

  export type ExamCreateWithoutCourseLoggingInput = {
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    SyllabusContent: SyllabusContentCreateNestedOneWithoutExamsInput
    ExamQuestions?: ExamQuestionCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutCourseLoggingInput = {
    id?: number
    title: string
    syllabusContentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    ExamQuestions?: ExamQuestionUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutCourseLoggingInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutCourseLoggingInput, ExamUncheckedCreateWithoutCourseLoggingInput>
  }

  export type CourseUpsertWithoutCourseLoggingsInput = {
    update: XOR<CourseUpdateWithoutCourseLoggingsInput, CourseUncheckedUpdateWithoutCourseLoggingsInput>
    create: XOR<CourseCreateWithoutCourseLoggingsInput, CourseUncheckedCreateWithoutCourseLoggingsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutCourseLoggingsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutCourseLoggingsInput, CourseUncheckedUpdateWithoutCourseLoggingsInput>
  }

  export type CourseUpdateWithoutCourseLoggingsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    CourseTopics?: CourseTopicUpdateManyWithoutCourseNestedInput
    Syllabus?: SyllabusUpdateManyWithoutCourseNestedInput
    CourseCreator?: CourseCreatorUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutCourseLoggingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    CourseTopics?: CourseTopicUncheckedUpdateManyWithoutCourseNestedInput
    Syllabus?: SyllabusUncheckedUpdateManyWithoutCourseNestedInput
    CourseCreator?: CourseCreatorUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type UsersUpsertWithoutCourseLoggingInput = {
    update: XOR<UsersUpdateWithoutCourseLoggingInput, UsersUncheckedUpdateWithoutCourseLoggingInput>
    create: XOR<UsersCreateWithoutCourseLoggingInput, UsersUncheckedCreateWithoutCourseLoggingInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutCourseLoggingInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutCourseLoggingInput, UsersUncheckedUpdateWithoutCourseLoggingInput>
  }

  export type UsersUpdateWithoutCourseLoggingInput = {
    gid?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    user_type?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CourseCreator?: CourseCreatorUpdateManyWithoutUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutCourseLoggingInput = {
    gid?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    user_type?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CourseCreator?: CourseCreatorUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SyllabusContentUpsertWithoutCourseLoggingInput = {
    update: XOR<SyllabusContentUpdateWithoutCourseLoggingInput, SyllabusContentUncheckedUpdateWithoutCourseLoggingInput>
    create: XOR<SyllabusContentCreateWithoutCourseLoggingInput, SyllabusContentUncheckedCreateWithoutCourseLoggingInput>
    where?: SyllabusContentWhereInput
  }

  export type SyllabusContentUpdateToOneWithWhereWithoutCourseLoggingInput = {
    where?: SyllabusContentWhereInput
    data: XOR<SyllabusContentUpdateWithoutCourseLoggingInput, SyllabusContentUncheckedUpdateWithoutCourseLoggingInput>
  }

  export type SyllabusContentUpdateWithoutCourseLoggingInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumSyllabusContentTypeFieldUpdateOperationsInput | $Enums.SyllabusContentType
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    Exams?: ExamUpdateManyWithoutSyllabusContentNestedInput
    MaterialContents?: MaterialContentUpdateManyWithoutSyllabusContentNestedInput
    Syllabus?: SyllabusUpdateOneRequiredWithoutSyllabusContentNestedInput
  }

  export type SyllabusContentUncheckedUpdateWithoutCourseLoggingInput = {
    id?: IntFieldUpdateOperationsInput | number
    syllabusId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumSyllabusContentTypeFieldUpdateOperationsInput | $Enums.SyllabusContentType
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    Exams?: ExamUncheckedUpdateManyWithoutSyllabusContentNestedInput
    MaterialContents?: MaterialContentUncheckedUpdateManyWithoutSyllabusContentNestedInput
  }

  export type MaterialContentUpsertWithoutCourseLoggingInput = {
    update: XOR<MaterialContentUpdateWithoutCourseLoggingInput, MaterialContentUncheckedUpdateWithoutCourseLoggingInput>
    create: XOR<MaterialContentCreateWithoutCourseLoggingInput, MaterialContentUncheckedCreateWithoutCourseLoggingInput>
    where?: MaterialContentWhereInput
  }

  export type MaterialContentUpdateToOneWithWhereWithoutCourseLoggingInput = {
    where?: MaterialContentWhereInput
    data: XOR<MaterialContentUpdateWithoutCourseLoggingInput, MaterialContentUncheckedUpdateWithoutCourseLoggingInput>
  }

  export type MaterialContentUpdateWithoutCourseLoggingInput = {
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    estimatedTime?: IntFieldUpdateOperationsInput | number
    Type?: MaterialContentTypeUpdateOneRequiredWithoutMaterialContentsNestedInput
    SyllabusContent?: SyllabusContentUpdateOneRequiredWithoutMaterialContentsNestedInput
    Attachments?: MaterialContentAttachmentUpdateManyWithoutMaterialContentNestedInput
    File?: MaterialContentFileUpdateOneWithoutMaterialContentNestedInput
    MaterialContentLearning?: MaterialContentLearningUpdateOneWithoutMaterialContentNestedInput
    MaterialContentTest?: MaterialContentTestUpdateOneWithoutMaterialContentNestedInput
  }

  export type MaterialContentUncheckedUpdateWithoutCourseLoggingInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    materialContentTypeId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    syllabusContentId?: IntFieldUpdateOperationsInput | number
    estimatedTime?: IntFieldUpdateOperationsInput | number
    Attachments?: MaterialContentAttachmentUncheckedUpdateManyWithoutMaterialContentNestedInput
    File?: MaterialContentFileUncheckedUpdateOneWithoutMaterialContentNestedInput
    MaterialContentLearning?: MaterialContentLearningUncheckedUpdateOneWithoutMaterialContentNestedInput
    MaterialContentTest?: MaterialContentTestUncheckedUpdateOneWithoutMaterialContentNestedInput
  }

  export type ExamUpsertWithoutCourseLoggingInput = {
    update: XOR<ExamUpdateWithoutCourseLoggingInput, ExamUncheckedUpdateWithoutCourseLoggingInput>
    create: XOR<ExamCreateWithoutCourseLoggingInput, ExamUncheckedCreateWithoutCourseLoggingInput>
    where?: ExamWhereInput
  }

  export type ExamUpdateToOneWithWhereWithoutCourseLoggingInput = {
    where?: ExamWhereInput
    data: XOR<ExamUpdateWithoutCourseLoggingInput, ExamUncheckedUpdateWithoutCourseLoggingInput>
  }

  export type ExamUpdateWithoutCourseLoggingInput = {
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    SyllabusContent?: SyllabusContentUpdateOneRequiredWithoutExamsNestedInput
    ExamQuestions?: ExamQuestionUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutCourseLoggingInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    syllabusContentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    ExamQuestions?: ExamQuestionUncheckedUpdateManyWithoutExamNestedInput
  }

  export type SubCategoryCreateWithoutCategoryInput = {
    title: string
    isActive?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    Topics?: TopicCreateNestedManyWithoutSubCategoryInput
  }

  export type SubCategoryUncheckedCreateWithoutCategoryInput = {
    id?: number
    title: string
    isActive?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    Topics?: TopicUncheckedCreateNestedManyWithoutSubCategoryInput
  }

  export type SubCategoryCreateOrConnectWithoutCategoryInput = {
    where: SubCategoryWhereUniqueInput
    create: XOR<SubCategoryCreateWithoutCategoryInput, SubCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type SubCategoryCreateManyCategoryInputEnvelope = {
    data: SubCategoryCreateManyCategoryInput | SubCategoryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type SubCategoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: SubCategoryWhereUniqueInput
    update: XOR<SubCategoryUpdateWithoutCategoryInput, SubCategoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<SubCategoryCreateWithoutCategoryInput, SubCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type SubCategoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: SubCategoryWhereUniqueInput
    data: XOR<SubCategoryUpdateWithoutCategoryInput, SubCategoryUncheckedUpdateWithoutCategoryInput>
  }

  export type SubCategoryUpdateManyWithWhereWithoutCategoryInput = {
    where: SubCategoryScalarWhereInput
    data: XOR<SubCategoryUpdateManyMutationInput, SubCategoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type SubCategoryScalarWhereInput = {
    AND?: SubCategoryScalarWhereInput | SubCategoryScalarWhereInput[]
    OR?: SubCategoryScalarWhereInput[]
    NOT?: SubCategoryScalarWhereInput | SubCategoryScalarWhereInput[]
    id?: IntFilter<"SubCategory"> | number
    title?: StringFilter<"SubCategory"> | string
    isActive?: BoolFilter<"SubCategory"> | boolean
    categoryId?: IntFilter<"SubCategory"> | number
    order?: IntFilter<"SubCategory"> | number
    createdAt?: DateTimeFilter<"SubCategory"> | Date | string
    updatedAt?: DateTimeFilter<"SubCategory"> | Date | string
    slug?: StringFilter<"SubCategory"> | string
  }

  export type CategoryCreateWithoutSubCategoriesInput = {
    title: string
    isActive?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
  }

  export type CategoryUncheckedCreateWithoutSubCategoriesInput = {
    id?: number
    title: string
    isActive?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
  }

  export type CategoryCreateOrConnectWithoutSubCategoriesInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutSubCategoriesInput, CategoryUncheckedCreateWithoutSubCategoriesInput>
  }

  export type TopicCreateWithoutSubCategoryInput = {
    title: string
    isActive?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    CourseTopics?: CourseTopicCreateNestedManyWithoutTopicInput
  }

  export type TopicUncheckedCreateWithoutSubCategoryInput = {
    id?: number
    title: string
    isActive?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    CourseTopics?: CourseTopicUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicCreateOrConnectWithoutSubCategoryInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutSubCategoryInput, TopicUncheckedCreateWithoutSubCategoryInput>
  }

  export type TopicCreateManySubCategoryInputEnvelope = {
    data: TopicCreateManySubCategoryInput | TopicCreateManySubCategoryInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithoutSubCategoriesInput = {
    update: XOR<CategoryUpdateWithoutSubCategoriesInput, CategoryUncheckedUpdateWithoutSubCategoriesInput>
    create: XOR<CategoryCreateWithoutSubCategoriesInput, CategoryUncheckedCreateWithoutSubCategoriesInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutSubCategoriesInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutSubCategoriesInput, CategoryUncheckedUpdateWithoutSubCategoriesInput>
  }

  export type CategoryUpdateWithoutSubCategoriesInput = {
    title?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryUncheckedUpdateWithoutSubCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type TopicUpsertWithWhereUniqueWithoutSubCategoryInput = {
    where: TopicWhereUniqueInput
    update: XOR<TopicUpdateWithoutSubCategoryInput, TopicUncheckedUpdateWithoutSubCategoryInput>
    create: XOR<TopicCreateWithoutSubCategoryInput, TopicUncheckedCreateWithoutSubCategoryInput>
  }

  export type TopicUpdateWithWhereUniqueWithoutSubCategoryInput = {
    where: TopicWhereUniqueInput
    data: XOR<TopicUpdateWithoutSubCategoryInput, TopicUncheckedUpdateWithoutSubCategoryInput>
  }

  export type TopicUpdateManyWithWhereWithoutSubCategoryInput = {
    where: TopicScalarWhereInput
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyWithoutSubCategoryInput>
  }

  export type TopicScalarWhereInput = {
    AND?: TopicScalarWhereInput | TopicScalarWhereInput[]
    OR?: TopicScalarWhereInput[]
    NOT?: TopicScalarWhereInput | TopicScalarWhereInput[]
    id?: IntFilter<"Topic"> | number
    title?: StringFilter<"Topic"> | string
    isActive?: BoolFilter<"Topic"> | boolean
    subCategoryId?: IntFilter<"Topic"> | number
    order?: IntFilter<"Topic"> | number
    createdAt?: DateTimeFilter<"Topic"> | Date | string
    updatedAt?: DateTimeFilter<"Topic"> | Date | string
    slug?: StringFilter<"Topic"> | string
  }

  export type CourseTopicCreateWithoutTopicInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    Course: CourseCreateNestedOneWithoutCourseTopicsInput
  }

  export type CourseTopicUncheckedCreateWithoutTopicInput = {
    id?: number
    courseId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseTopicCreateOrConnectWithoutTopicInput = {
    where: CourseTopicWhereUniqueInput
    create: XOR<CourseTopicCreateWithoutTopicInput, CourseTopicUncheckedCreateWithoutTopicInput>
  }

  export type CourseTopicCreateManyTopicInputEnvelope = {
    data: CourseTopicCreateManyTopicInput | CourseTopicCreateManyTopicInput[]
    skipDuplicates?: boolean
  }

  export type SubCategoryCreateWithoutTopicsInput = {
    title: string
    isActive?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    Category: CategoryCreateNestedOneWithoutSubCategoriesInput
  }

  export type SubCategoryUncheckedCreateWithoutTopicsInput = {
    id?: number
    title: string
    isActive?: boolean
    categoryId: number
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
  }

  export type SubCategoryCreateOrConnectWithoutTopicsInput = {
    where: SubCategoryWhereUniqueInput
    create: XOR<SubCategoryCreateWithoutTopicsInput, SubCategoryUncheckedCreateWithoutTopicsInput>
  }

  export type CourseTopicUpsertWithWhereUniqueWithoutTopicInput = {
    where: CourseTopicWhereUniqueInput
    update: XOR<CourseTopicUpdateWithoutTopicInput, CourseTopicUncheckedUpdateWithoutTopicInput>
    create: XOR<CourseTopicCreateWithoutTopicInput, CourseTopicUncheckedCreateWithoutTopicInput>
  }

  export type CourseTopicUpdateWithWhereUniqueWithoutTopicInput = {
    where: CourseTopicWhereUniqueInput
    data: XOR<CourseTopicUpdateWithoutTopicInput, CourseTopicUncheckedUpdateWithoutTopicInput>
  }

  export type CourseTopicUpdateManyWithWhereWithoutTopicInput = {
    where: CourseTopicScalarWhereInput
    data: XOR<CourseTopicUpdateManyMutationInput, CourseTopicUncheckedUpdateManyWithoutTopicInput>
  }

  export type SubCategoryUpsertWithoutTopicsInput = {
    update: XOR<SubCategoryUpdateWithoutTopicsInput, SubCategoryUncheckedUpdateWithoutTopicsInput>
    create: XOR<SubCategoryCreateWithoutTopicsInput, SubCategoryUncheckedCreateWithoutTopicsInput>
    where?: SubCategoryWhereInput
  }

  export type SubCategoryUpdateToOneWithWhereWithoutTopicsInput = {
    where?: SubCategoryWhereInput
    data: XOR<SubCategoryUpdateWithoutTopicsInput, SubCategoryUncheckedUpdateWithoutTopicsInput>
  }

  export type SubCategoryUpdateWithoutTopicsInput = {
    title?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    Category?: CategoryUpdateOneRequiredWithoutSubCategoriesNestedInput
  }

  export type SubCategoryUncheckedUpdateWithoutTopicsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type CourseCreateWithoutCourseTopicsInput = {
    title: string
    description: string
    cover: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    price: number
    slug: string
    CourseLoggings?: CourseLoggingCreateNestedManyWithoutCourseInput
    Syllabus?: SyllabusCreateNestedManyWithoutCourseInput
    CourseCreator?: CourseCreatorCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutCourseTopicsInput = {
    id?: number
    title: string
    description: string
    cover: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    price: number
    slug: string
    CourseLoggings?: CourseLoggingUncheckedCreateNestedManyWithoutCourseInput
    Syllabus?: SyllabusUncheckedCreateNestedManyWithoutCourseInput
    CourseCreator?: CourseCreatorUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCourseTopicsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCourseTopicsInput, CourseUncheckedCreateWithoutCourseTopicsInput>
  }

  export type TopicCreateWithoutCourseTopicsInput = {
    title: string
    isActive?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    SubCategory: SubCategoryCreateNestedOneWithoutTopicsInput
  }

  export type TopicUncheckedCreateWithoutCourseTopicsInput = {
    id?: number
    title: string
    isActive?: boolean
    subCategoryId: number
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
  }

  export type TopicCreateOrConnectWithoutCourseTopicsInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutCourseTopicsInput, TopicUncheckedCreateWithoutCourseTopicsInput>
  }

  export type CourseUpsertWithoutCourseTopicsInput = {
    update: XOR<CourseUpdateWithoutCourseTopicsInput, CourseUncheckedUpdateWithoutCourseTopicsInput>
    create: XOR<CourseCreateWithoutCourseTopicsInput, CourseUncheckedCreateWithoutCourseTopicsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutCourseTopicsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutCourseTopicsInput, CourseUncheckedUpdateWithoutCourseTopicsInput>
  }

  export type CourseUpdateWithoutCourseTopicsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    CourseLoggings?: CourseLoggingUpdateManyWithoutCourseNestedInput
    Syllabus?: SyllabusUpdateManyWithoutCourseNestedInput
    CourseCreator?: CourseCreatorUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutCourseTopicsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    CourseLoggings?: CourseLoggingUncheckedUpdateManyWithoutCourseNestedInput
    Syllabus?: SyllabusUncheckedUpdateManyWithoutCourseNestedInput
    CourseCreator?: CourseCreatorUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type TopicUpsertWithoutCourseTopicsInput = {
    update: XOR<TopicUpdateWithoutCourseTopicsInput, TopicUncheckedUpdateWithoutCourseTopicsInput>
    create: XOR<TopicCreateWithoutCourseTopicsInput, TopicUncheckedCreateWithoutCourseTopicsInput>
    where?: TopicWhereInput
  }

  export type TopicUpdateToOneWithWhereWithoutCourseTopicsInput = {
    where?: TopicWhereInput
    data: XOR<TopicUpdateWithoutCourseTopicsInput, TopicUncheckedUpdateWithoutCourseTopicsInput>
  }

  export type TopicUpdateWithoutCourseTopicsInput = {
    title?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    SubCategory?: SubCategoryUpdateOneRequiredWithoutTopicsNestedInput
  }

  export type TopicUncheckedUpdateWithoutCourseTopicsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subCategoryId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type CourseCreateWithoutSyllabusInput = {
    title: string
    description: string
    cover: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    price: number
    slug: string
    CourseLoggings?: CourseLoggingCreateNestedManyWithoutCourseInput
    CourseTopics?: CourseTopicCreateNestedManyWithoutCourseInput
    CourseCreator?: CourseCreatorCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutSyllabusInput = {
    id?: number
    title: string
    description: string
    cover: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    price: number
    slug: string
    CourseLoggings?: CourseLoggingUncheckedCreateNestedManyWithoutCourseInput
    CourseTopics?: CourseTopicUncheckedCreateNestedManyWithoutCourseInput
    CourseCreator?: CourseCreatorUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutSyllabusInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutSyllabusInput, CourseUncheckedCreateWithoutSyllabusInput>
  }

  export type SyllabusContentCreateWithoutSyllabusInput = {
    title: string
    type: $Enums.SyllabusContentType
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    Exams?: ExamCreateNestedManyWithoutSyllabusContentInput
    MaterialContents?: MaterialContentCreateNestedManyWithoutSyllabusContentInput
    CourseLogging?: CourseLoggingCreateNestedManyWithoutSyllabusContentInput
  }

  export type SyllabusContentUncheckedCreateWithoutSyllabusInput = {
    id?: number
    title: string
    type: $Enums.SyllabusContentType
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    Exams?: ExamUncheckedCreateNestedManyWithoutSyllabusContentInput
    MaterialContents?: MaterialContentUncheckedCreateNestedManyWithoutSyllabusContentInput
    CourseLogging?: CourseLoggingUncheckedCreateNestedManyWithoutSyllabusContentInput
  }

  export type SyllabusContentCreateOrConnectWithoutSyllabusInput = {
    where: SyllabusContentWhereUniqueInput
    create: XOR<SyllabusContentCreateWithoutSyllabusInput, SyllabusContentUncheckedCreateWithoutSyllabusInput>
  }

  export type SyllabusContentCreateManySyllabusInputEnvelope = {
    data: SyllabusContentCreateManySyllabusInput | SyllabusContentCreateManySyllabusInput[]
    skipDuplicates?: boolean
  }

  export type CourseUpsertWithoutSyllabusInput = {
    update: XOR<CourseUpdateWithoutSyllabusInput, CourseUncheckedUpdateWithoutSyllabusInput>
    create: XOR<CourseCreateWithoutSyllabusInput, CourseUncheckedCreateWithoutSyllabusInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutSyllabusInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutSyllabusInput, CourseUncheckedUpdateWithoutSyllabusInput>
  }

  export type CourseUpdateWithoutSyllabusInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    CourseLoggings?: CourseLoggingUpdateManyWithoutCourseNestedInput
    CourseTopics?: CourseTopicUpdateManyWithoutCourseNestedInput
    CourseCreator?: CourseCreatorUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutSyllabusInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    CourseLoggings?: CourseLoggingUncheckedUpdateManyWithoutCourseNestedInput
    CourseTopics?: CourseTopicUncheckedUpdateManyWithoutCourseNestedInput
    CourseCreator?: CourseCreatorUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type SyllabusContentUpsertWithWhereUniqueWithoutSyllabusInput = {
    where: SyllabusContentWhereUniqueInput
    update: XOR<SyllabusContentUpdateWithoutSyllabusInput, SyllabusContentUncheckedUpdateWithoutSyllabusInput>
    create: XOR<SyllabusContentCreateWithoutSyllabusInput, SyllabusContentUncheckedCreateWithoutSyllabusInput>
  }

  export type SyllabusContentUpdateWithWhereUniqueWithoutSyllabusInput = {
    where: SyllabusContentWhereUniqueInput
    data: XOR<SyllabusContentUpdateWithoutSyllabusInput, SyllabusContentUncheckedUpdateWithoutSyllabusInput>
  }

  export type SyllabusContentUpdateManyWithWhereWithoutSyllabusInput = {
    where: SyllabusContentScalarWhereInput
    data: XOR<SyllabusContentUpdateManyMutationInput, SyllabusContentUncheckedUpdateManyWithoutSyllabusInput>
  }

  export type SyllabusContentScalarWhereInput = {
    AND?: SyllabusContentScalarWhereInput | SyllabusContentScalarWhereInput[]
    OR?: SyllabusContentScalarWhereInput[]
    NOT?: SyllabusContentScalarWhereInput | SyllabusContentScalarWhereInput[]
    id?: IntFilter<"SyllabusContent"> | number
    syllabusId?: IntFilter<"SyllabusContent"> | number
    title?: StringFilter<"SyllabusContent"> | string
    type?: EnumSyllabusContentTypeFilter<"SyllabusContent"> | $Enums.SyllabusContentType
    order?: IntFilter<"SyllabusContent"> | number
    createdAt?: DateTimeFilter<"SyllabusContent"> | Date | string
    updatedAt?: DateTimeFilter<"SyllabusContent"> | Date | string
    slug?: StringFilter<"SyllabusContent"> | string
  }

  export type ExamCreateWithoutSyllabusContentInput = {
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    ExamQuestions?: ExamQuestionCreateNestedManyWithoutExamInput
    CourseLogging?: CourseLoggingCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutSyllabusContentInput = {
    id?: number
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    ExamQuestions?: ExamQuestionUncheckedCreateNestedManyWithoutExamInput
    CourseLogging?: CourseLoggingUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutSyllabusContentInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutSyllabusContentInput, ExamUncheckedCreateWithoutSyllabusContentInput>
  }

  export type ExamCreateManySyllabusContentInputEnvelope = {
    data: ExamCreateManySyllabusContentInput | ExamCreateManySyllabusContentInput[]
    skipDuplicates?: boolean
  }

  export type MaterialContentCreateWithoutSyllabusContentInput = {
    title: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    estimatedTime: number
    Type: MaterialContentTypeCreateNestedOneWithoutMaterialContentsInput
    Attachments?: MaterialContentAttachmentCreateNestedManyWithoutMaterialContentInput
    File?: MaterialContentFileCreateNestedOneWithoutMaterialContentInput
    MaterialContentLearning?: MaterialContentLearningCreateNestedOneWithoutMaterialContentInput
    MaterialContentTest?: MaterialContentTestCreateNestedOneWithoutMaterialContentInput
    CourseLogging?: CourseLoggingCreateNestedManyWithoutMaterialContentInput
  }

  export type MaterialContentUncheckedCreateWithoutSyllabusContentInput = {
    id?: number
    title: string
    materialContentTypeId: number
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    estimatedTime: number
    Attachments?: MaterialContentAttachmentUncheckedCreateNestedManyWithoutMaterialContentInput
    File?: MaterialContentFileUncheckedCreateNestedOneWithoutMaterialContentInput
    MaterialContentLearning?: MaterialContentLearningUncheckedCreateNestedOneWithoutMaterialContentInput
    MaterialContentTest?: MaterialContentTestUncheckedCreateNestedOneWithoutMaterialContentInput
    CourseLogging?: CourseLoggingUncheckedCreateNestedManyWithoutMaterialContentInput
  }

  export type MaterialContentCreateOrConnectWithoutSyllabusContentInput = {
    where: MaterialContentWhereUniqueInput
    create: XOR<MaterialContentCreateWithoutSyllabusContentInput, MaterialContentUncheckedCreateWithoutSyllabusContentInput>
  }

  export type MaterialContentCreateManySyllabusContentInputEnvelope = {
    data: MaterialContentCreateManySyllabusContentInput | MaterialContentCreateManySyllabusContentInput[]
    skipDuplicates?: boolean
  }

  export type SyllabusCreateWithoutSyllabusContentInput = {
    title: string
    description: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Course: CourseCreateNestedOneWithoutSyllabusInput
  }

  export type SyllabusUncheckedCreateWithoutSyllabusContentInput = {
    id?: number
    title: string
    description: string
    courseId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SyllabusCreateOrConnectWithoutSyllabusContentInput = {
    where: SyllabusWhereUniqueInput
    create: XOR<SyllabusCreateWithoutSyllabusContentInput, SyllabusUncheckedCreateWithoutSyllabusContentInput>
  }

  export type CourseLoggingCreateWithoutSyllabusContentInput = {
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Course: CourseCreateNestedOneWithoutCourseLoggingsInput
    User: UsersCreateNestedOneWithoutCourseLoggingInput
    MaterialContent?: MaterialContentCreateNestedOneWithoutCourseLoggingInput
    Exam?: ExamCreateNestedOneWithoutCourseLoggingInput
  }

  export type CourseLoggingUncheckedCreateWithoutSyllabusContentInput = {
    id?: number
    courseId: number
    userId: string
    materialContentId?: number | null
    examId?: number | null
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseLoggingCreateOrConnectWithoutSyllabusContentInput = {
    where: CourseLoggingWhereUniqueInput
    create: XOR<CourseLoggingCreateWithoutSyllabusContentInput, CourseLoggingUncheckedCreateWithoutSyllabusContentInput>
  }

  export type CourseLoggingCreateManySyllabusContentInputEnvelope = {
    data: CourseLoggingCreateManySyllabusContentInput | CourseLoggingCreateManySyllabusContentInput[]
    skipDuplicates?: boolean
  }

  export type ExamUpsertWithWhereUniqueWithoutSyllabusContentInput = {
    where: ExamWhereUniqueInput
    update: XOR<ExamUpdateWithoutSyllabusContentInput, ExamUncheckedUpdateWithoutSyllabusContentInput>
    create: XOR<ExamCreateWithoutSyllabusContentInput, ExamUncheckedCreateWithoutSyllabusContentInput>
  }

  export type ExamUpdateWithWhereUniqueWithoutSyllabusContentInput = {
    where: ExamWhereUniqueInput
    data: XOR<ExamUpdateWithoutSyllabusContentInput, ExamUncheckedUpdateWithoutSyllabusContentInput>
  }

  export type ExamUpdateManyWithWhereWithoutSyllabusContentInput = {
    where: ExamScalarWhereInput
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyWithoutSyllabusContentInput>
  }

  export type ExamScalarWhereInput = {
    AND?: ExamScalarWhereInput | ExamScalarWhereInput[]
    OR?: ExamScalarWhereInput[]
    NOT?: ExamScalarWhereInput | ExamScalarWhereInput[]
    id?: IntFilter<"Exam"> | number
    title?: StringFilter<"Exam"> | string
    syllabusContentId?: IntFilter<"Exam"> | number
    createdAt?: DateTimeFilter<"Exam"> | Date | string
    updatedAt?: DateTimeFilter<"Exam"> | Date | string
    description?: StringFilter<"Exam"> | string
  }

  export type MaterialContentUpsertWithWhereUniqueWithoutSyllabusContentInput = {
    where: MaterialContentWhereUniqueInput
    update: XOR<MaterialContentUpdateWithoutSyllabusContentInput, MaterialContentUncheckedUpdateWithoutSyllabusContentInput>
    create: XOR<MaterialContentCreateWithoutSyllabusContentInput, MaterialContentUncheckedCreateWithoutSyllabusContentInput>
  }

  export type MaterialContentUpdateWithWhereUniqueWithoutSyllabusContentInput = {
    where: MaterialContentWhereUniqueInput
    data: XOR<MaterialContentUpdateWithoutSyllabusContentInput, MaterialContentUncheckedUpdateWithoutSyllabusContentInput>
  }

  export type MaterialContentUpdateManyWithWhereWithoutSyllabusContentInput = {
    where: MaterialContentScalarWhereInput
    data: XOR<MaterialContentUpdateManyMutationInput, MaterialContentUncheckedUpdateManyWithoutSyllabusContentInput>
  }

  export type MaterialContentScalarWhereInput = {
    AND?: MaterialContentScalarWhereInput | MaterialContentScalarWhereInput[]
    OR?: MaterialContentScalarWhereInput[]
    NOT?: MaterialContentScalarWhereInput | MaterialContentScalarWhereInput[]
    id?: IntFilter<"MaterialContent"> | number
    title?: StringFilter<"MaterialContent"> | string
    materialContentTypeId?: IntFilter<"MaterialContent"> | number
    order?: IntFilter<"MaterialContent"> | number
    createdAt?: DateTimeFilter<"MaterialContent"> | Date | string
    updatedAt?: DateTimeFilter<"MaterialContent"> | Date | string
    slug?: StringFilter<"MaterialContent"> | string
    syllabusContentId?: IntFilter<"MaterialContent"> | number
    estimatedTime?: IntFilter<"MaterialContent"> | number
  }

  export type SyllabusUpsertWithoutSyllabusContentInput = {
    update: XOR<SyllabusUpdateWithoutSyllabusContentInput, SyllabusUncheckedUpdateWithoutSyllabusContentInput>
    create: XOR<SyllabusCreateWithoutSyllabusContentInput, SyllabusUncheckedCreateWithoutSyllabusContentInput>
    where?: SyllabusWhereInput
  }

  export type SyllabusUpdateToOneWithWhereWithoutSyllabusContentInput = {
    where?: SyllabusWhereInput
    data: XOR<SyllabusUpdateWithoutSyllabusContentInput, SyllabusUncheckedUpdateWithoutSyllabusContentInput>
  }

  export type SyllabusUpdateWithoutSyllabusContentInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Course?: CourseUpdateOneRequiredWithoutSyllabusNestedInput
  }

  export type SyllabusUncheckedUpdateWithoutSyllabusContentInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    courseId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseLoggingUpsertWithWhereUniqueWithoutSyllabusContentInput = {
    where: CourseLoggingWhereUniqueInput
    update: XOR<CourseLoggingUpdateWithoutSyllabusContentInput, CourseLoggingUncheckedUpdateWithoutSyllabusContentInput>
    create: XOR<CourseLoggingCreateWithoutSyllabusContentInput, CourseLoggingUncheckedCreateWithoutSyllabusContentInput>
  }

  export type CourseLoggingUpdateWithWhereUniqueWithoutSyllabusContentInput = {
    where: CourseLoggingWhereUniqueInput
    data: XOR<CourseLoggingUpdateWithoutSyllabusContentInput, CourseLoggingUncheckedUpdateWithoutSyllabusContentInput>
  }

  export type CourseLoggingUpdateManyWithWhereWithoutSyllabusContentInput = {
    where: CourseLoggingScalarWhereInput
    data: XOR<CourseLoggingUpdateManyMutationInput, CourseLoggingUncheckedUpdateManyWithoutSyllabusContentInput>
  }

  export type SyllabusContentCreateWithoutExamsInput = {
    title: string
    type: $Enums.SyllabusContentType
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    MaterialContents?: MaterialContentCreateNestedManyWithoutSyllabusContentInput
    Syllabus: SyllabusCreateNestedOneWithoutSyllabusContentInput
    CourseLogging?: CourseLoggingCreateNestedManyWithoutSyllabusContentInput
  }

  export type SyllabusContentUncheckedCreateWithoutExamsInput = {
    id?: number
    syllabusId: number
    title: string
    type: $Enums.SyllabusContentType
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    MaterialContents?: MaterialContentUncheckedCreateNestedManyWithoutSyllabusContentInput
    CourseLogging?: CourseLoggingUncheckedCreateNestedManyWithoutSyllabusContentInput
  }

  export type SyllabusContentCreateOrConnectWithoutExamsInput = {
    where: SyllabusContentWhereUniqueInput
    create: XOR<SyllabusContentCreateWithoutExamsInput, SyllabusContentUncheckedCreateWithoutExamsInput>
  }

  export type ExamQuestionCreateWithoutExamInput = {
    isActive: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    questionText: string
    typeQuestion: $Enums.TypeQuestion
    ExamOptions?: ExamOptionQuestionCreateNestedManyWithoutExamQuestionInput
  }

  export type ExamQuestionUncheckedCreateWithoutExamInput = {
    id?: number
    isActive: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    questionText: string
    typeQuestion: $Enums.TypeQuestion
    ExamOptions?: ExamOptionQuestionUncheckedCreateNestedManyWithoutExamQuestionInput
  }

  export type ExamQuestionCreateOrConnectWithoutExamInput = {
    where: ExamQuestionWhereUniqueInput
    create: XOR<ExamQuestionCreateWithoutExamInput, ExamQuestionUncheckedCreateWithoutExamInput>
  }

  export type ExamQuestionCreateManyExamInputEnvelope = {
    data: ExamQuestionCreateManyExamInput | ExamQuestionCreateManyExamInput[]
    skipDuplicates?: boolean
  }

  export type CourseLoggingCreateWithoutExamInput = {
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Course: CourseCreateNestedOneWithoutCourseLoggingsInput
    User: UsersCreateNestedOneWithoutCourseLoggingInput
    SyllabusContent: SyllabusContentCreateNestedOneWithoutCourseLoggingInput
    MaterialContent?: MaterialContentCreateNestedOneWithoutCourseLoggingInput
  }

  export type CourseLoggingUncheckedCreateWithoutExamInput = {
    id?: number
    courseId: number
    userId: string
    syllabusContentId: number
    materialContentId?: number | null
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseLoggingCreateOrConnectWithoutExamInput = {
    where: CourseLoggingWhereUniqueInput
    create: XOR<CourseLoggingCreateWithoutExamInput, CourseLoggingUncheckedCreateWithoutExamInput>
  }

  export type CourseLoggingCreateManyExamInputEnvelope = {
    data: CourseLoggingCreateManyExamInput | CourseLoggingCreateManyExamInput[]
    skipDuplicates?: boolean
  }

  export type SyllabusContentUpsertWithoutExamsInput = {
    update: XOR<SyllabusContentUpdateWithoutExamsInput, SyllabusContentUncheckedUpdateWithoutExamsInput>
    create: XOR<SyllabusContentCreateWithoutExamsInput, SyllabusContentUncheckedCreateWithoutExamsInput>
    where?: SyllabusContentWhereInput
  }

  export type SyllabusContentUpdateToOneWithWhereWithoutExamsInput = {
    where?: SyllabusContentWhereInput
    data: XOR<SyllabusContentUpdateWithoutExamsInput, SyllabusContentUncheckedUpdateWithoutExamsInput>
  }

  export type SyllabusContentUpdateWithoutExamsInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumSyllabusContentTypeFieldUpdateOperationsInput | $Enums.SyllabusContentType
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    MaterialContents?: MaterialContentUpdateManyWithoutSyllabusContentNestedInput
    Syllabus?: SyllabusUpdateOneRequiredWithoutSyllabusContentNestedInput
    CourseLogging?: CourseLoggingUpdateManyWithoutSyllabusContentNestedInput
  }

  export type SyllabusContentUncheckedUpdateWithoutExamsInput = {
    id?: IntFieldUpdateOperationsInput | number
    syllabusId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumSyllabusContentTypeFieldUpdateOperationsInput | $Enums.SyllabusContentType
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    MaterialContents?: MaterialContentUncheckedUpdateManyWithoutSyllabusContentNestedInput
    CourseLogging?: CourseLoggingUncheckedUpdateManyWithoutSyllabusContentNestedInput
  }

  export type ExamQuestionUpsertWithWhereUniqueWithoutExamInput = {
    where: ExamQuestionWhereUniqueInput
    update: XOR<ExamQuestionUpdateWithoutExamInput, ExamQuestionUncheckedUpdateWithoutExamInput>
    create: XOR<ExamQuestionCreateWithoutExamInput, ExamQuestionUncheckedCreateWithoutExamInput>
  }

  export type ExamQuestionUpdateWithWhereUniqueWithoutExamInput = {
    where: ExamQuestionWhereUniqueInput
    data: XOR<ExamQuestionUpdateWithoutExamInput, ExamQuestionUncheckedUpdateWithoutExamInput>
  }

  export type ExamQuestionUpdateManyWithWhereWithoutExamInput = {
    where: ExamQuestionScalarWhereInput
    data: XOR<ExamQuestionUpdateManyMutationInput, ExamQuestionUncheckedUpdateManyWithoutExamInput>
  }

  export type ExamQuestionScalarWhereInput = {
    AND?: ExamQuestionScalarWhereInput | ExamQuestionScalarWhereInput[]
    OR?: ExamQuestionScalarWhereInput[]
    NOT?: ExamQuestionScalarWhereInput | ExamQuestionScalarWhereInput[]
    id?: IntFilter<"ExamQuestion"> | number
    isActive?: BoolFilter<"ExamQuestion"> | boolean
    examId?: IntFilter<"ExamQuestion"> | number
    createdAt?: DateTimeFilter<"ExamQuestion"> | Date | string
    updatedAt?: DateTimeFilter<"ExamQuestion"> | Date | string
    description?: StringNullableFilter<"ExamQuestion"> | string | null
    questionText?: StringFilter<"ExamQuestion"> | string
    typeQuestion?: EnumTypeQuestionFilter<"ExamQuestion"> | $Enums.TypeQuestion
  }

  export type CourseLoggingUpsertWithWhereUniqueWithoutExamInput = {
    where: CourseLoggingWhereUniqueInput
    update: XOR<CourseLoggingUpdateWithoutExamInput, CourseLoggingUncheckedUpdateWithoutExamInput>
    create: XOR<CourseLoggingCreateWithoutExamInput, CourseLoggingUncheckedCreateWithoutExamInput>
  }

  export type CourseLoggingUpdateWithWhereUniqueWithoutExamInput = {
    where: CourseLoggingWhereUniqueInput
    data: XOR<CourseLoggingUpdateWithoutExamInput, CourseLoggingUncheckedUpdateWithoutExamInput>
  }

  export type CourseLoggingUpdateManyWithWhereWithoutExamInput = {
    where: CourseLoggingScalarWhereInput
    data: XOR<CourseLoggingUpdateManyMutationInput, CourseLoggingUncheckedUpdateManyWithoutExamInput>
  }

  export type ExamCreateWithoutExamQuestionsInput = {
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    SyllabusContent: SyllabusContentCreateNestedOneWithoutExamsInput
    CourseLogging?: CourseLoggingCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutExamQuestionsInput = {
    id?: number
    title: string
    syllabusContentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    CourseLogging?: CourseLoggingUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutExamQuestionsInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutExamQuestionsInput, ExamUncheckedCreateWithoutExamQuestionsInput>
  }

  export type ExamOptionQuestionCreateWithoutExamQuestionInput = {
    optionText: string
    isTrue?: boolean | null
    reason?: string | null
    order?: number | null
    attachment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamOptionQuestionUncheckedCreateWithoutExamQuestionInput = {
    id?: number
    optionText: string
    isTrue?: boolean | null
    reason?: string | null
    order?: number | null
    attachment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamOptionQuestionCreateOrConnectWithoutExamQuestionInput = {
    where: ExamOptionQuestionWhereUniqueInput
    create: XOR<ExamOptionQuestionCreateWithoutExamQuestionInput, ExamOptionQuestionUncheckedCreateWithoutExamQuestionInput>
  }

  export type ExamOptionQuestionCreateManyExamQuestionInputEnvelope = {
    data: ExamOptionQuestionCreateManyExamQuestionInput | ExamOptionQuestionCreateManyExamQuestionInput[]
    skipDuplicates?: boolean
  }

  export type ExamUpsertWithoutExamQuestionsInput = {
    update: XOR<ExamUpdateWithoutExamQuestionsInput, ExamUncheckedUpdateWithoutExamQuestionsInput>
    create: XOR<ExamCreateWithoutExamQuestionsInput, ExamUncheckedCreateWithoutExamQuestionsInput>
    where?: ExamWhereInput
  }

  export type ExamUpdateToOneWithWhereWithoutExamQuestionsInput = {
    where?: ExamWhereInput
    data: XOR<ExamUpdateWithoutExamQuestionsInput, ExamUncheckedUpdateWithoutExamQuestionsInput>
  }

  export type ExamUpdateWithoutExamQuestionsInput = {
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    SyllabusContent?: SyllabusContentUpdateOneRequiredWithoutExamsNestedInput
    CourseLogging?: CourseLoggingUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutExamQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    syllabusContentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    CourseLogging?: CourseLoggingUncheckedUpdateManyWithoutExamNestedInput
  }

  export type ExamOptionQuestionUpsertWithWhereUniqueWithoutExamQuestionInput = {
    where: ExamOptionQuestionWhereUniqueInput
    update: XOR<ExamOptionQuestionUpdateWithoutExamQuestionInput, ExamOptionQuestionUncheckedUpdateWithoutExamQuestionInput>
    create: XOR<ExamOptionQuestionCreateWithoutExamQuestionInput, ExamOptionQuestionUncheckedCreateWithoutExamQuestionInput>
  }

  export type ExamOptionQuestionUpdateWithWhereUniqueWithoutExamQuestionInput = {
    where: ExamOptionQuestionWhereUniqueInput
    data: XOR<ExamOptionQuestionUpdateWithoutExamQuestionInput, ExamOptionQuestionUncheckedUpdateWithoutExamQuestionInput>
  }

  export type ExamOptionQuestionUpdateManyWithWhereWithoutExamQuestionInput = {
    where: ExamOptionQuestionScalarWhereInput
    data: XOR<ExamOptionQuestionUpdateManyMutationInput, ExamOptionQuestionUncheckedUpdateManyWithoutExamQuestionInput>
  }

  export type ExamOptionQuestionScalarWhereInput = {
    AND?: ExamOptionQuestionScalarWhereInput | ExamOptionQuestionScalarWhereInput[]
    OR?: ExamOptionQuestionScalarWhereInput[]
    NOT?: ExamOptionQuestionScalarWhereInput | ExamOptionQuestionScalarWhereInput[]
    id?: IntFilter<"ExamOptionQuestion"> | number
    optionText?: StringFilter<"ExamOptionQuestion"> | string
    isTrue?: BoolNullableFilter<"ExamOptionQuestion"> | boolean | null
    reason?: StringNullableFilter<"ExamOptionQuestion"> | string | null
    order?: IntNullableFilter<"ExamOptionQuestion"> | number | null
    attachment?: StringNullableFilter<"ExamOptionQuestion"> | string | null
    examQuestionId?: IntFilter<"ExamOptionQuestion"> | number
    createdAt?: DateTimeFilter<"ExamOptionQuestion"> | Date | string
    updatedAt?: DateTimeFilter<"ExamOptionQuestion"> | Date | string
  }

  export type ExamQuestionCreateWithoutExamOptionsInput = {
    isActive: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    questionText: string
    typeQuestion: $Enums.TypeQuestion
    Exam: ExamCreateNestedOneWithoutExamQuestionsInput
  }

  export type ExamQuestionUncheckedCreateWithoutExamOptionsInput = {
    id?: number
    isActive: boolean
    examId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    questionText: string
    typeQuestion: $Enums.TypeQuestion
  }

  export type ExamQuestionCreateOrConnectWithoutExamOptionsInput = {
    where: ExamQuestionWhereUniqueInput
    create: XOR<ExamQuestionCreateWithoutExamOptionsInput, ExamQuestionUncheckedCreateWithoutExamOptionsInput>
  }

  export type ExamQuestionUpsertWithoutExamOptionsInput = {
    update: XOR<ExamQuestionUpdateWithoutExamOptionsInput, ExamQuestionUncheckedUpdateWithoutExamOptionsInput>
    create: XOR<ExamQuestionCreateWithoutExamOptionsInput, ExamQuestionUncheckedCreateWithoutExamOptionsInput>
    where?: ExamQuestionWhereInput
  }

  export type ExamQuestionUpdateToOneWithWhereWithoutExamOptionsInput = {
    where?: ExamQuestionWhereInput
    data: XOR<ExamQuestionUpdateWithoutExamOptionsInput, ExamQuestionUncheckedUpdateWithoutExamOptionsInput>
  }

  export type ExamQuestionUpdateWithoutExamOptionsInput = {
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    questionText?: StringFieldUpdateOperationsInput | string
    typeQuestion?: EnumTypeQuestionFieldUpdateOperationsInput | $Enums.TypeQuestion
    Exam?: ExamUpdateOneRequiredWithoutExamQuestionsNestedInput
  }

  export type ExamQuestionUncheckedUpdateWithoutExamOptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    examId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    questionText?: StringFieldUpdateOperationsInput | string
    typeQuestion?: EnumTypeQuestionFieldUpdateOperationsInput | $Enums.TypeQuestion
  }

  export type MaterialContentCreateWithoutTypeInput = {
    title: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    estimatedTime: number
    SyllabusContent: SyllabusContentCreateNestedOneWithoutMaterialContentsInput
    Attachments?: MaterialContentAttachmentCreateNestedManyWithoutMaterialContentInput
    File?: MaterialContentFileCreateNestedOneWithoutMaterialContentInput
    MaterialContentLearning?: MaterialContentLearningCreateNestedOneWithoutMaterialContentInput
    MaterialContentTest?: MaterialContentTestCreateNestedOneWithoutMaterialContentInput
    CourseLogging?: CourseLoggingCreateNestedManyWithoutMaterialContentInput
  }

  export type MaterialContentUncheckedCreateWithoutTypeInput = {
    id?: number
    title: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    syllabusContentId: number
    estimatedTime: number
    Attachments?: MaterialContentAttachmentUncheckedCreateNestedManyWithoutMaterialContentInput
    File?: MaterialContentFileUncheckedCreateNestedOneWithoutMaterialContentInput
    MaterialContentLearning?: MaterialContentLearningUncheckedCreateNestedOneWithoutMaterialContentInput
    MaterialContentTest?: MaterialContentTestUncheckedCreateNestedOneWithoutMaterialContentInput
    CourseLogging?: CourseLoggingUncheckedCreateNestedManyWithoutMaterialContentInput
  }

  export type MaterialContentCreateOrConnectWithoutTypeInput = {
    where: MaterialContentWhereUniqueInput
    create: XOR<MaterialContentCreateWithoutTypeInput, MaterialContentUncheckedCreateWithoutTypeInput>
  }

  export type MaterialContentCreateManyTypeInputEnvelope = {
    data: MaterialContentCreateManyTypeInput | MaterialContentCreateManyTypeInput[]
    skipDuplicates?: boolean
  }

  export type MaterialContentUpsertWithWhereUniqueWithoutTypeInput = {
    where: MaterialContentWhereUniqueInput
    update: XOR<MaterialContentUpdateWithoutTypeInput, MaterialContentUncheckedUpdateWithoutTypeInput>
    create: XOR<MaterialContentCreateWithoutTypeInput, MaterialContentUncheckedCreateWithoutTypeInput>
  }

  export type MaterialContentUpdateWithWhereUniqueWithoutTypeInput = {
    where: MaterialContentWhereUniqueInput
    data: XOR<MaterialContentUpdateWithoutTypeInput, MaterialContentUncheckedUpdateWithoutTypeInput>
  }

  export type MaterialContentUpdateManyWithWhereWithoutTypeInput = {
    where: MaterialContentScalarWhereInput
    data: XOR<MaterialContentUpdateManyMutationInput, MaterialContentUncheckedUpdateManyWithoutTypeInput>
  }

  export type MaterialContentTypeCreateWithoutMaterialContentsInput = {
    title: $Enums.TypeMaterialContent
  }

  export type MaterialContentTypeUncheckedCreateWithoutMaterialContentsInput = {
    id?: number
    title: $Enums.TypeMaterialContent
  }

  export type MaterialContentTypeCreateOrConnectWithoutMaterialContentsInput = {
    where: MaterialContentTypeWhereUniqueInput
    create: XOR<MaterialContentTypeCreateWithoutMaterialContentsInput, MaterialContentTypeUncheckedCreateWithoutMaterialContentsInput>
  }

  export type SyllabusContentCreateWithoutMaterialContentsInput = {
    title: string
    type: $Enums.SyllabusContentType
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    Exams?: ExamCreateNestedManyWithoutSyllabusContentInput
    Syllabus: SyllabusCreateNestedOneWithoutSyllabusContentInput
    CourseLogging?: CourseLoggingCreateNestedManyWithoutSyllabusContentInput
  }

  export type SyllabusContentUncheckedCreateWithoutMaterialContentsInput = {
    id?: number
    syllabusId: number
    title: string
    type: $Enums.SyllabusContentType
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    Exams?: ExamUncheckedCreateNestedManyWithoutSyllabusContentInput
    CourseLogging?: CourseLoggingUncheckedCreateNestedManyWithoutSyllabusContentInput
  }

  export type SyllabusContentCreateOrConnectWithoutMaterialContentsInput = {
    where: SyllabusContentWhereUniqueInput
    create: XOR<SyllabusContentCreateWithoutMaterialContentsInput, SyllabusContentUncheckedCreateWithoutMaterialContentsInput>
  }

  export type MaterialContentAttachmentCreateWithoutMaterialContentInput = {
    thumbnail: string
    path: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialContentAttachmentUncheckedCreateWithoutMaterialContentInput = {
    id?: number
    thumbnail: string
    path: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialContentAttachmentCreateOrConnectWithoutMaterialContentInput = {
    where: MaterialContentAttachmentWhereUniqueInput
    create: XOR<MaterialContentAttachmentCreateWithoutMaterialContentInput, MaterialContentAttachmentUncheckedCreateWithoutMaterialContentInput>
  }

  export type MaterialContentAttachmentCreateManyMaterialContentInputEnvelope = {
    data: MaterialContentAttachmentCreateManyMaterialContentInput | MaterialContentAttachmentCreateManyMaterialContentInput[]
    skipDuplicates?: boolean
  }

  export type MaterialContentFileCreateWithoutMaterialContentInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialContentFileUncheckedCreateWithoutMaterialContentInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialContentFileCreateOrConnectWithoutMaterialContentInput = {
    where: MaterialContentFileWhereUniqueInput
    create: XOR<MaterialContentFileCreateWithoutMaterialContentInput, MaterialContentFileUncheckedCreateWithoutMaterialContentInput>
  }

  export type MaterialContentLearningCreateWithoutMaterialContentInput = {
    content: string
  }

  export type MaterialContentLearningUncheckedCreateWithoutMaterialContentInput = {
    id?: number
    content: string
  }

  export type MaterialContentLearningCreateOrConnectWithoutMaterialContentInput = {
    where: MaterialContentLearningWhereUniqueInput
    create: XOR<MaterialContentLearningCreateWithoutMaterialContentInput, MaterialContentLearningUncheckedCreateWithoutMaterialContentInput>
  }

  export type MaterialContentTestCreateWithoutMaterialContentInput = {

  }

  export type MaterialContentTestUncheckedCreateWithoutMaterialContentInput = {
    id?: number
  }

  export type MaterialContentTestCreateOrConnectWithoutMaterialContentInput = {
    where: MaterialContentTestWhereUniqueInput
    create: XOR<MaterialContentTestCreateWithoutMaterialContentInput, MaterialContentTestUncheckedCreateWithoutMaterialContentInput>
  }

  export type CourseLoggingCreateWithoutMaterialContentInput = {
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Course: CourseCreateNestedOneWithoutCourseLoggingsInput
    User: UsersCreateNestedOneWithoutCourseLoggingInput
    SyllabusContent: SyllabusContentCreateNestedOneWithoutCourseLoggingInput
    Exam?: ExamCreateNestedOneWithoutCourseLoggingInput
  }

  export type CourseLoggingUncheckedCreateWithoutMaterialContentInput = {
    id?: number
    courseId: number
    userId: string
    syllabusContentId: number
    examId?: number | null
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseLoggingCreateOrConnectWithoutMaterialContentInput = {
    where: CourseLoggingWhereUniqueInput
    create: XOR<CourseLoggingCreateWithoutMaterialContentInput, CourseLoggingUncheckedCreateWithoutMaterialContentInput>
  }

  export type CourseLoggingCreateManyMaterialContentInputEnvelope = {
    data: CourseLoggingCreateManyMaterialContentInput | CourseLoggingCreateManyMaterialContentInput[]
    skipDuplicates?: boolean
  }

  export type MaterialContentTypeUpsertWithoutMaterialContentsInput = {
    update: XOR<MaterialContentTypeUpdateWithoutMaterialContentsInput, MaterialContentTypeUncheckedUpdateWithoutMaterialContentsInput>
    create: XOR<MaterialContentTypeCreateWithoutMaterialContentsInput, MaterialContentTypeUncheckedCreateWithoutMaterialContentsInput>
    where?: MaterialContentTypeWhereInput
  }

  export type MaterialContentTypeUpdateToOneWithWhereWithoutMaterialContentsInput = {
    where?: MaterialContentTypeWhereInput
    data: XOR<MaterialContentTypeUpdateWithoutMaterialContentsInput, MaterialContentTypeUncheckedUpdateWithoutMaterialContentsInput>
  }

  export type MaterialContentTypeUpdateWithoutMaterialContentsInput = {
    title?: EnumTypeMaterialContentFieldUpdateOperationsInput | $Enums.TypeMaterialContent
  }

  export type MaterialContentTypeUncheckedUpdateWithoutMaterialContentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: EnumTypeMaterialContentFieldUpdateOperationsInput | $Enums.TypeMaterialContent
  }

  export type SyllabusContentUpsertWithoutMaterialContentsInput = {
    update: XOR<SyllabusContentUpdateWithoutMaterialContentsInput, SyllabusContentUncheckedUpdateWithoutMaterialContentsInput>
    create: XOR<SyllabusContentCreateWithoutMaterialContentsInput, SyllabusContentUncheckedCreateWithoutMaterialContentsInput>
    where?: SyllabusContentWhereInput
  }

  export type SyllabusContentUpdateToOneWithWhereWithoutMaterialContentsInput = {
    where?: SyllabusContentWhereInput
    data: XOR<SyllabusContentUpdateWithoutMaterialContentsInput, SyllabusContentUncheckedUpdateWithoutMaterialContentsInput>
  }

  export type SyllabusContentUpdateWithoutMaterialContentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumSyllabusContentTypeFieldUpdateOperationsInput | $Enums.SyllabusContentType
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    Exams?: ExamUpdateManyWithoutSyllabusContentNestedInput
    Syllabus?: SyllabusUpdateOneRequiredWithoutSyllabusContentNestedInput
    CourseLogging?: CourseLoggingUpdateManyWithoutSyllabusContentNestedInput
  }

  export type SyllabusContentUncheckedUpdateWithoutMaterialContentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    syllabusId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumSyllabusContentTypeFieldUpdateOperationsInput | $Enums.SyllabusContentType
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    Exams?: ExamUncheckedUpdateManyWithoutSyllabusContentNestedInput
    CourseLogging?: CourseLoggingUncheckedUpdateManyWithoutSyllabusContentNestedInput
  }

  export type MaterialContentAttachmentUpsertWithWhereUniqueWithoutMaterialContentInput = {
    where: MaterialContentAttachmentWhereUniqueInput
    update: XOR<MaterialContentAttachmentUpdateWithoutMaterialContentInput, MaterialContentAttachmentUncheckedUpdateWithoutMaterialContentInput>
    create: XOR<MaterialContentAttachmentCreateWithoutMaterialContentInput, MaterialContentAttachmentUncheckedCreateWithoutMaterialContentInput>
  }

  export type MaterialContentAttachmentUpdateWithWhereUniqueWithoutMaterialContentInput = {
    where: MaterialContentAttachmentWhereUniqueInput
    data: XOR<MaterialContentAttachmentUpdateWithoutMaterialContentInput, MaterialContentAttachmentUncheckedUpdateWithoutMaterialContentInput>
  }

  export type MaterialContentAttachmentUpdateManyWithWhereWithoutMaterialContentInput = {
    where: MaterialContentAttachmentScalarWhereInput
    data: XOR<MaterialContentAttachmentUpdateManyMutationInput, MaterialContentAttachmentUncheckedUpdateManyWithoutMaterialContentInput>
  }

  export type MaterialContentAttachmentScalarWhereInput = {
    AND?: MaterialContentAttachmentScalarWhereInput | MaterialContentAttachmentScalarWhereInput[]
    OR?: MaterialContentAttachmentScalarWhereInput[]
    NOT?: MaterialContentAttachmentScalarWhereInput | MaterialContentAttachmentScalarWhereInput[]
    id?: IntFilter<"MaterialContentAttachment"> | number
    thumbnail?: StringFilter<"MaterialContentAttachment"> | string
    path?: StringFilter<"MaterialContentAttachment"> | string
    materialContentId?: IntFilter<"MaterialContentAttachment"> | number
    createdAt?: DateTimeFilter<"MaterialContentAttachment"> | Date | string
    updatedAt?: DateTimeFilter<"MaterialContentAttachment"> | Date | string
  }

  export type MaterialContentFileUpsertWithoutMaterialContentInput = {
    update: XOR<MaterialContentFileUpdateWithoutMaterialContentInput, MaterialContentFileUncheckedUpdateWithoutMaterialContentInput>
    create: XOR<MaterialContentFileCreateWithoutMaterialContentInput, MaterialContentFileUncheckedCreateWithoutMaterialContentInput>
    where?: MaterialContentFileWhereInput
  }

  export type MaterialContentFileUpdateToOneWithWhereWithoutMaterialContentInput = {
    where?: MaterialContentFileWhereInput
    data: XOR<MaterialContentFileUpdateWithoutMaterialContentInput, MaterialContentFileUncheckedUpdateWithoutMaterialContentInput>
  }

  export type MaterialContentFileUpdateWithoutMaterialContentInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialContentFileUncheckedUpdateWithoutMaterialContentInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialContentLearningUpsertWithoutMaterialContentInput = {
    update: XOR<MaterialContentLearningUpdateWithoutMaterialContentInput, MaterialContentLearningUncheckedUpdateWithoutMaterialContentInput>
    create: XOR<MaterialContentLearningCreateWithoutMaterialContentInput, MaterialContentLearningUncheckedCreateWithoutMaterialContentInput>
    where?: MaterialContentLearningWhereInput
  }

  export type MaterialContentLearningUpdateToOneWithWhereWithoutMaterialContentInput = {
    where?: MaterialContentLearningWhereInput
    data: XOR<MaterialContentLearningUpdateWithoutMaterialContentInput, MaterialContentLearningUncheckedUpdateWithoutMaterialContentInput>
  }

  export type MaterialContentLearningUpdateWithoutMaterialContentInput = {
    content?: StringFieldUpdateOperationsInput | string
  }

  export type MaterialContentLearningUncheckedUpdateWithoutMaterialContentInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
  }

  export type MaterialContentTestUpsertWithoutMaterialContentInput = {
    update: XOR<MaterialContentTestUpdateWithoutMaterialContentInput, MaterialContentTestUncheckedUpdateWithoutMaterialContentInput>
    create: XOR<MaterialContentTestCreateWithoutMaterialContentInput, MaterialContentTestUncheckedCreateWithoutMaterialContentInput>
    where?: MaterialContentTestWhereInput
  }

  export type MaterialContentTestUpdateToOneWithWhereWithoutMaterialContentInput = {
    where?: MaterialContentTestWhereInput
    data: XOR<MaterialContentTestUpdateWithoutMaterialContentInput, MaterialContentTestUncheckedUpdateWithoutMaterialContentInput>
  }

  export type MaterialContentTestUpdateWithoutMaterialContentInput = {

  }

  export type MaterialContentTestUncheckedUpdateWithoutMaterialContentInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type CourseLoggingUpsertWithWhereUniqueWithoutMaterialContentInput = {
    where: CourseLoggingWhereUniqueInput
    update: XOR<CourseLoggingUpdateWithoutMaterialContentInput, CourseLoggingUncheckedUpdateWithoutMaterialContentInput>
    create: XOR<CourseLoggingCreateWithoutMaterialContentInput, CourseLoggingUncheckedCreateWithoutMaterialContentInput>
  }

  export type CourseLoggingUpdateWithWhereUniqueWithoutMaterialContentInput = {
    where: CourseLoggingWhereUniqueInput
    data: XOR<CourseLoggingUpdateWithoutMaterialContentInput, CourseLoggingUncheckedUpdateWithoutMaterialContentInput>
  }

  export type CourseLoggingUpdateManyWithWhereWithoutMaterialContentInput = {
    where: CourseLoggingScalarWhereInput
    data: XOR<CourseLoggingUpdateManyMutationInput, CourseLoggingUncheckedUpdateManyWithoutMaterialContentInput>
  }

  export type MaterialContentCreateWithoutMaterialContentLearningInput = {
    title: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    estimatedTime: number
    Type: MaterialContentTypeCreateNestedOneWithoutMaterialContentsInput
    SyllabusContent: SyllabusContentCreateNestedOneWithoutMaterialContentsInput
    Attachments?: MaterialContentAttachmentCreateNestedManyWithoutMaterialContentInput
    File?: MaterialContentFileCreateNestedOneWithoutMaterialContentInput
    MaterialContentTest?: MaterialContentTestCreateNestedOneWithoutMaterialContentInput
    CourseLogging?: CourseLoggingCreateNestedManyWithoutMaterialContentInput
  }

  export type MaterialContentUncheckedCreateWithoutMaterialContentLearningInput = {
    id?: number
    title: string
    materialContentTypeId: number
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    syllabusContentId: number
    estimatedTime: number
    Attachments?: MaterialContentAttachmentUncheckedCreateNestedManyWithoutMaterialContentInput
    File?: MaterialContentFileUncheckedCreateNestedOneWithoutMaterialContentInput
    MaterialContentTest?: MaterialContentTestUncheckedCreateNestedOneWithoutMaterialContentInput
    CourseLogging?: CourseLoggingUncheckedCreateNestedManyWithoutMaterialContentInput
  }

  export type MaterialContentCreateOrConnectWithoutMaterialContentLearningInput = {
    where: MaterialContentWhereUniqueInput
    create: XOR<MaterialContentCreateWithoutMaterialContentLearningInput, MaterialContentUncheckedCreateWithoutMaterialContentLearningInput>
  }

  export type MaterialContentUpsertWithoutMaterialContentLearningInput = {
    update: XOR<MaterialContentUpdateWithoutMaterialContentLearningInput, MaterialContentUncheckedUpdateWithoutMaterialContentLearningInput>
    create: XOR<MaterialContentCreateWithoutMaterialContentLearningInput, MaterialContentUncheckedCreateWithoutMaterialContentLearningInput>
    where?: MaterialContentWhereInput
  }

  export type MaterialContentUpdateToOneWithWhereWithoutMaterialContentLearningInput = {
    where?: MaterialContentWhereInput
    data: XOR<MaterialContentUpdateWithoutMaterialContentLearningInput, MaterialContentUncheckedUpdateWithoutMaterialContentLearningInput>
  }

  export type MaterialContentUpdateWithoutMaterialContentLearningInput = {
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    estimatedTime?: IntFieldUpdateOperationsInput | number
    Type?: MaterialContentTypeUpdateOneRequiredWithoutMaterialContentsNestedInput
    SyllabusContent?: SyllabusContentUpdateOneRequiredWithoutMaterialContentsNestedInput
    Attachments?: MaterialContentAttachmentUpdateManyWithoutMaterialContentNestedInput
    File?: MaterialContentFileUpdateOneWithoutMaterialContentNestedInput
    MaterialContentTest?: MaterialContentTestUpdateOneWithoutMaterialContentNestedInput
    CourseLogging?: CourseLoggingUpdateManyWithoutMaterialContentNestedInput
  }

  export type MaterialContentUncheckedUpdateWithoutMaterialContentLearningInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    materialContentTypeId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    syllabusContentId?: IntFieldUpdateOperationsInput | number
    estimatedTime?: IntFieldUpdateOperationsInput | number
    Attachments?: MaterialContentAttachmentUncheckedUpdateManyWithoutMaterialContentNestedInput
    File?: MaterialContentFileUncheckedUpdateOneWithoutMaterialContentNestedInput
    MaterialContentTest?: MaterialContentTestUncheckedUpdateOneWithoutMaterialContentNestedInput
    CourseLogging?: CourseLoggingUncheckedUpdateManyWithoutMaterialContentNestedInput
  }

  export type MaterialContentCreateWithoutMaterialContentTestInput = {
    title: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    estimatedTime: number
    Type: MaterialContentTypeCreateNestedOneWithoutMaterialContentsInput
    SyllabusContent: SyllabusContentCreateNestedOneWithoutMaterialContentsInput
    Attachments?: MaterialContentAttachmentCreateNestedManyWithoutMaterialContentInput
    File?: MaterialContentFileCreateNestedOneWithoutMaterialContentInput
    MaterialContentLearning?: MaterialContentLearningCreateNestedOneWithoutMaterialContentInput
    CourseLogging?: CourseLoggingCreateNestedManyWithoutMaterialContentInput
  }

  export type MaterialContentUncheckedCreateWithoutMaterialContentTestInput = {
    id?: number
    title: string
    materialContentTypeId: number
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    syllabusContentId: number
    estimatedTime: number
    Attachments?: MaterialContentAttachmentUncheckedCreateNestedManyWithoutMaterialContentInput
    File?: MaterialContentFileUncheckedCreateNestedOneWithoutMaterialContentInput
    MaterialContentLearning?: MaterialContentLearningUncheckedCreateNestedOneWithoutMaterialContentInput
    CourseLogging?: CourseLoggingUncheckedCreateNestedManyWithoutMaterialContentInput
  }

  export type MaterialContentCreateOrConnectWithoutMaterialContentTestInput = {
    where: MaterialContentWhereUniqueInput
    create: XOR<MaterialContentCreateWithoutMaterialContentTestInput, MaterialContentUncheckedCreateWithoutMaterialContentTestInput>
  }

  export type MaterialContentUpsertWithoutMaterialContentTestInput = {
    update: XOR<MaterialContentUpdateWithoutMaterialContentTestInput, MaterialContentUncheckedUpdateWithoutMaterialContentTestInput>
    create: XOR<MaterialContentCreateWithoutMaterialContentTestInput, MaterialContentUncheckedCreateWithoutMaterialContentTestInput>
    where?: MaterialContentWhereInput
  }

  export type MaterialContentUpdateToOneWithWhereWithoutMaterialContentTestInput = {
    where?: MaterialContentWhereInput
    data: XOR<MaterialContentUpdateWithoutMaterialContentTestInput, MaterialContentUncheckedUpdateWithoutMaterialContentTestInput>
  }

  export type MaterialContentUpdateWithoutMaterialContentTestInput = {
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    estimatedTime?: IntFieldUpdateOperationsInput | number
    Type?: MaterialContentTypeUpdateOneRequiredWithoutMaterialContentsNestedInput
    SyllabusContent?: SyllabusContentUpdateOneRequiredWithoutMaterialContentsNestedInput
    Attachments?: MaterialContentAttachmentUpdateManyWithoutMaterialContentNestedInput
    File?: MaterialContentFileUpdateOneWithoutMaterialContentNestedInput
    MaterialContentLearning?: MaterialContentLearningUpdateOneWithoutMaterialContentNestedInput
    CourseLogging?: CourseLoggingUpdateManyWithoutMaterialContentNestedInput
  }

  export type MaterialContentUncheckedUpdateWithoutMaterialContentTestInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    materialContentTypeId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    syllabusContentId?: IntFieldUpdateOperationsInput | number
    estimatedTime?: IntFieldUpdateOperationsInput | number
    Attachments?: MaterialContentAttachmentUncheckedUpdateManyWithoutMaterialContentNestedInput
    File?: MaterialContentFileUncheckedUpdateOneWithoutMaterialContentNestedInput
    MaterialContentLearning?: MaterialContentLearningUncheckedUpdateOneWithoutMaterialContentNestedInput
    CourseLogging?: CourseLoggingUncheckedUpdateManyWithoutMaterialContentNestedInput
  }

  export type MaterialContentCreateWithoutFileInput = {
    title: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    estimatedTime: number
    Type: MaterialContentTypeCreateNestedOneWithoutMaterialContentsInput
    SyllabusContent: SyllabusContentCreateNestedOneWithoutMaterialContentsInput
    Attachments?: MaterialContentAttachmentCreateNestedManyWithoutMaterialContentInput
    MaterialContentLearning?: MaterialContentLearningCreateNestedOneWithoutMaterialContentInput
    MaterialContentTest?: MaterialContentTestCreateNestedOneWithoutMaterialContentInput
    CourseLogging?: CourseLoggingCreateNestedManyWithoutMaterialContentInput
  }

  export type MaterialContentUncheckedCreateWithoutFileInput = {
    id?: number
    title: string
    materialContentTypeId: number
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    syllabusContentId: number
    estimatedTime: number
    Attachments?: MaterialContentAttachmentUncheckedCreateNestedManyWithoutMaterialContentInput
    MaterialContentLearning?: MaterialContentLearningUncheckedCreateNestedOneWithoutMaterialContentInput
    MaterialContentTest?: MaterialContentTestUncheckedCreateNestedOneWithoutMaterialContentInput
    CourseLogging?: CourseLoggingUncheckedCreateNestedManyWithoutMaterialContentInput
  }

  export type MaterialContentCreateOrConnectWithoutFileInput = {
    where: MaterialContentWhereUniqueInput
    create: XOR<MaterialContentCreateWithoutFileInput, MaterialContentUncheckedCreateWithoutFileInput>
  }

  export type MaterialContentUpsertWithoutFileInput = {
    update: XOR<MaterialContentUpdateWithoutFileInput, MaterialContentUncheckedUpdateWithoutFileInput>
    create: XOR<MaterialContentCreateWithoutFileInput, MaterialContentUncheckedCreateWithoutFileInput>
    where?: MaterialContentWhereInput
  }

  export type MaterialContentUpdateToOneWithWhereWithoutFileInput = {
    where?: MaterialContentWhereInput
    data: XOR<MaterialContentUpdateWithoutFileInput, MaterialContentUncheckedUpdateWithoutFileInput>
  }

  export type MaterialContentUpdateWithoutFileInput = {
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    estimatedTime?: IntFieldUpdateOperationsInput | number
    Type?: MaterialContentTypeUpdateOneRequiredWithoutMaterialContentsNestedInput
    SyllabusContent?: SyllabusContentUpdateOneRequiredWithoutMaterialContentsNestedInput
    Attachments?: MaterialContentAttachmentUpdateManyWithoutMaterialContentNestedInput
    MaterialContentLearning?: MaterialContentLearningUpdateOneWithoutMaterialContentNestedInput
    MaterialContentTest?: MaterialContentTestUpdateOneWithoutMaterialContentNestedInput
    CourseLogging?: CourseLoggingUpdateManyWithoutMaterialContentNestedInput
  }

  export type MaterialContentUncheckedUpdateWithoutFileInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    materialContentTypeId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    syllabusContentId?: IntFieldUpdateOperationsInput | number
    estimatedTime?: IntFieldUpdateOperationsInput | number
    Attachments?: MaterialContentAttachmentUncheckedUpdateManyWithoutMaterialContentNestedInput
    MaterialContentLearning?: MaterialContentLearningUncheckedUpdateOneWithoutMaterialContentNestedInput
    MaterialContentTest?: MaterialContentTestUncheckedUpdateOneWithoutMaterialContentNestedInput
    CourseLogging?: CourseLoggingUncheckedUpdateManyWithoutMaterialContentNestedInput
  }

  export type MaterialContentCreateWithoutAttachmentsInput = {
    title: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    estimatedTime: number
    Type: MaterialContentTypeCreateNestedOneWithoutMaterialContentsInput
    SyllabusContent: SyllabusContentCreateNestedOneWithoutMaterialContentsInput
    File?: MaterialContentFileCreateNestedOneWithoutMaterialContentInput
    MaterialContentLearning?: MaterialContentLearningCreateNestedOneWithoutMaterialContentInput
    MaterialContentTest?: MaterialContentTestCreateNestedOneWithoutMaterialContentInput
    CourseLogging?: CourseLoggingCreateNestedManyWithoutMaterialContentInput
  }

  export type MaterialContentUncheckedCreateWithoutAttachmentsInput = {
    id?: number
    title: string
    materialContentTypeId: number
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    syllabusContentId: number
    estimatedTime: number
    File?: MaterialContentFileUncheckedCreateNestedOneWithoutMaterialContentInput
    MaterialContentLearning?: MaterialContentLearningUncheckedCreateNestedOneWithoutMaterialContentInput
    MaterialContentTest?: MaterialContentTestUncheckedCreateNestedOneWithoutMaterialContentInput
    CourseLogging?: CourseLoggingUncheckedCreateNestedManyWithoutMaterialContentInput
  }

  export type MaterialContentCreateOrConnectWithoutAttachmentsInput = {
    where: MaterialContentWhereUniqueInput
    create: XOR<MaterialContentCreateWithoutAttachmentsInput, MaterialContentUncheckedCreateWithoutAttachmentsInput>
  }

  export type MaterialContentUpsertWithoutAttachmentsInput = {
    update: XOR<MaterialContentUpdateWithoutAttachmentsInput, MaterialContentUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<MaterialContentCreateWithoutAttachmentsInput, MaterialContentUncheckedCreateWithoutAttachmentsInput>
    where?: MaterialContentWhereInput
  }

  export type MaterialContentUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: MaterialContentWhereInput
    data: XOR<MaterialContentUpdateWithoutAttachmentsInput, MaterialContentUncheckedUpdateWithoutAttachmentsInput>
  }

  export type MaterialContentUpdateWithoutAttachmentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    estimatedTime?: IntFieldUpdateOperationsInput | number
    Type?: MaterialContentTypeUpdateOneRequiredWithoutMaterialContentsNestedInput
    SyllabusContent?: SyllabusContentUpdateOneRequiredWithoutMaterialContentsNestedInput
    File?: MaterialContentFileUpdateOneWithoutMaterialContentNestedInput
    MaterialContentLearning?: MaterialContentLearningUpdateOneWithoutMaterialContentNestedInput
    MaterialContentTest?: MaterialContentTestUpdateOneWithoutMaterialContentNestedInput
    CourseLogging?: CourseLoggingUpdateManyWithoutMaterialContentNestedInput
  }

  export type MaterialContentUncheckedUpdateWithoutAttachmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    materialContentTypeId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    syllabusContentId?: IntFieldUpdateOperationsInput | number
    estimatedTime?: IntFieldUpdateOperationsInput | number
    File?: MaterialContentFileUncheckedUpdateOneWithoutMaterialContentNestedInput
    MaterialContentLearning?: MaterialContentLearningUncheckedUpdateOneWithoutMaterialContentNestedInput
    MaterialContentTest?: MaterialContentTestUncheckedUpdateOneWithoutMaterialContentNestedInput
    CourseLogging?: CourseLoggingUncheckedUpdateManyWithoutMaterialContentNestedInput
  }

  export type CourseCreatorCreateManyUserInput = {
    id?: number
    courseId: number
    as: $Enums.CourseAs
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseLoggingCreateManyUserInput = {
    id?: number
    courseId: number
    syllabusContentId: number
    materialContentId?: number | null
    examId?: number | null
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseCreatorUpdateWithoutUserInput = {
    as?: EnumCourseAsFieldUpdateOperationsInput | $Enums.CourseAs
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Course?: CourseUpdateOneRequiredWithoutCourseCreatorNestedInput
  }

  export type CourseCreatorUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    as?: EnumCourseAsFieldUpdateOperationsInput | $Enums.CourseAs
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseCreatorUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    as?: EnumCourseAsFieldUpdateOperationsInput | $Enums.CourseAs
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseLoggingUpdateWithoutUserInput = {
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Course?: CourseUpdateOneRequiredWithoutCourseLoggingsNestedInput
    SyllabusContent?: SyllabusContentUpdateOneRequiredWithoutCourseLoggingNestedInput
    MaterialContent?: MaterialContentUpdateOneWithoutCourseLoggingNestedInput
    Exam?: ExamUpdateOneWithoutCourseLoggingNestedInput
  }

  export type CourseLoggingUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    syllabusContentId?: IntFieldUpdateOperationsInput | number
    materialContentId?: NullableIntFieldUpdateOperationsInput | number | null
    examId?: NullableIntFieldUpdateOperationsInput | number | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseLoggingUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    syllabusContentId?: IntFieldUpdateOperationsInput | number
    materialContentId?: NullableIntFieldUpdateOperationsInput | number | null
    examId?: NullableIntFieldUpdateOperationsInput | number | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseLoggingCreateManyCourseInput = {
    id?: number
    userId: string
    syllabusContentId: number
    materialContentId?: number | null
    examId?: number | null
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseTopicCreateManyCourseInput = {
    id?: number
    topicId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SyllabusCreateManyCourseInput = {
    id?: number
    title: string
    description: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseCreatorCreateManyCourseInput = {
    id?: number
    userId: string
    as: $Enums.CourseAs
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseLoggingUpdateWithoutCourseInput = {
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UsersUpdateOneRequiredWithoutCourseLoggingNestedInput
    SyllabusContent?: SyllabusContentUpdateOneRequiredWithoutCourseLoggingNestedInput
    MaterialContent?: MaterialContentUpdateOneWithoutCourseLoggingNestedInput
    Exam?: ExamUpdateOneWithoutCourseLoggingNestedInput
  }

  export type CourseLoggingUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    syllabusContentId?: IntFieldUpdateOperationsInput | number
    materialContentId?: NullableIntFieldUpdateOperationsInput | number | null
    examId?: NullableIntFieldUpdateOperationsInput | number | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseLoggingUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    syllabusContentId?: IntFieldUpdateOperationsInput | number
    materialContentId?: NullableIntFieldUpdateOperationsInput | number | null
    examId?: NullableIntFieldUpdateOperationsInput | number | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseTopicUpdateWithoutCourseInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Topic?: TopicUpdateOneRequiredWithoutCourseTopicsNestedInput
  }

  export type CourseTopicUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    topicId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseTopicUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    topicId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyllabusUpdateWithoutCourseInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SyllabusContent?: SyllabusContentUpdateManyWithoutSyllabusNestedInput
  }

  export type SyllabusUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SyllabusContent?: SyllabusContentUncheckedUpdateManyWithoutSyllabusNestedInput
  }

  export type SyllabusUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseCreatorUpdateWithoutCourseInput = {
    as?: EnumCourseAsFieldUpdateOperationsInput | $Enums.CourseAs
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UsersUpdateOneRequiredWithoutCourseCreatorNestedInput
  }

  export type CourseCreatorUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    as?: EnumCourseAsFieldUpdateOperationsInput | $Enums.CourseAs
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseCreatorUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    as?: EnumCourseAsFieldUpdateOperationsInput | $Enums.CourseAs
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubCategoryCreateManyCategoryInput = {
    id?: number
    title: string
    isActive?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
  }

  export type SubCategoryUpdateWithoutCategoryInput = {
    title?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    Topics?: TopicUpdateManyWithoutSubCategoryNestedInput
  }

  export type SubCategoryUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    Topics?: TopicUncheckedUpdateManyWithoutSubCategoryNestedInput
  }

  export type SubCategoryUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type TopicCreateManySubCategoryInput = {
    id?: number
    title: string
    isActive?: boolean
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
  }

  export type TopicUpdateWithoutSubCategoryInput = {
    title?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    CourseTopics?: CourseTopicUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateWithoutSubCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    CourseTopics?: CourseTopicUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateManyWithoutSubCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type CourseTopicCreateManyTopicInput = {
    id?: number
    courseId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseTopicUpdateWithoutTopicInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Course?: CourseUpdateOneRequiredWithoutCourseTopicsNestedInput
  }

  export type CourseTopicUncheckedUpdateWithoutTopicInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseTopicUncheckedUpdateManyWithoutTopicInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyllabusContentCreateManySyllabusInput = {
    id?: number
    title: string
    type: $Enums.SyllabusContentType
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
  }

  export type SyllabusContentUpdateWithoutSyllabusInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumSyllabusContentTypeFieldUpdateOperationsInput | $Enums.SyllabusContentType
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    Exams?: ExamUpdateManyWithoutSyllabusContentNestedInput
    MaterialContents?: MaterialContentUpdateManyWithoutSyllabusContentNestedInput
    CourseLogging?: CourseLoggingUpdateManyWithoutSyllabusContentNestedInput
  }

  export type SyllabusContentUncheckedUpdateWithoutSyllabusInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumSyllabusContentTypeFieldUpdateOperationsInput | $Enums.SyllabusContentType
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    Exams?: ExamUncheckedUpdateManyWithoutSyllabusContentNestedInput
    MaterialContents?: MaterialContentUncheckedUpdateManyWithoutSyllabusContentNestedInput
    CourseLogging?: CourseLoggingUncheckedUpdateManyWithoutSyllabusContentNestedInput
  }

  export type SyllabusContentUncheckedUpdateManyWithoutSyllabusInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumSyllabusContentTypeFieldUpdateOperationsInput | $Enums.SyllabusContentType
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type ExamCreateManySyllabusContentInput = {
    id?: number
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
  }

  export type MaterialContentCreateManySyllabusContentInput = {
    id?: number
    title: string
    materialContentTypeId: number
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    estimatedTime: number
  }

  export type CourseLoggingCreateManySyllabusContentInput = {
    id?: number
    courseId: number
    userId: string
    materialContentId?: number | null
    examId?: number | null
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamUpdateWithoutSyllabusContentInput = {
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    ExamQuestions?: ExamQuestionUpdateManyWithoutExamNestedInput
    CourseLogging?: CourseLoggingUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutSyllabusContentInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    ExamQuestions?: ExamQuestionUncheckedUpdateManyWithoutExamNestedInput
    CourseLogging?: CourseLoggingUncheckedUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateManyWithoutSyllabusContentInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type MaterialContentUpdateWithoutSyllabusContentInput = {
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    estimatedTime?: IntFieldUpdateOperationsInput | number
    Type?: MaterialContentTypeUpdateOneRequiredWithoutMaterialContentsNestedInput
    Attachments?: MaterialContentAttachmentUpdateManyWithoutMaterialContentNestedInput
    File?: MaterialContentFileUpdateOneWithoutMaterialContentNestedInput
    MaterialContentLearning?: MaterialContentLearningUpdateOneWithoutMaterialContentNestedInput
    MaterialContentTest?: MaterialContentTestUpdateOneWithoutMaterialContentNestedInput
    CourseLogging?: CourseLoggingUpdateManyWithoutMaterialContentNestedInput
  }

  export type MaterialContentUncheckedUpdateWithoutSyllabusContentInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    materialContentTypeId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    estimatedTime?: IntFieldUpdateOperationsInput | number
    Attachments?: MaterialContentAttachmentUncheckedUpdateManyWithoutMaterialContentNestedInput
    File?: MaterialContentFileUncheckedUpdateOneWithoutMaterialContentNestedInput
    MaterialContentLearning?: MaterialContentLearningUncheckedUpdateOneWithoutMaterialContentNestedInput
    MaterialContentTest?: MaterialContentTestUncheckedUpdateOneWithoutMaterialContentNestedInput
    CourseLogging?: CourseLoggingUncheckedUpdateManyWithoutMaterialContentNestedInput
  }

  export type MaterialContentUncheckedUpdateManyWithoutSyllabusContentInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    materialContentTypeId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    estimatedTime?: IntFieldUpdateOperationsInput | number
  }

  export type CourseLoggingUpdateWithoutSyllabusContentInput = {
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Course?: CourseUpdateOneRequiredWithoutCourseLoggingsNestedInput
    User?: UsersUpdateOneRequiredWithoutCourseLoggingNestedInput
    MaterialContent?: MaterialContentUpdateOneWithoutCourseLoggingNestedInput
    Exam?: ExamUpdateOneWithoutCourseLoggingNestedInput
  }

  export type CourseLoggingUncheckedUpdateWithoutSyllabusContentInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    materialContentId?: NullableIntFieldUpdateOperationsInput | number | null
    examId?: NullableIntFieldUpdateOperationsInput | number | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseLoggingUncheckedUpdateManyWithoutSyllabusContentInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    materialContentId?: NullableIntFieldUpdateOperationsInput | number | null
    examId?: NullableIntFieldUpdateOperationsInput | number | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamQuestionCreateManyExamInput = {
    id?: number
    isActive: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    questionText: string
    typeQuestion: $Enums.TypeQuestion
  }

  export type CourseLoggingCreateManyExamInput = {
    id?: number
    courseId: number
    userId: string
    syllabusContentId: number
    materialContentId?: number | null
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamQuestionUpdateWithoutExamInput = {
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    questionText?: StringFieldUpdateOperationsInput | string
    typeQuestion?: EnumTypeQuestionFieldUpdateOperationsInput | $Enums.TypeQuestion
    ExamOptions?: ExamOptionQuestionUpdateManyWithoutExamQuestionNestedInput
  }

  export type ExamQuestionUncheckedUpdateWithoutExamInput = {
    id?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    questionText?: StringFieldUpdateOperationsInput | string
    typeQuestion?: EnumTypeQuestionFieldUpdateOperationsInput | $Enums.TypeQuestion
    ExamOptions?: ExamOptionQuestionUncheckedUpdateManyWithoutExamQuestionNestedInput
  }

  export type ExamQuestionUncheckedUpdateManyWithoutExamInput = {
    id?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    questionText?: StringFieldUpdateOperationsInput | string
    typeQuestion?: EnumTypeQuestionFieldUpdateOperationsInput | $Enums.TypeQuestion
  }

  export type CourseLoggingUpdateWithoutExamInput = {
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Course?: CourseUpdateOneRequiredWithoutCourseLoggingsNestedInput
    User?: UsersUpdateOneRequiredWithoutCourseLoggingNestedInput
    SyllabusContent?: SyllabusContentUpdateOneRequiredWithoutCourseLoggingNestedInput
    MaterialContent?: MaterialContentUpdateOneWithoutCourseLoggingNestedInput
  }

  export type CourseLoggingUncheckedUpdateWithoutExamInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    syllabusContentId?: IntFieldUpdateOperationsInput | number
    materialContentId?: NullableIntFieldUpdateOperationsInput | number | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseLoggingUncheckedUpdateManyWithoutExamInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    syllabusContentId?: IntFieldUpdateOperationsInput | number
    materialContentId?: NullableIntFieldUpdateOperationsInput | number | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamOptionQuestionCreateManyExamQuestionInput = {
    id?: number
    optionText: string
    isTrue?: boolean | null
    reason?: string | null
    order?: number | null
    attachment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamOptionQuestionUpdateWithoutExamQuestionInput = {
    optionText?: StringFieldUpdateOperationsInput | string
    isTrue?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamOptionQuestionUncheckedUpdateWithoutExamQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    optionText?: StringFieldUpdateOperationsInput | string
    isTrue?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamOptionQuestionUncheckedUpdateManyWithoutExamQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    optionText?: StringFieldUpdateOperationsInput | string
    isTrue?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialContentCreateManyTypeInput = {
    id?: number
    title: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    syllabusContentId: number
    estimatedTime: number
  }

  export type MaterialContentUpdateWithoutTypeInput = {
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    estimatedTime?: IntFieldUpdateOperationsInput | number
    SyllabusContent?: SyllabusContentUpdateOneRequiredWithoutMaterialContentsNestedInput
    Attachments?: MaterialContentAttachmentUpdateManyWithoutMaterialContentNestedInput
    File?: MaterialContentFileUpdateOneWithoutMaterialContentNestedInput
    MaterialContentLearning?: MaterialContentLearningUpdateOneWithoutMaterialContentNestedInput
    MaterialContentTest?: MaterialContentTestUpdateOneWithoutMaterialContentNestedInput
    CourseLogging?: CourseLoggingUpdateManyWithoutMaterialContentNestedInput
  }

  export type MaterialContentUncheckedUpdateWithoutTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    syllabusContentId?: IntFieldUpdateOperationsInput | number
    estimatedTime?: IntFieldUpdateOperationsInput | number
    Attachments?: MaterialContentAttachmentUncheckedUpdateManyWithoutMaterialContentNestedInput
    File?: MaterialContentFileUncheckedUpdateOneWithoutMaterialContentNestedInput
    MaterialContentLearning?: MaterialContentLearningUncheckedUpdateOneWithoutMaterialContentNestedInput
    MaterialContentTest?: MaterialContentTestUncheckedUpdateOneWithoutMaterialContentNestedInput
    CourseLogging?: CourseLoggingUncheckedUpdateManyWithoutMaterialContentNestedInput
  }

  export type MaterialContentUncheckedUpdateManyWithoutTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    syllabusContentId?: IntFieldUpdateOperationsInput | number
    estimatedTime?: IntFieldUpdateOperationsInput | number
  }

  export type MaterialContentAttachmentCreateManyMaterialContentInput = {
    id?: number
    thumbnail: string
    path: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseLoggingCreateManyMaterialContentInput = {
    id?: number
    courseId: number
    userId: string
    syllabusContentId: number
    examId?: number | null
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialContentAttachmentUpdateWithoutMaterialContentInput = {
    thumbnail?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialContentAttachmentUncheckedUpdateWithoutMaterialContentInput = {
    id?: IntFieldUpdateOperationsInput | number
    thumbnail?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialContentAttachmentUncheckedUpdateManyWithoutMaterialContentInput = {
    id?: IntFieldUpdateOperationsInput | number
    thumbnail?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseLoggingUpdateWithoutMaterialContentInput = {
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Course?: CourseUpdateOneRequiredWithoutCourseLoggingsNestedInput
    User?: UsersUpdateOneRequiredWithoutCourseLoggingNestedInput
    SyllabusContent?: SyllabusContentUpdateOneRequiredWithoutCourseLoggingNestedInput
    Exam?: ExamUpdateOneWithoutCourseLoggingNestedInput
  }

  export type CourseLoggingUncheckedUpdateWithoutMaterialContentInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    syllabusContentId?: IntFieldUpdateOperationsInput | number
    examId?: NullableIntFieldUpdateOperationsInput | number | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseLoggingUncheckedUpdateManyWithoutMaterialContentInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    syllabusContentId?: IntFieldUpdateOperationsInput | number
    examId?: NullableIntFieldUpdateOperationsInput | number | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UsersCountOutputTypeDefaultArgs instead
     */
    export type UsersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseCountOutputTypeDefaultArgs instead
     */
    export type CourseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryCountOutputTypeDefaultArgs instead
     */
    export type CategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubCategoryCountOutputTypeDefaultArgs instead
     */
    export type SubCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TopicCountOutputTypeDefaultArgs instead
     */
    export type TopicCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TopicCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SyllabusCountOutputTypeDefaultArgs instead
     */
    export type SyllabusCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SyllabusCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SyllabusContentCountOutputTypeDefaultArgs instead
     */
    export type SyllabusContentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SyllabusContentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExamCountOutputTypeDefaultArgs instead
     */
    export type ExamCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExamCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExamQuestionCountOutputTypeDefaultArgs instead
     */
    export type ExamQuestionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExamQuestionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaterialContentTypeCountOutputTypeDefaultArgs instead
     */
    export type MaterialContentTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaterialContentTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaterialContentCountOutputTypeDefaultArgs instead
     */
    export type MaterialContentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaterialContentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsersDefaultArgs instead
     */
    export type UsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseDefaultArgs instead
     */
    export type CourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseCreatorDefaultArgs instead
     */
    export type CourseCreatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseCreatorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseLoggingDefaultArgs instead
     */
    export type CourseLoggingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseLoggingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryDefaultArgs instead
     */
    export type CategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubCategoryDefaultArgs instead
     */
    export type SubCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TopicDefaultArgs instead
     */
    export type TopicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TopicDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseTopicDefaultArgs instead
     */
    export type CourseTopicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseTopicDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SyllabusDefaultArgs instead
     */
    export type SyllabusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SyllabusDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SyllabusContentDefaultArgs instead
     */
    export type SyllabusContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SyllabusContentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExamDefaultArgs instead
     */
    export type ExamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExamDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExamQuestionDefaultArgs instead
     */
    export type ExamQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExamQuestionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExamOptionQuestionDefaultArgs instead
     */
    export type ExamOptionQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExamOptionQuestionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaterialContentTypeDefaultArgs instead
     */
    export type MaterialContentTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaterialContentTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaterialContentDefaultArgs instead
     */
    export type MaterialContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaterialContentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaterialContentLearningDefaultArgs instead
     */
    export type MaterialContentLearningArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaterialContentLearningDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaterialContentTestDefaultArgs instead
     */
    export type MaterialContentTestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaterialContentTestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaterialContentFileDefaultArgs instead
     */
    export type MaterialContentFileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaterialContentFileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaterialContentAttachmentDefaultArgs instead
     */
    export type MaterialContentAttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaterialContentAttachmentDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}